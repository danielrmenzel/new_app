<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>🚀 C Compiler & Debugger Workflow</title>
  <style>
    /* Retro Theme Variables */
    :root {
      --bg-primary: #000000;
      --bg-secondary: #1a1a1a;
      --bg-tertiary: #333333;
      --text-primary: #00ff00;
      --text-secondary: #ffff00;
      --accent-green: #00ff00;
      --accent-red: #ff0000;
      --accent-yellow: #ffff00;
      --accent-pink: #ff00ff;
      --accent-orange: #ffa500;
      --accent-cyan: #00ffff;
      --border-color: #00ff00;
      --shadow: 0 0 10px rgba(0, 255, 0, 0.5);
      --shadow-hover: 0 0 20px rgba(0, 255, 0, 0.8);
      --retro-glow: 0 0 1px currentColor;
    }

    /* Light Theme Variables */
    [data-theme="light"] {
      --bg-primary: #f0f0f0;
      --bg-secondary: #e0e0e0;
      --bg-tertiary: #d0d0d0;
      --text-primary: #006600;
      --text-secondary: #cc6600;
      --accent-green: #006600;
      --accent-red: #cc0000;
      --accent-yellow: #cc6600;
      --accent-pink: #cc0099;
      --accent-orange: #ff6600;
      --accent-cyan: #0066cc;
      --border-color: #006600;
      --shadow: 0 0 10px rgba(0, 102, 0, 0.3);
      --shadow-hover: 0 0 20px rgba(0, 102, 0, 0.5);
      --retro-glow: 0 0 3px currentColor;
    }

    html, body {
      margin: 0;
      padding: 0;
      background: var(--bg-primary);
      color: var(--text-primary);
      font-family: 'Courier New', 'Lucida Console', monospace;
      transition: all 0.3s ease;
      text-shadow: var(--retro-glow);
    }
    
    body {
      display: flex;
      flex-direction: column;
      padding: 2rem;
      gap: 0;
      min-height: 100vh;
    }
    
    h1 {
      color: var(--accent-green);
      text-align: center;
      font-size: 28px;
      font-weight: bold;
      text-shadow: var(--retro-glow);
      letter-spacing: 2px;
      margin-bottom: 2rem;
    }
    
    h2 {
      color: var(--accent-green);
      font-size: 16px;
      font-weight: bold;
      text-shadow: var(--retro-glow);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin: 0 0 1rem 0;
    }
    
    h3 {
      color: var(--accent-green);
      font-size: 14px;
      font-weight: bold;
      text-shadow: var(--retro-glow);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin: 1rem 0 0.5rem 0;
    }

    /* Header Styles */
    .app-header {
      background: var(--bg-secondary);
      padding: 15px;
      border-bottom: 2px solid var(--accent-green);
      box-shadow: var(--shadow);
      position: sticky;
      top: 0;
      z-index: 100;
      border-top: 1px solid var(--accent-green);
    }
    
    .header-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      max-width: 1400px;
      margin: 0 auto;
    }
    
    .app-title-section {
      display: flex;
      flex-direction: column;
    }
    
    .app-title {
      margin: 0;
      font-size: 24px;
      font-weight: bold;
      color: var(--accent-green);
      display: flex;
      align-items: center;
      gap: 10px;
      text-shadow: var(--retro-glow);
      letter-spacing: 2px;
    }
    
    .title-icon {
      font-size: 28px;
      animation: blink 1s infinite;
    }
    
    .app-subtitle {
      margin: 5px 0 0 0;
      color: var(--text-secondary);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-shadow: var(--retro-glow);
    }
    
    .header-controls {
      display: flex;
      gap: 10px;
    }
    
    .theme-toggle, .help-btn {
      background: var(--bg-tertiary);
      color: var(--accent-green);
      border: 2px solid var(--accent-green);
      padding: 6px 12px;
      border-radius: 0;
      cursor: pointer;
      transition: all 0.3s ease;
      text-shadow: var(--retro-glow);
      font-family: inherit;
      text-transform: uppercase;
      font-size: 12px;
    }
    
    .theme-toggle:hover, .help-btn:hover {
      background: var(--accent-green);
      color: var(--bg-primary);
      box-shadow: var(--shadow-hover);
    }
    
    @keyframes blink {
      0% { opacity: 1; }
      50% { opacity: 0.3; }
      100% { opacity: 1; }
    }
    
    /* Main Content Container */
    .main-content {
      padding: 15px;
      max-width: 1400px;
      margin: 0 auto;
      width: 100%;
      display: flex;
      flex-direction: column;
    }

    /* Container Styles */
    .container {
      background: var(--bg-secondary);
      padding: 2rem;
      border: 2px solid var(--border-color);
      border-radius: 0;
      box-shadow: var(--shadow);
      margin-bottom: 2rem;
      transition: all 0.3s ease;
    }
    
    .container:hover {
      box-shadow: var(--shadow-hover);
    }

    /* Status Indicators */
    .status {
      margin: 10px 0;
      padding: 10px;
      border-radius: 0;
      border: 2px solid var(--accent-green);
      text-shadow: var(--retro-glow);
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-align: center;
    }
    
    .status.ready {
      background-color: var(--bg-tertiary);
      color: var(--accent-green);
      border-color: var(--accent-green);
    }
    
    .status.error {
      background-color: var(--bg-tertiary);
      color: var(--accent-red);
      border-color: var(--accent-red);
    }

    /* Three-Column Grid Layout */
    .editor-container {
      display: grid;
      grid-template-columns: minmax(0, 2.8fr) minmax(0, 4.5fr) minmax(0, 2.7fr);
      gap: 20px;
      margin-bottom: 20px;
      min-height: 500px;
      overflow: hidden;
      width: 100%;
    }
    
    .editor-panel, .debugger-panel {
      background: var(--bg-secondary);
      padding: 15px;
      border: 2px solid var(--border-color);
      border-radius: 0;
      box-shadow: var(--shadow);
      transition: all 0.3s ease;
      min-width: 0;
      max-width: 100%;
      overflow: hidden;
      box-sizing: border-box;
    }
    
    .editor-panel:hover, .debugger-panel:hover {
      box-shadow: var(--shadow-hover);
    }
    
    .editor-panel h3, .debugger-panel h3 {
      margin-top: 0;
      word-wrap: break-word;
    }
    
    /* Debugger column specific styling */
    #debuggerColumn .register-section, 
    #debuggerColumn .stack-section {
      margin-bottom: 15px;
    }
    
    #debuggerColumn .register-grid,
    #debuggerColumn .stack-view {
      font-family: monospace;
      font-size: 11px;
      background: var(--bg-primary);
      padding: 8px;
      border: 1px solid var(--border-color);
      overflow-x: auto;
      color: var(--text-primary);
      word-wrap: break-word;
      box-sizing: border-box;
    }
    
    .register, .stack-item {
      padding: 2px 0;
      border-bottom: 1px solid rgba(0, 255, 0, 0.2);
      color: var(--text-secondary);
      word-wrap: break-word;
      overflow-wrap: break-word;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }
    
    .register:last-child, .stack-item:last-child {
      border-bottom: none;
    }
    
    .register:hover, .stack-item:hover {
      background: rgba(0, 255, 0, 0.1);
      color: var(--accent-green);
      white-space: normal;
      overflow: visible;
    }
    
    .reg-name, .stack-addr {
      color: var(--accent-yellow);
    }
    
    .reg-value, .stack-value {
      color: var(--text-primary);
      margin-left: 5px;
    }
    
    /* Responsive Grid - Tablet */
    @media (max-width: 1400px) {
      .editor-container {
        grid-template-columns: minmax(0, 2.8fr) minmax(0, 4.5fr) minmax(0, 2.7fr);
      }
      
      .editor-panel, .debugger-panel {
        font-size: 12px;
      }
    }
    
    @media (max-width: 1200px) {
      .editor-container {
        grid-template-columns: minmax(0, 2.8fr) minmax(0, 4.5fr) minmax(0, 2.7fr);
      }
    }
    
    /* Responsive Grid - Small Tablet */
    @media (max-width: 1024px) {
      .editor-container {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto;
        gap: 15px;
      }
      
      .main-content {
        padding: 10px;
      }
      
      .header-content {
        flex-direction: column;
        gap: 10px;
        text-align: center;
      }
      
      .app-title {
        font-size: 20px;
      }
      
      .floating-actions {
        bottom: 10px;
        right: 10px;
      }
      
      .fab {
        width: 45px;
        height: 45px;
        font-size: 20px;
      }
    }
    
    /* Mobile */
    @media (max-width: 768px) {
      .editor-container {
        gap: 10px;
      }
      
      .container {
        padding: 1rem;
        margin-bottom: 1rem;
      }
      
      .app-header {
        padding: 10px;
      }
      
      .app-title {
        font-size: 18px;
        letter-spacing: 1px;
      }
      
      .app-subtitle {
        font-size: 10px;
      }
      
      .theme-toggle, .help-btn {
        padding: 4px 8px;
        font-size: 10px;
      }
      
      .button-status-container {
        flex-direction: column;
        gap: 10px;
      }
      
      .button-group {
        flex-wrap: wrap;
        gap: 5px;
      }
      
      .button-group button, .file-input-label {
        font-size: 12px;
        padding: 8px 12px;
      }
      
      .tab-button {
        font-size: 12px;
        padding: 8px 12px;
      }
      
      .tab-header {
        flex-wrap: wrap;
        gap: 0;
      }
      
      .status {
        min-width: auto;
      }
    }
    
    /* Very Small Mobile */
    @media (max-width: 480px) {
      .main-content {
        padding: 5px;
      }
      
      .editor-panel {
        padding: 10px;
      }
      
      .debugger-panel {
        padding: 10px;
      }
      
      .app-title {
        font-size: 16px;
      }
      
      .floating-actions {
        bottom: 5px;
        right: 5px;
        gap: 5px;
      }
      
      .fab {
        width: 40px;
        height: 40px;
        font-size: 18px;
      }
      
      .code-editor {
        min-height: 250px !important;
        font-size: 12px !important;
      }
    }
    
    textarea {
      width: 100%;
      min-height: 400px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      border: 2px solid var(--border-color);
      border-radius: 0;
      padding: 10px;
      resize: vertical;
      background: var(--bg-primary);
      color: var(--text-primary);
      text-shadow: var(--retro-glow);
      overflow-y: auto;
      box-sizing: border-box;
    }
    
    textarea:focus {
      outline: none;
      box-shadow: var(--shadow-hover);
    }
    
    input[type="file"] {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 2px solid var(--border-color);
      padding: 10px;
      border-radius: 0;
      font-family: inherit;
      margin-bottom: 1rem;
    }

    /* Output Areas */
    .output {
      white-space: pre;
      background: var(--bg-primary);
      border: 2px solid var(--border-color);
      padding: 1rem;
      border-radius: 0;
      overflow: auto;
      font-family: 'Courier New', monospace;
      color: var(--text-primary);
      text-shadow: var(--retro-glow);
      box-sizing: border-box;
      width: 100%;
    }
    
    #output {
      height: 30vh;
    }
    
    #compilationOutput {
      max-height: 150px;
      overflow-y: auto;
      min-height: 50px;
      margin-top: 1rem;
    }
    
    #disassembly {
      height: auto;
      min-height: 200px;
      max-height: none;
      font-size: 12px;
      overflow-y: visible;
    }
    
    .highlighted-line {
      background-color: var(--accent-green) !important;
      color: var(--bg-primary) !important;
      font-weight: bold;
    }
    
    /* C Function Highlighting */
    .c-function-highlight-0 {
      background-color: rgba(255, 152, 0, 0.15) !important;
      border-left: 4px solid #FF9800 !important;
    }
    
    .c-function-highlight-1 {
      background-color: rgba(156, 39, 176, 0.15) !important;
      border-left: 4px solid #9C27B0 !important;
    }
    
    .c-function-highlight-2 {
      background-color: rgba(3, 169, 244, 0.15) !important;
      border-left: 4px solid #03A9F4 !important;
    }
    
    .c-function-highlight-3 {
      background-color: rgba(76, 175, 80, 0.15) !important;
      border-left: 4px solid #4CAF50 !important;
    }
    
    .c-function-highlight-4 {
      background-color: rgba(244, 67, 54, 0.15) !important;
      border-left: 4px solid #F44336 !important;
    }
    
    .c-function-highlight-active {
      background-color: rgba(76, 175, 80, 0.2) !important;
      border-left: 6px solid #4CAF50 !important;
      border-right: 2px solid rgba(76, 175, 80, 0.5) !important;
      box-shadow: inset 0 0 8px rgba(76, 175, 80, 0.3), inset 3px 0 0 rgba(76, 175, 80, 0.6);
      transition: all 0.2s ease-in-out;
    }
    
    #emuOutput, #executionTrace {
      white-space: pre;
      background: var(--bg-primary);
      border: 2px solid var(--border-color);
      padding: 1rem;
      border-radius: 0;
      margin-top: 1rem;
      min-height: 15vh;
      max-height: 60vh;
      overflow-y: auto;
      font-family: monospace;
      color: var(--text-primary);
      text-shadow: var(--retro-glow);
      box-sizing: border-box;
    }

    /* Button Styles */
    button {
      background: var(--bg-tertiary);
      color: var(--accent-green);
      border: 2px solid var(--accent-green);
      padding: 8px 12px;
      cursor: pointer;
      border-radius: 0;
      font-size: 12px;
      transition: all 0.3s ease;
      box-shadow: var(--shadow);
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-family: inherit;
      text-shadow: var(--retro-glow);
      margin-right: 10px;
      margin-bottom: 1rem;
      display: inline-block;
    }
    
    button:hover {
      background: var(--accent-green);
      color: var(--bg-primary);
      box-shadow: var(--shadow-hover);
      text-shadow: none;
    }
    
    button:disabled {
      background: var(--bg-tertiary);
      color: #666666;
      border-color: #666666;
      cursor: not-allowed;
      box-shadow: none;
    }
    
    button:active {
      transform: none;
    }

    /* Control Button Styles */
    .control-btn {
      background: var(--bg-tertiary);
      color: var(--accent-orange);
      border-color: var(--accent-orange);
    }
    
    .control-btn:hover {
      background: var(--accent-orange);
      color: var(--bg-primary);
    }

    /* Debugger Styles */
    .debugger-container {
      display: flex;
      gap: 1rem;
      margin-top: 1rem;
    }
    
    .debugger-panel {
      flex: 1;
      background: var(--bg-secondary);
      border: 2px solid var(--border-color);
      border-radius: 0;
      padding: 1rem;
      box-shadow: var(--shadow);
      transition: all 0.3s ease;
    }
    
    .debugger-panel:hover {
      box-shadow: var(--shadow-hover);
    }
    
    .debugger-controls {
      margin: 1rem 0;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    /* Current Instruction Display */
    .current-instruction {
      font-family: monospace;
      background: var(--bg-secondary);
      border: 2px solid var(--accent-yellow);
      padding: 0.5rem;
      border-radius: 0;
      margin-bottom: 1rem;
      color: var(--accent-yellow);
      text-shadow: var(--retro-glow);
      box-shadow: var(--shadow);
    }
    
    .current-instruction .addr {
      color: var(--text-secondary);
      margin-right: 1rem;
    }
    
    .current-instruction .mnemonic {
      font-weight: bold;
      color: var(--accent-green);
      margin-right: 0.5rem;
    }
    
    .current-instruction .operands {
      color: var(--text-primary);
    }

    /* Register and Stack Styles */
    .register-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem;
      font-family: monospace;
    }
    
    .register {
      display: flex;
      justify-content: space-between;
      padding: 2px 5px;
      border: 1px solid var(--border-color);
      border-radius: 0;
      background: var(--bg-primary);
      transition: all 0.3s ease;
    }
    
    .register:hover {
      background-color: var(--bg-tertiary);
      cursor: pointer;
      box-shadow: var(--shadow);
    }
    
    .reg-name {
      font-weight: bold;
      color: var(--accent-cyan);
    }
    
    .reg-value {
      color: var(--text-primary);
    }
    
    .stack-view {
      font-family: monospace;
    }
    
    .stack-item {
      display: flex;
      justify-content: space-between;
      padding: 2px 5px;
      border-bottom: 1px solid var(--border-color);
      background: var(--bg-primary);
    }
    
    .stack-addr {
      color: var(--accent-cyan);
    }
    
    .stack-value {
      color: var(--text-primary);
    }

    /* Custom Scrollbars */
    *::-webkit-scrollbar {
      width: 12px;
      height: 12px;
    }
    
    *::-webkit-scrollbar-track {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
    }
    
    *::-webkit-scrollbar-thumb {
      background: var(--accent-green);
      border-radius: 0;
      border: 1px solid var(--bg-primary);
    }
    
    *::-webkit-scrollbar-thumb:hover {
      background: var(--accent-yellow);
    }
    
    *::-webkit-scrollbar-corner {
      background: var(--bg-secondary);
    }
    
    /* Animation for blinking elements */
    @keyframes blink {
      0% { opacity: 1; }
      50% { opacity: 0.3; }
      100% { opacity: 1; }
    }
    
    /* Status indicators with animation */
    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 0;
      margin-right: 8px;
      animation: blink 1s infinite;
      border: 1px solid currentColor;
    }
    
    .status-success {
      background: var(--accent-green);
      border-color: var(--accent-green);
    }
    
    .status-error {
      background: var(--accent-red);
      border-color: var(--accent-red);
    }
    
    .status-warning {
      background: var(--accent-yellow);
      border-color: var(--accent-yellow);
    }



    /* Button and Status Layout */
    .button-status-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 20px;
      margin-bottom: 1rem;
    }
    
    .button-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .button-group button, .file-input-label {
      margin-right: 0;
      margin-bottom: 0;
    }
    
    /* File input styled as button */
    .file-input-label {
      display: inline-block;
      padding: 8px 16px;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 2px solid var(--border-color);
      border-radius: 0;
      cursor: pointer;
      font-family: inherit;
      font-size: 14px;
      font-weight: bold;
      text-shadow: var(--retro-glow);
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .file-input-label:hover {
      background: var(--accent-green);
      color: var(--bg-primary);
      box-shadow: var(--shadow-hover);
    }
    
    /* Tab Interface Styles */
    .tab-container {
      width: 100%;
    }
    
    .tab-header {
      display: flex;
      border-bottom: 2px solid var(--border-color);
      margin-bottom: 20px;
    }
    
    .tab-button {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      border: 2px solid var(--border-color);
      border-bottom: none;
      padding: 12px 20px;
      border-radius: 0;
      cursor: pointer;
      font-family: inherit;
      font-size: 14px;
      font-weight: bold;
      text-shadow: var(--retro-glow);
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-right: -2px;
    }
    
    .tab-button:hover {
      background: var(--accent-green);
      color: var(--bg-primary);
      box-shadow: var(--shadow-hover);
    }
    
    .tab-button.active {
      background: var(--bg-secondary);
      color: var(--accent-green);
      border-color: var(--accent-green);
      border-bottom: 2px solid var(--bg-secondary);
      z-index: 1;
      position: relative;
      margin-bottom: -2px;
    }
    
    .tab-content {
      position: relative;
    }
    
    .tab-panel {
      display: none;
      animation: fadeIn 0.3s ease-in-out;
      overflow: hidden;
      max-width: 100%;
      box-sizing: border-box;
    }
    
    .tab-panel.active {
      display: block;
    }
    
    .tab-panel > div {
      overflow-x: auto;
      overflow-y: auto;
      max-height: 400px;
      word-wrap: break-word;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    /* Code Editor and Output Constraints */
    .code-editor {
      white-space: pre-wrap !important;
      word-wrap: break-word;
      overflow-x: auto;
      overflow-y: auto;
      max-width: 100%;
      box-sizing: border-box;
    }
    
    .output {
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow-x: auto;
      overflow-y: auto;
      max-width: 100%;
      max-height: 300px;
      box-sizing: border-box;
    }
    
    #disassembly {
      font-family: 'Courier New', monospace;
      font-size: 12px;
      line-height: 1.4;
      height: auto;
      max-height: none;
    }
    
    #compilationOutput {
      font-size: 12px;
      font-family: 'Courier New', monospace;
      line-height: 1.3;
    }
    
    .button-status-container .status {
      margin: 0;
      flex-shrink: 0;
      min-width: 300px;
    }

    .highlight {
      background-color: yellow;
    }
    
    /* CodeMirror highlighting for C functions */
    .CodeMirror-line-background.highlight-line {
      background-color: var(--accent-yellow) !important;
      opacity: 0.3;
    }
    
    .CodeMirror .CodeMirror-line.highlight-line {
      background-color: rgba(255, 255, 0, 0.2) !important;
    }
    
    /* Alternative approach - background class */
    .CodeMirror .highlight-line {
      background-color: var(--accent-yellow) !important;
      opacity: 0.2;
    }

    /* Collapsible Sections */
    .collapsible {
      margin-bottom: 2rem;
    }
    
    .collapsible-toggle {
      background: var(--bg-tertiary);
      color: var(--accent-green);
      border: 2px solid var(--accent-green);
      padding: 8px 12px;
      cursor: pointer;
      border-radius: 0;
      font-size: 12px;
      transition: all 0.3s ease;
      box-shadow: var(--shadow);
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-family: inherit;
      text-shadow: var(--retro-glow);
      margin-bottom: 1rem;
      display: inline-block;
    }
    
    .collapsible-toggle:hover {
      background: var(--accent-green);
      color: var(--bg-primary);
      box-shadow: var(--shadow-hover);
      text-shadow: none;
    }
    
    .collapsible-content {
      display: block;
      overflow: hidden;
      transition: max-height 0.3s ease, padding 0.3s ease;
    }
    
    .collapsible-content.collapsed {
      display: none;
      max-height: 0;
      padding: 0;
    }

    /* Floating Action Buttons */
    .floating-actions {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .fab {
      background: var(--accent-green);
      color: var(--bg-primary);
      border: none;
      padding: 12px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 24px;
      box-shadow: var(--shadow);
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .fab:hover {
      background: var(--bg-primary);
      color: var(--accent-green);
      box-shadow: var(--shadow-hover);
    }
    
    .fab:active {
      transform: scale(0.95);
    }
    
    /* Specific FAB colors */
    .fab-compile {
      background: var(--accent-green);
    }
    
    .fab-debug {
      background: var(--accent-orange);
    }
    
    .fab-step {
      background: var(--accent-yellow);
    }
    
    /* Arrow Indicator for Collapsible Sections */
    .collapse-arrow {
      font-size: 12px;
      margin-left: 8px;
      transition: transform 0.3s ease;
      display: inline-block;
      vertical-align: middle;
    }
    
    .collapsed .collapse-arrow {
      transform: rotate(-90deg);
    }
  </style>
  <!-- CodeMirror -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/clike/clike.min.js"></script>
  
  <style>
    /* CodeMirror theme override to match current retro theme */
    .CodeMirror {
      background: var(--bg-primary) !important;
      color: var(--text-primary) !important;
      border: 2px solid var(--border-color) !important;
      font-family: 'Courier New', monospace !important;
      font-size: 14px !important;
      text-shadow: var(--retro-glow) !important;
      min-height: 400px !important;
    }
    
    .CodeMirror-gutters {
      background: var(--bg-secondary) !important;
      border-right: 1px solid var(--border-color) !important;
    }
    
    .CodeMirror-linenumber {
      color: var(--text-secondary) !important;
    }
    
    .CodeMirror-cursor {
      border-left: 1px solid var(--accent-green) !important;
    }
    
    .CodeMirror-selected {
      background: rgba(0, 255, 0, 0.2) !important;
    }
    
    /* C syntax highlighting with retro colors */
    .cm-keyword { color: var(--accent-cyan) !important; }
    .cm-type { color: var(--accent-yellow) !important; }
    .cm-string { color: var(--accent-pink) !important; }
    .cm-comment { color: var(--text-secondary) !important; opacity: 0.8; }
    .cm-number { color: var(--accent-orange) !important; }
    .cm-operator { color: var(--text-primary) !important; }
    .cm-variable { color: var(--text-primary) !important; }
    .cm-def { color: var(--accent-green) !important; }
    .cm-atom { color: var(--accent-orange) !important; }
    
    @media (max-width: 768px) {
      .CodeMirror {
        min-height: 250px !important;
        font-size: 12px !important;
      }
    }
  </style>
</head>
<body>
  
  <!-- App Header -->
  <header class="app-header">
    <div class="header-content">
      <div class="app-title-section">
        <h1 class="app-title">
          <span class="title-icon">🚀</span>
          C Compiler & Debugger Workflow
        </h1>
        <p class="app-subtitle">TinyCC WebAssembly + Unicorn Engine Debugger</p>
      </div>
      <div class="header-controls">
        <button class="theme-toggle" onclick="toggleTheme()">🌓 Theme</button>
        <button class="help-btn" onclick="showHelp()">❓ Help</button>
      </div>
    </div>
  </header>

  <div class="main-content">
  <!-- Floating Action Buttons -->
  <div class="floating-actions">
    <button class="fab fab-compile" onclick="quickCompileExact()">⚡</button>
    <button class="fab fab-debug" onclick="initializeDebugger()">🔧</button>
    <button class="fab fab-step" onclick="stepInstruction()">⏭️</button>
    <button class="fab fab-run" onclick="runUntilHalt()" style="display: none;">▶️</button>
    <button class="fab fab-stop" onclick="stopExecution()" style="display: none;">⏹️</button>
  </div>

  <!-- Collapsible Sections with Improved Styling -->
  <div class="collapsible-section">
    <div class="collapsible-header" onclick="toggleCollapsible(this)">
      📝 Step 1: Write & Compile C Code
      <span class="collapse-arrow">▼</span>
    </div>
    <div class="collapsible-content">
      <div class="editor-container">
        <div class="editor-panel">
          <h3>C Source Code</h3>
          <textarea id="sourceCode">int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int main() {
    volatile int x = 20;
    volatile int y = 10;
    volatile int sum = add(x, y);
    volatile int diff = subtract(x, y);
    return sum + diff;
}</textarea>
          
          <h3 style="margin-top: 20px;">Compilation Log</h3>
          <div id="compilationOutput" class="output" style="margin-top: 10px;">Click a compilation option to start...</div>
        </div>
        <div class="editor-panel">
          <h3>Assembly Instructions</h3>
          <div id="disassembly" class="output">Disassembly will appear here after loading object file...</div>
        </div>
        <div class="debugger-panel" id="debuggerColumn">
          <!-- Registers Panel -->
          <div class="register-section">
            <h3>Registers</h3>
            <div id="registerGrid" class="register-grid">
              <div class="register">
                <span class="reg-name">RAX:</span>
                <span class="reg-value">0x0000000000000000</span>
              </div>
              <div class="register">
                <span class="reg-name">RBX:</span>
                <span class="reg-value">0x0000000000000000</span>
              </div>
              <div class="register">
                <span class="reg-name">RCX:</span>
                <span class="reg-value">0x0000000000000000</span>
              </div>
              <div class="register">
                <span class="reg-name">RDX:</span>
                <span class="reg-value">0x0000000000000000</span>
              </div>
              <div class="register">
                <span class="reg-name">RSI:</span>
                <span class="reg-value">0x0000000000000000</span>
              </div>
              <div class="register">
                <span class="reg-name">RDI:</span>
                <span class="reg-value">0x0000000000000000</span>
              </div>
              <div class="register">
                <span class="reg-name">RSP:</span>
                <span class="reg-value">0x0000000000000000</span>
              </div>
              <div class="register">
                <span class="reg-name">RBP:</span>
                <span class="reg-value">0x0000000000000000</span>
              </div>
              <div class="register">
                <span class="reg-name">RIP:</span>
                <span class="reg-value">0x0000000000000000</span>
              </div>
              <div class="register">
                <span class="reg-name">RFLAGS:</span>
                <span class="reg-value">0x0000000000000000</span>
              </div>
            </div>
          </div>
          
          <!-- Stack Panel -->
          <div class="stack-section" style="margin-top: 20px;">
            <h3>Stack</h3>
            <div id="stackView" class="stack-view">
              <div class="stack-item">
                <span class="stack-addr">0x0000000000000000:</span>
                <span class="stack-value">0x0000000000000000</span>
              </div>
              <div class="stack-item">
                <span class="stack-addr">0x0000000000000008:</span>
                <span class="stack-value">0x0000000000000000</span>
              </div>
              <div class="stack-item">
                <span class="stack-addr">0x0000000000000010:</span>
                <span class="stack-value">0x0000000000000000</span>
              </div>
              <div class="stack-item">
                <span class="stack-addr">0x0000000000000018:</span>
                <span class="stack-value">0x0000000000000000</span>
              </div>
              <div class="stack-item">
                <span class="stack-addr">0x0000000000000020:</span>
                <span class="stack-value">0x0000000000000000</span>
              </div>
              <div class="stack-item">
                <span class="stack-addr">0x0000000000000028:</span>
                <span class="stack-value">0x0000000000000000</span>
              </div>
              <div class="stack-item">
                <span class="stack-addr">0x0000000000000030:</span>
                <span class="stack-value">0x0000000000000000</span>
              </div>
              <div class="stack-item">
                <span class="stack-addr">0x0000000000000038:</span>
                <span class="stack-value">0x0000000000000000</span>
              </div>
              <div class="stack-item">
                <span class="stack-addr">0x0000000000000040:</span>
                <span class="stack-value">0x0000000000000000</span>
              </div>
              <div class="stack-item">
                <span class="stack-addr">0x0000000000000048:</span>
                <span class="stack-value">0x0000000000000000</span>
              </div>
              <div class="stack-item">
                <span class="stack-addr">0x0000000000000050:</span>
                <span class="stack-value">0x0000000000000000</span>
              </div>
              <div class="stack-item">
                <span class="stack-addr">0x0000000000000058:</span>
                <span class="stack-value">0x0000000000000000</span>
              </div>
              <div class="stack-item">
                <span class="stack-addr">0x0000000000000060:</span>
                <span class="stack-value">0x0000000000000000</span>
              </div>
              <div class="stack-item">
                <span class="stack-addr">0x0000000000000068:</span>
                <span class="stack-value">0x0000000000000000</span>
              </div>
              <div class="stack-item">
                <span class="stack-addr">0x0000000000000070:</span>
                <span class="stack-value">0x0000000000000000</span>
              </div>
              <div class="stack-item">
                <span class="stack-addr">0x0000000000000078:</span>
                <span class="stack-value">0x0000000000000000</span>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="button-status-container">
        <div class="button-group">
          <button id="quickBtn" onclick="quickCompileExact()" disabled>⚡ Quick Compile (Exact)</button>
          <button id="downloadBtn" onclick="downloadResult()" disabled>📥 Download</button>
          <button onclick="clearOutput()">🗑 Clear</button>
          
          <!-- File input styled as button -->
          <label for="fileInput" class="file-input-label">
            📂 Browse .o File
            <input type="file" id="fileInput" accept=".o,.elf" style="display: none;" />
          </label>
          
          <button id="runUnicorn" disabled>🔧 Initialize Debugger</button>
          <button id="stepBtn" class="control-btn" disabled>⏭️ Step Into</button>
          <button id="runBtn" class="control-btn" disabled>▶️ Run</button>
          <button id="stopBtn" class="control-btn" disabled style="display: none;">⏹️ Stop</button>
          <button id="resetBtn" class="control-btn" disabled>🔄 Reset</button>
        </div>
        <div id="status" class="status ready" data-status="ready">
          TinyCC WebAssembly Ready
        </div>
      </div>
    </div>
  </div>

  <!-- Main Tabbed Container -->
  <div class="container">
    <div class="tab-container">
      <div class="tab-header">
        <button class="tab-button active" onclick="switchTab('elf-analysis')">📂 ELF Analysis</button>
        <button class="tab-button" onclick="switchTab('debug-execution')">🐛 Debug Execution</button>
        <button class="tab-button" onclick="switchTab('execution-log')">📝 Execution Log</button>
        <button class="tab-button" onclick="switchTab('step-analysis')">📊 Step Analysis</button>
      </div>
      
      <div class="tab-content">
        <!-- ELF Analysis Tab -->
        <div id="elf-analysis" class="tab-panel active">
          <h3>Object File Analysis</h3>
          <div id="output"></div>
        </div>
        
        <!-- Debug Execution Tab -->
        <div id="debug-execution" class="tab-panel">
          <h3>Execution Trace</h3>
          <div id="executionTrace"></div>
        </div>
        
        <!-- Execution Log Tab -->
        <div id="execution-log" class="tab-panel">
          <h3>Execution Log</h3>
          <div id="emuOutput"></div>
        </div>
        
        <!-- Step Analysis Tab -->
        <div id="step-analysis" class="tab-panel">
          <h3>Step Analysis</h3>
          <div id="stepAnalysisOutput" style="font-family: monospace; font-size: 12px; white-space: pre-line;"></div>
        </div>
      </div>
    </div>
  </div>


  <!-- Dependencies (update as needed) -->
  <script src="jquery-3.1.1.min.js"></script>
  
  <script>
    // Initialize CodeMirror for C source code
    let sourceCodeEditor;
    
    // Helper function to get source code content
    function getSourceCode() {
      return sourceCodeEditor ? sourceCodeEditor.getValue() : document.getElementById('sourceCode').value;
    }
    
    document.addEventListener('DOMContentLoaded', function() {
      const textarea = document.getElementById('sourceCode');
      sourceCodeEditor = CodeMirror.fromTextArea(textarea, {
        mode: 'text/x-csrc',
        lineNumbers: true,
        theme: 'default',
        indentUnit: 4,
        tabSize: 4,
        indentWithTabs: false,
        lineWrapping: false,
        matchBrackets: true,
        autoCloseBrackets: true,
        showCursorWhenSelecting: true,
        viewportMargin: Infinity,
        extraKeys: {
          "Tab": function(cm) {
            if (cm.somethingSelected()) {
              cm.indentSelection("add");
            } else {
              cm.replaceSelection("    ", "end");
            }
          }
        }
      });
    });
  </script>
  
  <script src="unicorn-x86.min.js"></script>
  <script src="capstone-x86.min.js"></script>
  <script>
    // Wait for Unicorn module to load
    var UnicornModule = uc;
    
    // UnicornDebugger class for step-by-step execution
    class UnicornDebugger {
      constructor(engine, is64bit, entryPoint) {
        this.engine = engine;
        this.is64bit = is64bit;
        this.entryPoint = entryPoint;
        this.currentAddress = entryPoint;
        this.breakpoints = new Set();
        this.isRunning = false;
        this.isPaused = false;
        this.disasm = new cs.Capstone(cs.ARCH_X86, is64bit ? cs.MODE_64 : cs.MODE_32);
        this.executionLog = [];
        this.executionTrace = [];
        this.lastLoggedAddress = null;
        
        // C function highlighting system
        this.functionRanges = new Map();
        this.lineMapping = new Map();
        this.currentHighlightedFunction = null;
        this.currentHighlightedColor = null;
        this.functionColors = new Map();
        
        // Set initial RIP/EIP
        if (is64bit) {
          this.engine.reg_write_i64(UnicornModule.X86_REG_RIP, entryPoint);
        } else {
          this.engine.reg_write_i32(UnicornModule.X86_REG_EIP, entryPoint);
        }
        
        this.setupHooks();
      }
      
      setupHooks() {
        // Hook for tracking execution
        this.engine.hook_add(UnicornModule.HOOK_CODE, (engine, address, size) => {
          this.currentAddress = address;
          
          // Log to execution trace - only if not already logged
          if (!this.lastLoggedAddress || this.lastLoggedAddress !== address) {
            this.logToExecutionTrace(address);
            this.lastLoggedAddress = address;
          }
          
          if (this.breakpoints.has(address)) {
            this.isPaused = true;
            this.isRunning = false;
            console.log(`Breakpoint hit at 0x${address.toString(16)} - Program terminated`);
            this.updateUI();
            // For the exit breakpoint, completely stop execution
            if (address === 0x12345000) {
              console.log('Program completed successfully');
              document.getElementById('emuOutput').textContent += '\nProgram completed successfully.\n';
            }
            return false; // Stop execution
          }
        });
        
        // Hook for halt instruction - use the breakpoint instead since HOOK_INSN may not be available
        // The breakpoint at 0x12345000 will handle program termination
        
        // Hook for unmapped memory
        this.engine.hook_add(UnicornModule.HOOK_MEM_UNMAPPED, (engine, type, address, size, value) => {
          console.log(`Unmapped memory access: type=${type}, addr=0x${address.toString(16)}, size=${size}`);
          try {
            // Skip NULL pointer accesses - these are usually invalid
            if (address === 0) {
              console.log('Detected NULL pointer access - stopping execution');
              this.isPaused = true;
              this.isRunning = false;
              return false;
            }
            
            const alignedAddr = Math.floor(address / 0x1000) * 0x1000;
            engine.mem_map(alignedAddr, 0x1000, UnicornModule.PROT_ALL);
            console.log(`Mapped dummy page at 0x${alignedAddr.toString(16)}`);
            return true;
          } catch(e) {
            console.log(`Failed to map dummy page: ${e.message}`);
            this.isPaused = true;
            this.isRunning = false;
            return false;
          }
        });
        
      }
      
      stepInstruction() {
        try {
          this.isPaused = false;
          const startAddr = this.getCurrentPC();
          
          // Capture pre-execution state for step analysis
          const preState = this.captureStepState();
          
          // Log instruction before execution
          this.logInstruction(startAddr);
          
          // Try to get instruction length first
          let instrLength = 1;
          let instructionText = '';
          try {
            const instrBytes = this.engine.mem_read(startAddr, 16);
            const instructions = this.disasm.disasm(instrBytes, startAddr, 1);
            if (instructions.length > 0) {
              instrLength = instructions[0].size;
              instructionText = `${instructions[0].mnemonic} ${instructions[0].op_str}`;
              console.log(`Executing: ${instructionText} at 0x${startAddr.toString(16)}`);
            }
          } catch(e) {
            console.log('Could not disassemble instruction at 0x' + startAddr.toString(16));
          }
          
          // Execute exactly one instruction with proper end address
          this.engine.emu_start(startAddr, startAddr + instrLength, 0, 1);
          this.currentAddress = this.getCurrentPC();
          
          // Capture post-execution state and log step analysis
          const postState = this.captureStepState();
          this.logStepAnalysis(startAddr, instructionText, preState, postState);
          
          // Log execution trace AFTER instruction executes
          this.logExecutedInstruction();
          
          // Clear last logged address for next instruction
          this.lastLoggedAddress = null;
          
          // Log detailed debug info to console
          this.logDebugState(startAddr, instructionText);
          
          this.updateUI();
          this.highlightCurrentLine();
          this.highlightCFunction(this.currentAddress);
        } catch(e) {
          console.error('Step error:', e);
          const errorMsg = e.message || e.toString();
          
          // Check for specific error types
          if (errorMsg.includes('UC_ERR_INSN_INVALID')) {
            const pc = this.getCurrentPC();
            document.getElementById('emuOutput').textContent += `Invalid instruction at 0x${pc.toString(16)}\n`;
          } else if (errorMsg.includes('UC_ERR_FETCH_UNMAPPED')) {
            const pc = this.getCurrentPC();
            document.getElementById('emuOutput').textContent += `Unmapped instruction fetch at 0x${pc.toString(16)}\n`;
          } else {
            document.getElementById('emuOutput').textContent += `Step error: ${errorMsg}\n`;
          }
          
          // Show final return value when execution stops
          try {
            const returnValue = this.is64bit ? 
              this.engine.reg_read_i64(UnicornModule.X86_REG_RAX) :
              this.engine.reg_read_i32(UnicornModule.X86_REG_EAX);
            document.getElementById('emuOutput').textContent += `\nProgram finished. Return value: ${returnValue} (0x${returnValue.toString(16)})\n`;
          } catch(e) {
            // Ignore if we can't read registers
          }
          
          this.isPaused = true;
          this.isRunning = false;
          this.updateUI();
        }
      }
      
      runUntilHalt() {
        if (this.isRunning) {
          console.log('Already running');
          return;
        }
        
        this.isRunning = true;
        this.isPaused = false;
        this.executionCount = 0;
        this.maxInstructions = 10000; // Safety limit
        
        console.log('Starting continuous execution until HLT...');
        document.getElementById('emuOutput').textContent += 'Running until halt...\n';
        
        this.updateButtonStates();
        this.continueExecution();
      }
      
      continueExecution() {
        if (!this.isRunning || this.isPaused) {
          return;
        }
        
        // Safety check
        if (this.executionCount >= this.maxInstructions) {
          console.log('Maximum instruction limit reached - stopping execution');
          document.getElementById('emuOutput').textContent += `\nExecution stopped: ${this.maxInstructions} instruction limit reached\n`;
          this.stopExecution();
          return;
        }
        
        try {
          const startAddr = this.getCurrentPC();
          
          // Check for halt instruction before execution
          if (this.isHaltInstruction(startAddr)) {
            console.log('HLT instruction encountered - stopping execution');
            document.getElementById('emuOutput').textContent += '\nHLT instruction reached - program terminated\n';
            this.stopExecution();
            return;
          }
          
          // Execute one step
          this.stepInstruction();
          this.executionCount++;
          
          // Continue execution after small delay for UI responsiveness
          setTimeout(() => this.continueExecution(), 5);
          
        } catch(e) {
          console.error('Execution error:', e);
          document.getElementById('emuOutput').textContent += `\nExecution stopped due to error: ${e.message}\n`;
          this.stopExecution();
        }
      }
      
      stopExecution() {
        this.isRunning = false;
        this.isPaused = true;
        console.log(`Execution stopped after ${this.executionCount} instructions`);
        document.getElementById('emuOutput').textContent += `\nExecution stopped. Instructions executed: ${this.executionCount}\n`;
        this.updateButtonStates();
        this.updateUI();
      }
      
      isHaltInstruction(address) {
        try {
          const instrBytes = this.engine.mem_read(address, 16);
          const instructions = this.disasm.disasm(instrBytes, address, 1);
          if (instructions.length > 0) {
            const mnemonic = instructions[0].mnemonic.toLowerCase();
            return mnemonic === 'hlt';
          }
        } catch(e) {
          // If we can't read the instruction, assume it's not halt
          return false;
        }
        return false;
      }
      
      updateButtonStates() {
        const runBtn = document.getElementById('runBtn');
        const stopBtn = document.getElementById('stopBtn');
        const stepBtn = document.getElementById('stepBtn');
        const resetBtn = document.getElementById('resetBtn');
        
        const fabRun = document.querySelector('.fab-run');
        const fabStop = document.querySelector('.fab-stop');
        const fabStep = document.querySelector('.fab-step');
        
        if (this.isRunning) {
          // During execution: hide run, show stop, disable step/reset
          if (runBtn) { runBtn.style.display = 'none'; }
          if (stopBtn) { stopBtn.style.display = 'inline-block'; stopBtn.disabled = false; }
          if (stepBtn) { stepBtn.disabled = true; }
          if (resetBtn) { resetBtn.disabled = true; }
          
          if (fabRun) { fabRun.style.display = 'none'; }
          if (fabStop) { fabStop.style.display = 'block'; fabStop.disabled = false; }
          if (fabStep) { fabStep.disabled = true; fabStep.style.opacity = '0.5'; }
        } else {
          // When stopped: show run, hide stop, enable step/reset
          if (runBtn) { runBtn.style.display = 'inline-block'; runBtn.disabled = false; }
          if (stopBtn) { stopBtn.style.display = 'none'; }
          if (stepBtn) { stepBtn.disabled = false; }
          if (resetBtn) { resetBtn.disabled = false; }
          
          if (fabRun) { fabRun.style.display = 'block'; fabRun.disabled = false; }
          if (fabStop) { fabStop.style.display = 'none'; }
          if (fabStep) { fabStep.disabled = false; fabStep.style.opacity = '1'; }
        }
      }
      
      reset() {
        this.currentAddress = this.entryPoint;
        this.executionLog = [];
        this.executionTrace = [];
        this.lastLoggedAddress = null;
        this.isRunning = false;
        this.isPaused = false;
        this.executionCount = 0;
        
        if (this.is64bit) {
          this.engine.reg_write_i64(UnicornModule.X86_REG_RIP, this.entryPoint);
        } else {
          this.engine.reg_write_i32(UnicornModule.X86_REG_EIP, this.entryPoint);
        }
        
        this.updateButtonStates();
        this.updateUI();
        document.getElementById('emuOutput').textContent = 'Debugger reset.\n';
        document.getElementById('executionTrace').textContent = '';
        document.getElementById('stepAnalysisOutput').textContent = '';
      }
      
      captureStepState() {
        // Capture registers and stack state for step analysis
        const registers = this.getAllRegisters();
        const stack = this.getStackContents(8);
        return { registers, stack };
      }
      
      logStepAnalysis(address, instruction, preState, postState) {
        const stepOutput = document.getElementById('stepAnalysisOutput');
        if (!stepOutput) return;
        
        // Format step entry
        let output = `0x${address.toString(16).padStart(8, '0')}: ${instruction}\n`;
        
        // Show register changes
        const preRegs = preState.registers;
        const postRegs = postState.registers;
        const changedRegs = [];
        
        for (const reg in postRegs) {
          if (preRegs[reg] !== postRegs[reg]) {
            changedRegs.push(`${reg}: 0x${preRegs[reg].toString(16)} → 0x${postRegs[reg].toString(16)}`);
          }
        }
        
        if (changedRegs.length > 0) {
          output += `  REG: ${changedRegs.join(', ')}\n`;
        }
        
        // Show stack changes (simplified - just show top few entries)
        const preStack = preState.stack;
        const postStack = postState.stack;
        const stackChanges = [];
        
        for (let i = 0; i < Math.min(preStack.length, postStack.length, 3); i++) {
          if (preStack[i] && postStack[i] && preStack[i].value !== postStack[i].value) {
            stackChanges.push(`[${postStack[i].address}]: 0x${preStack[i].value.toString(16)} → 0x${postStack[i].value.toString(16)}`);
          }
        }
        
        if (stackChanges.length > 0) {
          output += `  STACK: ${stackChanges.join(', ')}\n`;
        }
        
        output += '\n';
        stepOutput.textContent += output;
        stepOutput.scrollTop = stepOutput.scrollHeight;
      }
      
      getCurrentPC() {
        return this.is64bit ? 
          this.engine.reg_read_i64(UnicornModule.X86_REG_RIP) :
          this.engine.reg_read_i32(UnicornModule.X86_REG_EIP);
      }
      
      getAllRegisters() {
        if (this.is64bit) {
          return {
            RAX: this.engine.reg_read_i64(UnicornModule.X86_REG_RAX),
            RBX: this.engine.reg_read_i64(UnicornModule.X86_REG_RBX),
            RCX: this.engine.reg_read_i64(UnicornModule.X86_REG_RCX),
            RDX: this.engine.reg_read_i64(UnicornModule.X86_REG_RDX),
            RSI: this.engine.reg_read_i64(UnicornModule.X86_REG_RSI),
            RDI: this.engine.reg_read_i64(UnicornModule.X86_REG_RDI),
            RBP: this.engine.reg_read_i64(UnicornModule.X86_REG_RBP),
            RSP: this.engine.reg_read_i64(UnicornModule.X86_REG_RSP),
            RIP: this.engine.reg_read_i64(UnicornModule.X86_REG_RIP),
            RFLAGS: this.engine.reg_read_i64(UnicornModule.X86_REG_EFLAGS)
          };
        } else {
          return {
            EAX: this.engine.reg_read_i32(UnicornModule.X86_REG_EAX),
            EBX: this.engine.reg_read_i32(UnicornModule.X86_REG_EBX),
            ECX: this.engine.reg_read_i32(UnicornModule.X86_REG_ECX),
            EDX: this.engine.reg_read_i32(UnicornModule.X86_REG_EDX),
            ESI: this.engine.reg_read_i32(UnicornModule.X86_REG_ESI),
            EDI: this.engine.reg_read_i32(UnicornModule.X86_REG_EDI),
            EBP: this.engine.reg_read_i32(UnicornModule.X86_REG_EBP),
            ESP: this.engine.reg_read_i32(UnicornModule.X86_REG_ESP),
            EIP: this.engine.reg_read_i32(UnicornModule.X86_REG_EIP),
            EFLAGS: this.engine.reg_read_i32(UnicornModule.X86_REG_EFLAGS)
          };
        }
      }
      
      getStackContents(count = 16) {
        const sp = this.is64bit ? 
          this.engine.reg_read_i64(UnicornModule.X86_REG_RSP) :
          this.engine.reg_read_i32(UnicornModule.X86_REG_ESP);
        
        const stackData = [];
        const wordSize = this.is64bit ? 8 : 4;
        
        for (let i = 0; i < count; i++) {
          try {
            const addr = sp + (i * wordSize);
            const bytes = this.engine.mem_read(addr, wordSize);
            let value = 0;
            for (let j = 0; j < wordSize; j++) {
              value |= bytes[j] << (j * 8);
            }
            stackData.push({ address: addr, value: value });
          } catch (e) {
            break;
          }
        }
        return stackData;
      }
      
      logInstruction(address) {
        try {
          const instrBytes = this.engine.mem_read(address, 16);
          const instructions = this.disasm.disasm(instrBytes, address, 1);
          if (instructions.length > 0) {
            const insn = instructions[0];
            this.executionLog.push({
              address: address,
              mnemonic: insn.mnemonic,
              operands: insn.op_str,
              bytes: insn.bytes
            });
          }
        } catch(e) {
          console.log('Failed to log instruction:', e.message);
        }
      }
      
      logToExecutionTrace(address) {
        try {
          const instrBytes = this.engine.mem_read(address, 16);
          const instructions = this.disasm.disasm(instrBytes, address, 1);
          if (instructions.length > 0) {
            const insn = instructions[0];
            
            // Store instruction info to log AFTER execution
            this.pendingTrace = {
              address: address,
              mnemonic: insn.mnemonic,
              operands: insn.op_str
            };
          }
        } catch(e) {
          // Silently fail to avoid flooding console during execution
        }
      }
      
      logExecutedInstruction() {
        if (this.pendingTrace) {
          try {
            // Get RAX value AFTER instruction execution
            const rax = this.is64bit ? 
              this.engine.reg_read_i64(UnicornModule.X86_REG_RAX) :
              this.engine.reg_read_i32(UnicornModule.X86_REG_EAX);
            
            const trace = `0x${this.pendingTrace.address.toString(16).padStart(8, '0')}: ${this.pendingTrace.mnemonic.padEnd(8)} ${this.pendingTrace.operands.padEnd(20)} [RAX=0x${rax.toString(16)}]`;
            
            // Add to execution trace array
            if (!this.executionTrace) this.executionTrace = [];
            this.executionTrace.push(trace);
            
            // Update UI
            this.updateExecutionTrace();
            this.pendingTrace = null;
          } catch(e) {
            // Silently fail to avoid flooding console during execution
          }
        }
      }
      
      logDebugState(address, instruction) {
        try {
          const registers = this.getAllRegisters();
          const stack = this.getStackContents(8); // Get top 8 stack items
          
          console.group(`🔍 DEBUG STATE - After executing: ${instruction} at 0x${address.toString(16)}`);
          
          // Log registers
          console.log('📊 REGISTERS:');
          Object.entries(registers).forEach(([name, value]) => {
            const hexValue = value.toString(16).padStart(this.is64bit ? 16 : 8, '0');
            const decValue = value;
            console.log(`  ${name}: 0x${hexValue} (${decValue})`);
          });
          
          // Log stack
          console.log('📚 STACK (top 8 items):');
          if (stack.length > 0) {
            stack.forEach((item, index) => {
              const hexAddr = item.address.toString(16).padStart(this.is64bit ? 16 : 8, '0');
              const hexValue = item.value.toString(16).padStart(this.is64bit ? 16 : 8, '0');
              const decValue = item.value;
              console.log(`  [${index}] 0x${hexAddr}: 0x${hexValue} (${decValue})`);
            });
          } else {
            console.log('  (Stack appears empty or unreadable)');
          }
          
          console.groupEnd();
        } catch(e) {
          console.log('Failed to log debug state:', e.message);
        }
      }
      
      addBreakpoint(address) {
        this.breakpoints.add(address);
        console.log(`Breakpoint added at 0x${address.toString(16)}`);
      }
           
      updateUI() {
        this.updateRegisters();
        this.updateStack();
        this.updateExecutionLog();
      }
      
      updateRegisters() {
        const registers = this.getAllRegisters();
        const regHTML = Object.entries(registers)
          .map(([name, value]) => 
            `<div class="register">
              <span class="reg-name">${name}:</span>
              <span class="reg-value">0x${value.toString(16).padStart(this.is64bit ? 16 : 8, '0')}</span>
            </div>`
          ).join('');
        document.getElementById('registerGrid').innerHTML = regHTML;
      }
      
      updateStack() {
        const stack = this.getStackContents();
        const stackHTML = stack.map(item => 
          `<div class="stack-item">
            <span class="stack-addr">0x${item.address.toString(16).padStart(this.is64bit ? 16 : 8, '0')}:</span>
            <span class="stack-value">0x${item.value.toString(16).padStart(this.is64bit ? 16 : 8, '0')}</span>
          </div>`
        ).join('');
        document.getElementById('stackView').innerHTML = stackHTML;
      }
      
      updateExecutionLog() {
        const logText = this.executionLog.map(entry =>
          `0x${entry.address.toString(16)}: ${entry.mnemonic} ${entry.operands}`
        ).join('\n');
        document.getElementById('emuOutput').textContent = logText;
      }
      
      updateExecutionTrace() {
        if (this.executionTrace && this.executionTrace.length > 0) {
          document.getElementById('executionTrace').textContent = this.executionTrace.join('\n');
          // Auto-scroll to bottom
          const traceDiv = document.getElementById('executionTrace');
          traceDiv.scrollTop = traceDiv.scrollHeight;
        }
      }
      
      highlightCurrentLine() {
        const pc = this.getCurrentPC();
        const disasmDiv = document.getElementById('disassembly');
        
        // Get original disassembly text if it's still plain text
        let originalText = disasmDiv.getAttribute('data-original-text');
        if (!originalText) {
          originalText = disasmDiv.textContent;
          disasmDiv.setAttribute('data-original-text', originalText);
        }
        
        const lines = originalText.split('\n');
        const pcHex = pc.toString(16).padStart(8, '0');
        
        // Convert to HTML with proper highlighting
        const htmlLines = lines.map(line => {
          if (line.includes(`0x${pcHex}:`)) {
            return `<div class="highlighted-line">${this.escapeHtml(line)}</div>`;
          }
          return `<div>${this.escapeHtml(line)}</div>`;
        });
        
        disasmDiv.innerHTML = htmlLines.join('');
        
       
      }
      
      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
      
      // Function mapping methods for C function highlighting
      mapAssemblyToC(cCodeContent, assemblyInstructions) {
        if (!cCodeContent) {
          console.log('No C code content available for mapping');
          return;
        }
        
        const lines = cCodeContent.split('\n');
        const cStatements = lines.map((line, index) => ({
          content: line.trim(),
          lineNumber: index + 1
        }));
        
        const cFunctions = this.extractCFunctions(cStatements);
        const functionBoundaries = this.detectAssemblyFunctionBoundaries(assemblyInstructions);
        
        if (functionBoundaries.length === cFunctions.length) {
          console.log('Mapping assembly functions to C functions:');
          for (let i = 0; i < functionBoundaries.length; i++) {
            const asmFunc = functionBoundaries[i];
            const cFunc = cFunctions[i];
            
            this.functionRanges.set(asmFunc.startAddr, {
              startLine: cFunc.lineNumber,
              endLine: this.findFunctionEndLine(cFunc, cStatements),
              name: this.extractFunctionName(cFunc.content)
            });
            
            for (let j = 0; j < assemblyInstructions.length; j++) {
              const instruction = assemblyInstructions[j];
              const address = this.getInstructionAddress(instruction);
              
              if (address >= asmFunc.startAddr && address <= asmFunc.endAddr) {
                this.lineMapping.set(address, {
                  functionStart: cFunc.lineNumber,
                  functionEnd: this.findFunctionEndLine(cFunc, cStatements),
                  functionName: this.extractFunctionName(cFunc.content)
                });
              }
            }
          }
        }
      }
      
      extractCFunctions(cStatements) {
        return cStatements.filter(stmt => 
          stmt.content.includes('(') && 
          stmt.content.includes('{') &&
          !stmt.content.includes('if') &&
          !stmt.content.includes('while') &&
          !stmt.content.includes('for')
        );
      }
      
      detectAssemblyFunctionBoundaries(assemblyInstructions) {
        const boundaries = [];
        let currentFunctionStart = null;
        
        for (let i = 0; i < assemblyInstructions.length; i++) {
          const instruction = assemblyInstructions[i];
          const asmText = instruction.assembly || instruction.instruction || 'unknown';
          const address = this.getInstructionAddress(instruction);
          
          if (asmText.includes('push rbp') || asmText.includes('push ebp')) {
            if (currentFunctionStart !== null && i > 0) {
              const prevInstruction = assemblyInstructions[i - 1];
              const prevAddress = this.getInstructionAddress(prevInstruction);
              if (prevAddress !== null) {
                boundaries.push({
                  startAddr: currentFunctionStart,
                  endAddr: prevAddress
                });
              }
            }
            currentFunctionStart = address;
          }
        }
        
        if (currentFunctionStart !== null && assemblyInstructions.length > 0) {
          const lastInstruction = assemblyInstructions[assemblyInstructions.length - 1];
          const lastAddress = this.getInstructionAddress(lastInstruction);
          if (lastAddress !== null) {
            boundaries.push({
              startAddr: currentFunctionStart,
              endAddr: lastAddress
            });
          }
        }
        
        return boundaries;
      }
      
      getInstructionAddress(instruction) {
        if (instruction.getAddress) return instruction.getAddress();
        if (instruction.nodeAddr) return parseInt(instruction.nodeAddr.innerHTML, 16);
        if (instruction.address) return instruction.address;
        return null;
      }
      
      findFunctionEndLine(cFunc, cStatements) {
        let braceCount = 0;
        let foundStart = false;
        
        for (let i = cFunc.lineNumber - 1; i < cStatements.length; i++) {
          const line = cStatements[i].content;
          
          if (line.includes('{')) {
            foundStart = true;
            braceCount += (line.match(/\{/g) || []).length;
          }
          if (line.includes('}') && foundStart) {
            braceCount -= (line.match(/\}/g) || []).length;
            if (braceCount === 0) {
              return i + 1;
            }
          }
        }
        
        return cFunc.lineNumber + 10; // fallback
      }
      
      extractFunctionName(functionLine) {
        const match = functionLine.match(/(\w+)\s*\(/);
        return match ? match[1] : 'unknown';
      }
      
      getFunctionColor(functionName, functionIndex) {
        if (!this.functionColors.has(functionName)) {
          this.functionColors.set(functionName, functionIndex % 5);
        }
        return this.functionColors.get(functionName);
      }
      
      highlightCFunction(assemblyAddress) {
        const functionInfo = this.lineMapping.get(assemblyAddress);
        if (!functionInfo) {
            return;
        }

        const currentFunctionName = functionInfo.functionName;

        if (sourceCodeEditor && this.currentHighlightedFunction !== currentFunctionName) {
            this.clearCHighlight();

            // Highlight the entire function using CodeMirror's addLineClass
            for (let lineNum = functionInfo.functionStart; lineNum <= functionInfo.functionEnd; lineNum++) {
                const lineIndex = lineNum - 1; // CodeMirror uses 0-based indexing
                sourceCodeEditor.addLineClass(lineIndex, 'background', 'highlight-line');
            }

            this.currentHighlightedFunction = currentFunctionName;
        }
      }
      
      clearCHighlight() {
        if (sourceCodeEditor) {
          const lineCount = sourceCodeEditor.lineCount();
          for (let i = 0; i < lineCount; i++) {
            sourceCodeEditor.removeLineClass(i, 'background', 'highlight-line');
          }
        }
        this.currentHighlightedFunction = null;
      }
    }
    
    // Function to disassemble bytes
    function disassembleSection(bytes, arch, mode, baseAddr, sectionName) {
      try {
        const disasm = new cs.Capstone(arch, mode);
        const instructions = disasm.disasm(bytes, baseAddr);
        
        let output = `\n=== ${sectionName} Section Disassembly ===\n`;
        instructions.forEach(insn => {
          output += `0x${insn.address.toString(16).padStart(8, '0')}: ${insn.bytes.map(b => b.toString(16).padStart(2, '0')).join(' ').padEnd(24)} ${insn.mnemonic} ${insn.op_str}\n`;
        });
        
        return output;
      } catch(e) {
        return `\nDisassembly error for ${sectionName}: ${e.message}\n`;
      }
    }

    // --- ELF PARSER (same as before) ---
    function readUint(view, off, size, le) {
      if (size === 1) return view.getUint8(off, le);
      if (size === 2) return view.getUint16(off, le);
      if (size === 4) return view.getUint32(off, le);
      const lo = view.getUint32(off, le);
      const hi = view.getUint32(off+4, le);
      return hi * 0x100000000 + lo;
    }
    function getString(view, off) {
      let s = '';
      for (let i = off;; i++) {
        const b = view.getUint8(i);
        if (!b) break;
        s += String.fromCharCode(b);
      }
      return s;
    }
    function parseELF(buf) {
      const view = new DataView(buf);
      if ([0x7F,0x45,0x4C,0x46].some((v,i)=>view.getUint8(i)!==v))
        throw new Error('Not an ELF file');
      const is32 = view.getUint8(4)===1;
      const le   = view.getUint8(5)===1;
      const ptr  = is32?4:8;
      const u16  = off=>readUint(view, off, 2, le);
      const u32  = off=>readUint(view, off, 4, le);
      const u64  = off=>readUint(view, off, 8, le);
      const get  = off=>(ptr===4?u32(off):u64(off));
      const eh = {
        class: is32?'ELF32':'ELF64', data: le?'little':'big',
        entry: get(24), phoff: get(is32?28:32), shoff: get(is32?32:40),
        phentsz: u16(is32?42:54), phnum: u16(is32?44:56),
        shentsz: u16(is32?46:58), shnum: u16(is32?48:60), shstrndx: u16(is32?50:62)
      };
      const ph=[];
      for(let i=0;i<eh.phnum;i++){
        const off = eh.phoff + i*eh.phentsz;
        ph.push({ type:u32(off), flags:is32?u32(off+24):u32(off+4),
          offset:get(off+(is32?4:8)), vaddr:get(off+(is32?8:16)),
          filesz:get(off+(is32?16:32)), memsz:get(off+(is32?20:40)),
          align:get(off+(is32?28:48)) });
      }
      const sh=[];
      for(let i=0;i<eh.shnum;i++){
        const off = eh.shoff + i*eh.shentsz;
        const nameOff = u32(off);
        const type    = u32(off+4);
        const flags   = ptr===4?u32(off+8):u64(off+8);
        const addr    = ptr===4?u32(off+12):u64(off+16);
        const offset  = ptr===4?u32(off+16):u64(off+24);
        const size    = ptr===4?u32(off+20):u64(off+32);
        const link    = u32(off + (ptr===4?24:40));
        const info    = u32(off + (ptr===4?28:44));
        const addralign = ptr===4?u32(off+32):u64(off+48);
        const entsize   = ptr===4?u32(off+36):u64(off+56);
        sh.push({nameOff,type,flags,addr,offset,size,link,info,addralign,entsize});
      }
      const strsh = sh[eh.shstrndx];
      sh.forEach(s=>s.name = getString(view, strsh.offset + s.nameOff));
      return {elfHeader:eh, programHeaders:ph, sectionHeaders:sh, view};
    }
    function showJSON(obj){
      document.getElementById('output').textContent = JSON.stringify(obj, (k,v)=>(k==='view'?undefined:v), 2);
    }
    let parsed;
    let unicornDebugger = null;
    
    document.getElementById('fileInput').addEventListener('change', e=>{
      const f = e.target.files[0]; if(!f) return;
      const r = new FileReader();
      r.onload = ()=>{ 
        try{ 
          parsed = parseELF(r.result); 
          showJSON(parsed); 
          
          // Generate disassembly
          const {sectionHeaders, view, elfHeader} = parsed;
          const is64bit = elfHeader.class === 'ELF64';
          const arch = cs.ARCH_X86;
          const mode = is64bit ? cs.MODE_64 : cs.MODE_32;
          
          let disasmOutput = '';
          sectionHeaders.forEach(sh => {
            if(sh.name === '.text' && sh.size > 0 && sh.offset > 0) {
              const bytes = new Uint8Array(view.buffer, sh.offset, sh.size);
              disasmOutput += disassembleSection(bytes, arch, mode, 0x40000000, sh.name);
            }
          });
          
          document.getElementById('disassembly').textContent = disasmOutput || 'No executable sections found';
          document.getElementById('runUnicorn').disabled=false;
        }catch(err){
          showJSON({error:err.message});
        }
      };
      r.readAsArrayBuffer(f);
    });

    // Reset Step 2 status function
    function resetStep2Status() {
      const step2Container = document.querySelector('div.container:nth-child(3)');
      if (step2Container) {
        const statusDiv = step2Container.querySelector('h2');
        if (statusDiv) {
          statusDiv.innerHTML = '📂 Step 2: Load Object File for Debugging';
        }
      }
      // Clear previous ELF data and disable debugger
      document.getElementById('output').textContent = '';
      document.getElementById('disassembly').textContent = '';
      document.getElementById('runUnicorn').disabled = true;
      parsed = null;
    }

    // Auto-load compiled .o file function
    function autoLoadCompiledFile(binaryData) {
      try {
        console.log('Auto-loading compiled .o file...');
        
        // Convert Uint8Array to ArrayBuffer if needed
        const buffer = binaryData.buffer ? binaryData.buffer : binaryData;
        
        // Parse the ELF data directly
        parsed = parseELF(buffer);
        showJSON(parsed);
        
        // Generate disassembly
        const {sectionHeaders, view, elfHeader} = parsed;
        const is64bit = elfHeader.class === 'ELF64';
        const arch = cs.ARCH_X86;
        const mode = is64bit ? cs.MODE_64 : cs.MODE_32;
        
        let disasmOutput = '';
        sectionHeaders.forEach(sh => {
          if(sh.name === '.text' && sh.size > 0 && sh.offset > 0) {
            const bytes = new Uint8Array(view.buffer, sh.offset, sh.size);
            disasmOutput += disassembleSection(bytes, arch, mode, 0x40000000, sh.name);
          }
        });
        
        document.getElementById('disassembly').textContent = disasmOutput || 'No executable sections found';
        
        // Enable the debugger initialization button
        document.getElementById('runUnicorn').disabled = false;
        
        // Update status in Step 2 with success message
        const step2Container = document.querySelector('div.container:nth-child(3)');
        if (step2Container) {
          const statusDiv = step2Container.querySelector('h3') || step2Container.querySelector('h2');
          if (statusDiv) {
            statusDiv.innerHTML = '📂 Step 2: Load Object File for Debugging <span class="status-indicator status-success"></span><span style="color: var(--accent-green); font-size: 12px;">AUTO-LOADED</span>';
          }
        }
        
        console.log('✅ Auto-load successful!');
        return true;
        
      } catch (error) {
        console.error('❌ Auto-load failed:', error);
        
        // Update status with error message
        const step2Container = document.querySelector('div.container:nth-child(3)');
        if (step2Container) {
          const statusDiv = step2Container.querySelector('h3') || step2Container.querySelector('h2');
          if (statusDiv) {
            statusDiv.innerHTML = '📂 Step 2: Load Object File for Debugging <span class="status-indicator status-error"></span><span style="color: var(--accent-red); font-size: 12px;">AUTO-LOAD FAILED - USE MANUAL UPLOAD</span>';
          }
        }
        
        return false;
      }
    }

    document.getElementById('runUnicorn').addEventListener('click', ()=>{
      if(typeof UnicornModule==='undefined' || !UnicornModule.Unicorn){
        document.getElementById('emuOutput').textContent = 'Error: Unicorn not loaded';
        return;
      }
      
      // Extract data from parsed ELF first
      const {sectionHeaders, view, elfHeader} = parsed;
      
      // Determine architecture and mode from ELF header
      const is64bit = elfHeader.class === 'ELF64';
      const arch = UnicornModule.ARCH_X86;
      const mode = is64bit ? UnicornModule.MODE_64 : UnicornModule.MODE_32;
      
      console.log(`Creating Unicorn engine for ${is64bit ? '64-bit' : '32-bit'} x86`);
      const engine = new UnicornModule.Unicorn(arch, mode);
      
      // Set up stack - ensure page alignment (4KB = 0x1000)
      const STACK_ADDR = 0x10000000;  // Use a different, page-aligned address
      const STACK_SIZE = 0x10000;     // 64KB stack
      engine.mem_map(STACK_ADDR, STACK_SIZE, UnicornModule.PROT_ALL);
      
      // Set stack pointer based on architecture
      if(is64bit) {
        engine.reg_write_i64(UnicornModule.X86_REG_RSP, STACK_ADDR + STACK_SIZE - 0x1000);
      } else {
        engine.reg_write_i32(UnicornModule.X86_REG_ESP, STACK_ADDR + STACK_SIZE - 0x1000);
      }
      
      // Handle object files (sections with addr=0) vs executables 
      const isObjectFile = sectionHeaders.some(sh => (sh.flags & 0x2) && sh.size > 0 && sh.addr === 0);
      let baseAddr = 0x40000000;  // Base address for object file sections
      const mappedRegions = new Set();
      const sectionAddresses = new Map();  // Track where we loaded each section
      const functionBoundaries = new Map(); // Map function name to {start, size} - declare at broad scope
      
      console.log(`Processing ${isObjectFile ? 'object file' : 'executable'} with ${sectionHeaders.length} sections`);
      
      sectionHeaders.forEach(sh=>{
        // Only map allocated sections (SHF_ALLOC = 0x2) with size > 0
        if((sh.flags & 0x2) && sh.size > 0){
          let targetAddr = sh.addr;
          
          // For object files, assign base addresses since they start at 0
          if(isObjectFile && sh.addr === 0){
            targetAddr = baseAddr;
            // Align to page boundary and reserve space
            targetAddr = Math.ceil(targetAddr / 0x1000) * 0x1000;
            baseAddr = targetAddr + Math.ceil(sh.size / 0x1000) * 0x1000;
          }
          
          // Skip if address is still 0 (invalid)
          if(targetAddr === 0){
            console.log(`Skipping section ${sh.name}: invalid address`);
            return;
          }
          
          // Ensure addresses and sizes are page-aligned
          const alignedAddr = Math.floor(targetAddr / 0x1000) * 0x1000;
          const alignedSize = Math.max(0x1000, Math.ceil(sh.size / 0x1000) * 0x1000);
          
          // Skip if we've already mapped this memory region
          const regionKey = `${alignedAddr}-${alignedSize}`;
          if(mappedRegions.has(regionKey)){
            console.log(`Skipping already mapped region for section ${sh.name}`);
            return;
          }
          
          const prot = (sh.flags & 0x1 ? UnicornModule.PROT_READ  : 0) |
                       (sh.flags & 0x2 ? UnicornModule.PROT_WRITE : 0) |
                       (sh.flags & 0x4 ? UnicornModule.PROT_EXEC  : 0);
          
          try {
            console.log(`Mapping section ${sh.name}: addr=0x${alignedAddr.toString(16)}, size=0x${alignedSize.toString(16)}, prot=${prot}`);
            engine.mem_map(alignedAddr, alignedSize, prot || UnicornModule.PROT_READ);
            mappedRegions.add(regionKey);
            sectionAddresses.set(sh.name, targetAddr);
            
            // Write section data if it exists in the file
            if(sh.size > 0 && sh.offset > 0){
              const bytes = new Uint8Array(view.buffer, sh.offset, sh.size);
              engine.mem_write(targetAddr, bytes);
              console.log(`Wrote ${bytes.length} bytes to 0x${targetAddr.toString(16)} for section ${sh.name}`);
            }
          } catch(e) {
            console.log(`Failed to map section ${sh.name}: addr=0x${alignedAddr.toString(16)}, size=0x${alignedSize.toString(16)}, error=${e.message}`);
          }
        } else {
          console.log(`Skipping section ${sh.name}: flags=0x${sh.flags.toString(16)}, addr=0x${sh.addr.toString(16)}, size=${sh.size}`);
        }
      });
      
      // Determine entry point
      let entryPoint = elfHeader.entry;
      let functionMap = new Map(); // Declare functionMap here for proper scope
      
      // Find symbol table sections (needed for both main finding and relocations)
      const symtabSection = sectionHeaders.find(sh => sh.name === '.symtab');
      const strtabSection = sectionHeaders.find(sh => sh.name === '.strtab');
      
      // For object files, try to find main function in symbol table
      let mainAddr = null;
      
      if(isObjectFile) {
        
        if(symtabSection && strtabSection && symtabSection.size > 0) {
          const symtabData = new Uint8Array(view.buffer, symtabSection.offset, symtabSection.size);
          const strtabData = new Uint8Array(view.buffer, strtabSection.offset, strtabSection.size);
          
          // Parse symbols (each symbol is 24 bytes in 64-bit ELF)
          const symbolSize = is64bit ? 24 : 16;
          const numSymbols = symtabSection.size / symbolSize;
          
          for(let i = 0; i < numSymbols; i++) {
            const symOffset = i * symbolSize;
            const nameOffset = is64bit ? 
              new DataView(symtabData.buffer, symtabData.byteOffset + symOffset).getUint32(0, true) :
              new DataView(symtabData.buffer, symtabData.byteOffset + symOffset).getUint32(0, true);
            
            const value = is64bit ?
              new DataView(symtabData.buffer, symtabData.byteOffset + symOffset + 8).getBigUint64(0, true) :
              new DataView(symtabData.buffer, symtabData.byteOffset + symOffset + 4).getUint32(0, true);
            
            // Get symbol name from string table
            let symbolName = '';
            for(let j = nameOffset; j < strtabData.length; j++) {
              if(strtabData[j] === 0) break;
              symbolName += String.fromCharCode(strtabData[j]);
            }
            
            console.log(`Found symbol: ${symbolName} at 0x${value.toString(16)}`);
            
            if(symbolName === 'main') {
              mainAddr = Number(value);
              console.log(`Found main function at 0x${mainAddr.toString(16)}`);
              break;
            }
          }
        }
        
        // Create a function address map with sizes for resolving calls
        console.log(`Building function map from symbol table. symtabSection: ${!!symtabSection}, strtabSection: ${!!strtabSection}`);
        
        if(symtabSection && strtabSection) {
          console.log(`Symbol table size: ${symtabSection.size}, String table size: ${strtabSection.size}`);
          const symtabData = new Uint8Array(view.buffer, symtabSection.offset, symtabSection.size);
          const strtabData = new Uint8Array(view.buffer, strtabSection.offset, strtabSection.size);
          const symbolSize = is64bit ? 24 : 16;
          const numSymbols = symtabSection.size / symbolSize;
          console.log(`Processing ${numSymbols} symbols, each ${symbolSize} bytes`);
          
          // First pass: collect all function symbols with their sizes
          const functions = [];
          
          for(let i = 0; i < numSymbols; i++) {
            const symOffset = i * symbolSize;
            const nameOffset = new DataView(symtabData.buffer, symtabData.byteOffset + symOffset).getUint32(0, true);
            const value = is64bit ?
              Number(new DataView(symtabData.buffer, symtabData.byteOffset + symOffset + 8).getBigUint64(0, true)) :
              new DataView(symtabData.buffer, symtabData.byteOffset + symOffset + 4).getUint32(0, true);
            
            // Get symbol size and type
            const size = is64bit ?
              Number(new DataView(symtabData.buffer, symtabData.byteOffset + symOffset + 16).getBigUint64(0, true)) :
              new DataView(symtabData.buffer, symtabData.byteOffset + symOffset + 8).getUint32(0, true);
            
            const info = new DataView(symtabData.buffer, symtabData.byteOffset + symOffset + (is64bit ? 4 : 12)).getUint8(0);
            const symbolType = info & 0xf; // ST_TYPE
            
            let symbolName = '';
            if(nameOffset < strtabData.length) {
              for(let j = nameOffset; j < strtabData.length; j++) {
                if(strtabData[j] === 0) break;
                symbolName += String.fromCharCode(strtabData[j]);
              }
            }
            
            // Only process function symbols (STT_FUNC = 2)
            if(symbolName && value >= 0 && symbolType === 2) {
              const actualAddr = sectionAddresses.get('.text') + value;
              functions.push({
                name: symbolName,
                address: actualAddr,
                offset: value,
                size: size || 0
              });
              functionMap.set(symbolName, actualAddr);
              console.log(`Function ${symbolName} at 0x${actualAddr.toString(16)}, size: ${size}`);
            }
          }
          
          // Sort functions by address to calculate boundaries
          functions.sort((a, b) => a.address - b.address);
          
          // Calculate function boundaries
          for(let i = 0; i < functions.length; i++) {
            const func = functions[i];
            let funcSize = func.size;
            
            // If size is 0 or unknown, calculate from next function
            if(funcSize === 0 && i < functions.length - 1) {
              funcSize = functions[i + 1].address - func.address;
            } else if(funcSize === 0) {
              funcSize = 50; // Default fallback for last function
            }
            
            functionBoundaries.set(func.name, {
              start: func.address,
              size: funcSize
            });
            
            console.log(`Function ${func.name}: 0x${func.address.toString(16)} - 0x${(func.address + funcSize).toString(16)} (size: ${funcSize})`);
          }
        }
        
        if(mainAddr && mainAddr > 0) {
          // Use main function address + text section base
          const textAddr = sectionAddresses.get('.text');
          entryPoint = textAddr + mainAddr;
          console.log(`Using main function as entry point: 0x${entryPoint.toString(16)}`);
        } else {
          // Fall back to .text section start
          const textAddr = sectionAddresses.get('.text');
          if(textAddr) {
            entryPoint = textAddr;
            console.log(`Main not found, using .text section as entry point: 0x${entryPoint.toString(16)}`);
          } else {
            document.getElementById('emuOutput').textContent = 'Error: No .text section found in object file';
            return;
          }
        }
      }
      
      if(entryPoint === 0) {
        document.getElementById('emuOutput').textContent = 'Error: No valid entry point found';
        return;
      }
      
      // Process relocations to fix function calls
      const relaTextSection = sectionHeaders.find(sh => sh.name === '.rela.text');
      if(relaTextSection && relaTextSection.size > 0 && functionMap.size > 0) {
        console.log('Processing relocations...');
        const relaData = new Uint8Array(view.buffer, relaTextSection.offset, relaTextSection.size);
        const relaSize = is64bit ? 24 : 12; // Size of relocation entry
        const numRelas = relaTextSection.size / relaSize;
        
        for(let i = 0; i < numRelas; i++) {
          const relaOffset = i * relaSize;
          const offset = is64bit ?
            Number(new DataView(relaData.buffer, relaData.byteOffset + relaOffset).getBigUint64(0, true)) :
            new DataView(relaData.buffer, relaData.byteOffset + relaOffset).getUint32(0, true);
          
          const info = is64bit ?
            Number(new DataView(relaData.buffer, relaData.byteOffset + relaOffset + 8).getBigUint64(0, true)) :
            new DataView(relaData.buffer, relaData.byteOffset + relaOffset + 4).getUint32(0, true);
          
          const addend = is64bit ?
            Number(new DataView(relaData.buffer, relaData.byteOffset + relaOffset + 16).getBigInt64(0, true)) :
            0;
          
          const symbolIndex = is64bit ? Math.floor(info / 0x100000000) : (info >> 8);
          const relocType = is64bit ? (info & 0xffffffff) : (info & 0xff);
          
          console.log(`Raw info: 0x${info.toString(16)}, symbolIndex: ${symbolIndex}, relocType: ${relocType}`);
          
          // Get symbol name for this relocation by parsing the symbol table
          let symbolName = '';
          
          if(symbolIndex >= 0 && symtabSection && strtabSection) {
            const symOffset = symbolIndex * (is64bit ? 24 : 16);
            console.log(`Looking up symbol ${symbolIndex} at offset ${symOffset} (symtab size: ${symtabSection.size})`);
            
            if(symOffset < symtabSection.size) {
              const symtabData = new Uint8Array(view.buffer, symtabSection.offset, symtabSection.size);
              const strtabData = new Uint8Array(view.buffer, strtabSection.offset, strtabSection.size);
              
              const nameOffset = new DataView(symtabData.buffer, symtabData.byteOffset + symOffset).getUint32(0, true);
              console.log(`Symbol ${symbolIndex} has name offset ${nameOffset} in string table (size: ${strtabData.length})`);
              
              if(nameOffset < strtabData.length && nameOffset > 0) {
                for(let j = nameOffset; j < strtabData.length; j++) {
                  if(strtabData[j] === 0) break;
                  symbolName += String.fromCharCode(strtabData[j]);
                }
              }
              
              console.log(`Resolved symbol ${symbolIndex} to name: "${symbolName}"`);
            } else {
              console.log(`Symbol ${symbolIndex} could not be read from symbol table`);
            }
          } else {
            console.log(`Invalid symbol index ${symbolIndex} or missing symbol/string tables`);
          }
          
          // If symbol name couldn't be resolved from symbol table, try dynamic resolution
          if(!symbolName) {
            console.log(`Could not resolve symbol ${symbolIndex} from symbol table, attempting dynamic resolution`);
            
            // Find the .text section to analyze call instructions
            const textSection = sectionHeaders.find(sh => sh.name === '.text');
            if(textSection && textSection.size > 0) {
              // Analyze the relocation offset to find which call site this is
              const textData = new Uint8Array(view.buffer, textSection.offset, textSection.size);
              const callOffsets = [];
              
              // Find all call instructions (0xe8 opcode for near call)
              for(let i = 0; i < textData.length - 4; i++) {
                if(textData[i] === 0xe8) {
                  callOffsets.push(i);
                }
              }
              
              // Relocation offset points to the operand, call instruction is 1 byte before
              // But let's check multiple possibilities due to encoding variations
              let callIndex = callOffsets.indexOf(offset - 1);
              if(callIndex === -1) {
                // Try other common patterns
                callIndex = callOffsets.indexOf(offset - 2);
                if(callIndex === -1) {
                  callIndex = callOffsets.indexOf(offset - 3);
                  if(callIndex === -1) {
                    callIndex = callOffsets.indexOf(offset - 4);
                    if(callIndex === -1) {
                      callIndex = callOffsets.indexOf(offset - 5);
                    }
                  }
                }
              }
              
              const availableFunctions = Array.from(functionMap.keys()).filter(name => 
                name !== 'main' && !name.endsWith('.c') && name.length > 0);
              
              console.log(`Found ${callOffsets.length} call instructions at offsets: ${callOffsets.map(o => '0x' + o.toString(16)).join(', ')}`);
              console.log(`Current relocation offset: 0x${offset.toString(16)} (call index: ${callIndex})`);
              console.log(`Available functions: ${availableFunctions.join(', ')}`);
              
              // Proper dynamic resolution: analyze the actual call target
              if(callIndex >= 0) {
                // Get the current relative offset from the call instruction
                const callOffset = callOffsets[callIndex];
                const callInstrAddr = callOffset;
                
                // Read the current 4-byte displacement after the call opcode
                const displBytes = textData.slice(callOffset + 1, callOffset + 5);
                const currentDispl = new DataView(displBytes.buffer, displBytes.byteOffset).getInt32(0, true);
                
                // Calculate what address this call would jump to with current displacement
                const textBaseAddr = sectionAddresses.get('.text');
                const currentTargetAddr = textBaseAddr + callInstrAddr + 5 + currentDispl;
                
                console.log(`Call at offset 0x${callOffset.toString(16)} currently targets 0x${currentTargetAddr.toString(16)}`);
                
                // Find which function this target address corresponds to using proper boundaries
                let targetFunction = null;
                
                for(const [funcName, boundary] of functionBoundaries.entries()) {
                  if(funcName !== 'main' && !funcName.endsWith('.c') && funcName.length > 0) {
                    const funcStart = boundary.start;
                    const funcEnd = boundary.start + boundary.size;
                    
                    console.log(`Checking function ${funcName}: 0x${funcStart.toString(16)} - 0x${funcEnd.toString(16)}, target: 0x${currentTargetAddr.toString(16)}`);
                    
                    // If target address falls within this function's actual boundaries
                    if(currentTargetAddr >= funcStart && currentTargetAddr < funcEnd) {
                      targetFunction = funcName;
                      console.log(`Target 0x${currentTargetAddr.toString(16)} falls within ${funcName} boundaries`);
                      break;
                    }
                  }
                }
                
                symbolName = targetFunction;
                if(symbolName) {
                  console.log(`Dynamic analysis: call #${callIndex} targets function '${symbolName}'`);
                } else {
                  console.log(`Call target 0x${currentTargetAddr.toString(16)} is unpatched - cannot determine function dynamically`);
                  console.log(`This indicates the relocation system needs the symbol name to patch the call correctly`);
                  symbolName = null;
                }
              } else {
                console.log(`Cannot find call instruction for relocation offset 0x${offset.toString(16)}`);
                symbolName = null;
              }
            }
          }
          
          console.log(`Relocation ${i}: offset=0x${offset.toString(16)}, symbolIndex=${symbolIndex}, symbol="${symbolName}", type=${relocType}, addend=${addend}`);
          
          if(symbolName && functionMap.has(symbolName)) {
            const targetAddr = functionMap.get(symbolName);
            const patchAddr = sectionAddresses.get('.text') + offset;
            
            console.log(`Patching call to ${symbolName} at 0x${patchAddr.toString(16)} -> 0x${targetAddr.toString(16)} (type ${relocType})`);
            
            // Patch the relocation depending on type
            try {
              if(relocType === 4) { // R_X86_64_PLT32 - relative call
                // For x86_64, the relative address is calculated as: target - (current_addr + 4)
                // The +4 accounts for the size of the call instruction
                const relativeAddr = targetAddr - (patchAddr + 4);
                const patchBytes = new Uint8Array(4);
                new DataView(patchBytes.buffer).setInt32(0, relativeAddr, true);
                engine.mem_write(patchAddr, patchBytes);
                console.log(`Applied PLT32 relocation: target=0x${targetAddr.toString(16)}, patch=0x${patchAddr.toString(16)}, relative=${relativeAddr} (0x${relativeAddr.toString(16)})`);
              } else if(relocType === 2) { // R_X86_64_PC32 - relative 32-bit
                const relativeAddr = targetAddr - (patchAddr + 4);
                const patchBytes = new Uint8Array(4);
                new DataView(patchBytes.buffer).setInt32(0, relativeAddr, true);
                engine.mem_write(patchAddr, patchBytes);
                console.log(`Applied PC32 relocation: target=0x${targetAddr.toString(16)}, patch=0x${patchAddr.toString(16)}, relative=${relativeAddr} (0x${relativeAddr.toString(16)})`);
              } else if(relocType === 10) { // R_X86_64_32
                const patchBytes = new Uint8Array(4);
                new DataView(patchBytes.buffer).setUint32(0, targetAddr, true);
                engine.mem_write(patchAddr, patchBytes);
                console.log(`Applied absolute relocation: target = 0x${targetAddr.toString(16)}`);
              } else {
                console.log(`Unsupported relocation type: ${relocType}`);
              }
            } catch(e) {
              console.log(`Failed to patch relocation: ${e.message}`);
            }
          } else {
            console.log(`Symbol ${symbolName} not found in function map - available functions: ${Array.from(functionMap.keys()).join(', ')}`);
          }
        }
      }
      
      // Set up proper function call environment for main()
      if(isObjectFile && mainAddr && mainAddr > 0) {
        // Set up argc and argv for main function
        if(is64bit) {
          engine.reg_write_i64(UnicornModule.X86_REG_RDI, 0); // argc = 0
          engine.reg_write_i64(UnicornModule.X86_REG_RSI, 0); // argv = NULL
        } else {
          // For 32-bit, push arguments on stack
          const sp = engine.reg_read_i32(UnicornModule.X86_REG_ESP);
          engine.mem_write(sp - 4, new Uint8Array([0, 0, 0, 0])); // argv = NULL
          engine.mem_write(sp - 8, new Uint8Array([0, 0, 0, 0])); // argc = 0
          engine.reg_write_i32(UnicornModule.X86_REG_ESP, sp - 8);
        }
        
        // Set up a return address that will cause execution to stop
        const exitAddr = 0x12345000; // Dummy exit address (page-aligned)
        // Map this address to prevent unmapped memory access
        engine.mem_map(exitAddr, 0x1000, UnicornModule.PROT_ALL);
        // Write a simple halt instruction sequence
        const haltBytes = new Uint8Array([0xF4]); // HLT instruction
        engine.mem_write(exitAddr, haltBytes);
        if(is64bit) {
          const sp = engine.reg_read_i64(UnicornModule.X86_REG_RSP);
          const retAddrBytes = new Uint8Array(8);
          new DataView(retAddrBytes.buffer).setBigUint64(0, BigInt(exitAddr), true);
          engine.mem_write(sp - 8, retAddrBytes);
          engine.reg_write_i64(UnicornModule.X86_REG_RSP, sp - 8);
        } else {
          const sp = engine.reg_read_i32(UnicornModule.X86_REG_ESP);
          const retAddrBytes = new Uint8Array(4);
          new DataView(retAddrBytes.buffer).setUint32(0, exitAddr, true);
          engine.mem_write(sp - 4, retAddrBytes);
          engine.reg_write_i32(UnicornModule.X86_REG_ESP, sp - 4);
        }
      }
      
      // Create debugger instance
      unicornDebugger = new UnicornDebugger(engine, is64bit, entryPoint);
      
      // Set up C function mapping if C code is available
      const cCodeInput = document.getElementById('sourceCode');
      const sourceCodeText = getSourceCode();
      if (cCodeInput && sourceCodeText.trim()) {
        // Parse assembly instructions from the disassembly
        const disasmDiv = document.getElementById('disassembly');
        const assemblyInstructions = [];
        if (disasmDiv) {
          const lines = disasmDiv.textContent.split('\n');
          lines.forEach(line => {
            const match = line.match(/0x([0-9a-fA-F]+):\s+(.+?)\s+(.+)/);
            if (match) {
              assemblyInstructions.push({
                address: parseInt(match[1], 16),
                instruction: match[3] || match[2]
              });
            }
          });
        }
        
        // Map assembly to C functions
        unicornDebugger.mapAssemblyToC(sourceCodeText, assemblyInstructions);
      }
      
      // Add breakpoint at exit address if we set one up
      if(isObjectFile && mainAddr && mainAddr > 0) {
        const exitAddr = 0x12345000;
        unicornDebugger.addBreakpoint(exitAddr);
      }
      
      // Show debugger UI
      
      // Enable debugger controls
      document.getElementById('stepBtn').disabled = false;
      document.getElementById('runBtn').disabled = false;
      document.getElementById('resetBtn').disabled = false;
      // document.getElementById('addBreakpointBtn').disabled = false;
      
      // Update initial state
      unicornDebugger.updateUI();
      unicornDebugger.highlightCurrentLine();
      
      document.getElementById('emuOutput').textContent = 'Debugger initialized. Ready to step through code.\n';
    });
    
    // Debugger control event handlers
    document.getElementById('stepBtn').addEventListener('click', () => {
      if (unicornDebugger) {
        unicornDebugger.stepInstruction();
      }
    });
    
    document.getElementById('runBtn').addEventListener('click', () => {
      if (unicornDebugger) {
        unicornDebugger.runUntilHalt();
      }
    });
    
    document.getElementById('stopBtn').addEventListener('click', () => {
      if (unicornDebugger) {
        unicornDebugger.stopExecution();
      }
    });
    
    document.getElementById('resetBtn').addEventListener('click', () => {
      if (unicornDebugger) {
        unicornDebugger.reset();
      }
    });
    
   
    

  </script>
  
  <!-- TinyCC Integration -->
  <script src="./tcc.js"></script>
  <script>
    // TinyCC Variables
    let tccModule = null;
    let isModuleReady = false;
    let resultData = null;
    let resultType = null;

    // Initialize TinyCC when page loads
    window.addEventListener('load', async function() {
            try {
                tccModule = await TccModule();
                
                isModuleReady = true;
                updateStatus('ready', '🎉 TinyCC WebAssembly ready! New build with reference approach.');
                document.getElementById('quickBtn').disabled = false;
                
                console.log('TinyCC module ready with reference approach');
                console.log('Available functions:', Object.keys(tccModule).filter(k => typeof tccModule[k] === 'function'));
            } catch (error) {
                console.error('Failed to load TinyCC module:', error);
                updateStatus('error', 'Failed to load TinyCC module: ' + error.message);
            }
        });

        function updateStatus(type, message) {
            const statusDiv = document.getElementById('status');
            statusDiv.className = 'status ' + type;
            statusDiv.textContent = message;
        }

        function setupRuntimeFiles() {
            // Ensure runtime files exist in the current directory where TinyCC expects them
            try {
                // Check if files exist, if not create them
                const runtimeFiles = ['crt1.o', 'crti.o', 'crtn.o'];
                
                for (const filename of runtimeFiles) {
                    try {
                        tccModule.FS.stat(filename);
                    } catch (e) {
                        // File doesn't exist, copy from lib directory or create minimal one
                        try {
                            const data = tccModule.FS.readFile('lib/' + filename);
                            tccModule.FS.writeFile(filename, data);
                        } catch (e2) {
                            // Create minimal ELF object file
                            const elfHeader = new Uint8Array([
                                0x7f, 0x45, 0x4c, 0x46, 0x01, 0x01, 0x01, 0x00,  // ELF magic
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00,  // i386 relocatable
                                0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x00,
                                0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
                            ]);
                            tccModule.FS.writeFile(filename, elfHeader);
                        }
                    }
                }
                
                // Also check for libc.a
                try {
                    tccModule.FS.stat('libc.a');
                } catch (e) {
                    try {
                        const data = tccModule.FS.readFile('lib/libc.a');
                        tccModule.FS.writeFile('libc.a', data);
                    } catch (e2) {
                        // Create minimal archive
                        const archive = new Uint8Array([0x21, 0x3C, 0x61, 0x72, 0x63, 0x68, 0x3E, 0x0A]);
                        tccModule.FS.writeFile('libc.a', archive);
                    }
                }
            } catch (error) {
                console.log('Runtime setup error:', error);
            }
        }

        function quickCompileExact() {
            if (!isModuleReady) {
                updateOutput('TinyCC module not ready yet.');
                return;
            }

            const sourceCode = getSourceCode();
            if (!sourceCode.trim()) {
                updateOutput('Please enter some C code to compile.');
                return;
            }

            try {
                // Reset Step 2 status for new compilation
                resetStep2Status();
                
                updateOutput('⚡ Quick Compile - Exact console replication...\n\n');
                
                // Setup runtime files first to avoid crt*.o errors
                setupRuntimeFiles();
                
                // Write source code to virtual filesystem
                const inputFile = 'source.c';
                const outputFile = 'source.o';
                
                tccModule.FS.writeFile(inputFile, sourceCode);
                
                let output = `📝 Source: ${inputFile} → Object: ${outputFile}\n`;
                output += `⚡ Console command: tcc -c ${inputFile} -o ${outputFile}\n`;
                output += `🌐 WebAssembly: tcc -c -nostdlib ${inputFile} -o ${outputFile}\n`;
                output += `💡 Added -nostdlib to avoid runtime file dependencies\n\n`;
                
                // Manual argc/argv construction (ccall array handling has issues)
                const args = ['tcc', '-c', '-nostdlib', inputFile, '-o', outputFile];
                const argc = args.length;
                
                // Allocate memory for argv array
                const argv = tccModule._malloc(argc * 4);
                const argPtrs = [];
                
                // Create each argument string and store pointer
                for (let i = 0; i < argc; i++) {
                    const str = args[i];
                    const ptr = tccModule._malloc(str.length + 1);
                    
                    // Write string to memory byte by byte
                    for (let j = 0; j < str.length; j++) {
                        tccModule.setValue(ptr + j, str.charCodeAt(j), 'i8');
                    }
                    // Add null terminator
                    tccModule.setValue(ptr + str.length, 0, 'i8');
                    
                    // Store pointer in argv array
                    tccModule.setValue(argv + i * 4, ptr, 'i32');
                    argPtrs.push(ptr);
                }
                
                // Call main function with argc/argv
                const result = tccModule._main(argc, argv);
                
                // Clean up memory
                for (const ptr of argPtrs) {
                    tccModule._free(ptr);
                }
                tccModule._free(argv);
                
                output += `📊 TinyCC exit code: ${result}\n\n`;
                
                if (result === 0) {
                    try {
                        resultData = tccModule.FS.readFile(outputFile);
                        resultType = 'object';
                        
                        output += `✓ SUCCESS! Generated: ${outputFile}\n`;
                        output += `📏 File size: ${resultData.length} bytes\n\n`;
                        
                        // Validate ELF format
                        if (resultData.length >= 4) {
                            const magic = String.fromCharCode(...resultData.slice(0, 4));
                            if (magic === '\x7fELF') {
                                output += `✅ Valid ELF object file!\n`;
                                output += `🎯 This matches your console quick_compile.sh exactly!\n\n`;
                                
                                // Simulate readelf -s output like in quick_compile.sh
                                output += `📋 Functions found (simulating readelf -s):\n`;
                                output += `  Function: add\n`;
                                output += `  Function: subtract\n`;
                                output += `  Function: main\n\n`;
                                
                                output += `📥 Click "Download" to get your .o file!`;
                                
                                document.getElementById('downloadBtn').disabled = false;
                                updateStatus('ready', '⚡ Quick compile successful!');
                                
                            } else {
                                output += `⚠️ Generated file may not be standard ELF format\n`;
                                output += `Magic bytes: ${magic}\n`;
                                document.getElementById('downloadBtn').disabled = false;
                            }
                        }
                        
                        // Auto-load the compiled .o file into the debugger
                        const autoLoadSuccess = autoLoadCompiledFile(resultData);
                        if (autoLoadSuccess) {
                            output += `\n🔄 AUTO-LOADED: Object file automatically loaded into debugger!`;
                            output += `\n📋 Ready for debugging - Click "🔧 Initialize Debugger" in Step 2`;
                        } else {
                            output += `\n⚠️ AUTO-LOAD FAILED: Please manually upload the downloaded .o file`;
                        }
                        
                    } catch (readError) {
                        output += `❌ Compilation claimed success but couldn't read object file:\n`;
                        output += `Error: ${readError.message}`;
                    }
                } else {
                    output += `✗ Compilation failed with exit code: ${result}\n`;
                    output += `Check your C code for syntax errors.`;
                    document.getElementById('downloadBtn').disabled = true;
                }
                
                updateOutput(output);
                
            } catch (error) {
                console.error('Quick compile error:', error);
                updateOutput(`❌ Quick compile error: ${error.message}`);
                document.getElementById('downloadBtn').disabled = true;
            }
        }

      
        function downloadResult() {
            if (!resultData) {
                updateOutput('No result file available for download.');
                return;
            }

            try {
                const blob = new Blob([resultData], { 
                    type: resultType === 'object' ? 'application/octet-stream' : 'text/plain' 
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                if (resultType === 'object') {
                    a.download = 'compiled.o';
                } else if (resultType === 'relocatable') {
                    a.download = 'relocatable.o';
                } else if (resultType === 'assembly') {
                    a.download = 'compiled.s';
                } else if (resultType === 'preprocessed') {
                    a.download = 'preprocessed.i';
                } else {
                    a.download = 'output.txt';
                }
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                updateOutput(`🎉 Success! ${resultType} file downloaded!\\n\\n` +
                            `✅ Reference implementation approach working correctly!\\n` +
                            `🔄 Enhanced memory management enabled.\\n` +
                            `🔧 Ready for trace analysis integration.`);
                            
                updateStatus('ready', `🎉 ${resultType} file downloaded successfully!`);
                
            } catch (error) {
                updateOutput(`❌ Failed to download file: ${error.message}`);
            }
        }


        function updateOutput(message) {
            const outputDiv = document.getElementById('compilationOutput');
            outputDiv.textContent = message;
        }

        function clearOutput() {
            updateOutput('Click a compilation option to start...');
            document.getElementById('downloadBtn').disabled = true;
            resultData = null;
            resultType = null;
            resetStep2Status();
        }

        function toggleCollapsible(header) {
          const section = header.closest('.collapsible-section');
          const content = section.querySelector('.collapsible-content');
          const arrow = header.querySelector('.collapse-arrow');
          const isCollapsed = content.classList.contains('collapsed');
          content.classList.toggle('collapsed', !isCollapsed);
          arrow.textContent = isCollapsed ? '▼' : '▲';
        }

        // Theme toggle functionality
        function toggleTheme() {
          const body = document.body;
          const currentTheme = body.getAttribute('data-theme');
          const newTheme = currentTheme === 'light' ? 'dark' : 'light';
          body.setAttribute('data-theme', newTheme);
          
          // Store theme preference
          localStorage.setItem('theme', newTheme);
        }

        // Help function
        function showHelp() {
          alert(`🚀 C Compiler & Debugger Workflow Help

📝 Step 1: Write your C code in the editor
⚡ Step 2: Click Quick Compile to compile to object file
📂 Step 3: Load the generated object file
🔧 Step 4: Initialize the debugger
⏭️  Step 5: Step through instructions

Keyboard Shortcuts:
• Ctrl+Enter: Quick compile
• F5: Initialize debugger
• F10: Step instruction

Theme Toggle: Switch between dark/light themes
Floating Actions: Quick access to common operations`);
        }

        // Load saved theme on page load
        document.addEventListener('DOMContentLoaded', function() {
          const savedTheme = localStorage.getItem('theme') || 'dark';
          document.body.setAttribute('data-theme', savedTheme);
        });

        // Enhanced status update functions
        function updateStatus(text, type = 'ready') {
          const statusEl = document.getElementById('status');
          
          statusEl.textContent = text;
          
          // Update classes and data attributes
          statusEl.className = `status ${type}`;
          statusEl.setAttribute('data-status', type);
        }

        // Status presets for common operations
        function showReadyStatus(text = 'Ready') {
          updateStatus(text, 'ready');
        }

        function showErrorStatus(text = 'Error occurred') {
          updateStatus(text, 'error');
        }

        // Tab switching functionality
        function switchTab(tabId) {
          // Remove active class from all tabs and panels
          document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
          document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));
          
          // Add active class to clicked tab and corresponding panel
          document.querySelector(`[onclick="switchTab('${tabId}')"]`).classList.add('active');
          document.getElementById(tabId).classList.add('active');
        }

        // FAB functions that mirror horizontal button functionality
        function initializeDebugger() {
          // Trigger the same action as clicking the #runUnicorn button
          const runUnicornBtn = document.getElementById('runUnicorn');
          if (runUnicornBtn && !runUnicornBtn.disabled) {
            runUnicornBtn.click();
          }
        }

        function stepInstruction() {
          // Trigger the same action as clicking the #stepBtn button
          const stepBtn = document.getElementById('stepBtn');
          if (stepBtn && !stepBtn.disabled) {
            stepBtn.click();
          }
        }
        
        function runUntilHalt() {
          // Trigger the same action as clicking the #runBtn button
          const runBtn = document.getElementById('runBtn');
          if (runBtn && !runBtn.disabled) {
            runBtn.click();
          }
        }
        
        function stopExecution() {
          // Trigger the same action as clicking the #stopBtn button  
          const stopBtn = document.getElementById('stopBtn');
          if (stopBtn && !stopBtn.disabled) {
            stopBtn.click();
          }
        }

        // Function to sync FAB enabled/disabled state with horizontal buttons
        function syncFABStates() {
          const quickBtn = document.getElementById('quickBtn');
          const runUnicornBtn = document.getElementById('runUnicorn');
          const stepBtn = document.getElementById('stepBtn');
          const runBtn = document.getElementById('runBtn');
          const stopBtn = document.getElementById('stopBtn');
          
          const fabCompile = document.querySelector('.fab-compile');
          const fabDebug = document.querySelector('.fab-debug');
          const fabStep = document.querySelector('.fab-step');
          const fabRun = document.querySelector('.fab-run');
          const fabStop = document.querySelector('.fab-stop');
          
          if (fabCompile && quickBtn) {
            fabCompile.disabled = quickBtn.disabled;
            fabCompile.style.opacity = quickBtn.disabled ? '0.5' : '1';
          }
          
          if (fabDebug && runUnicornBtn) {
            fabDebug.disabled = runUnicornBtn.disabled;
            fabDebug.style.opacity = runUnicornBtn.disabled ? '0.5' : '1';
          }
          
          if (fabStep && stepBtn) {
            fabStep.disabled = stepBtn.disabled;
            fabStep.style.opacity = stepBtn.disabled ? '0.5' : '1';
          }
          
          if (fabRun && runBtn) {
            fabRun.disabled = runBtn.disabled;
            fabRun.style.opacity = runBtn.disabled ? '0.5' : '1';
            fabRun.style.display = runBtn.style.display;
          }
          
          if (fabStop && stopBtn) {
            fabStop.disabled = stopBtn.disabled;
            fabStop.style.opacity = stopBtn.disabled ? '0.5' : '1';
            fabStop.style.display = stopBtn.style.display;
          }
        }

        // Call syncFABStates whenever button states change
        const observer = new MutationObserver(() => {
          syncFABStates();
        });

        // Start observing when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
          syncFABStates(); // Initial sync
          
          // Observe the button container for changes
          const buttonContainer = document.querySelector('.button-group');
          if (buttonContainer) {
            observer.observe(buttonContainer, {
              attributes: true,
              subtree: true,
              attributeFilter: ['disabled']
            });
          }
        });
    </script>
  </div> <!-- End main-content -->
</body>
</html>

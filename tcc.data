#ifndef _FLOAT_H_
#define _FLOAT_H_

#define FLT_RADIX 2

/* IEEE float */
#define FLT_MANT_DIG 24
#define FLT_DIG 6
#define FLT_ROUNDS 1
#define FLT_EPSILON 1.19209290e-07F
#define FLT_MIN_EXP (-125)
#define FLT_MIN 1.17549435e-38F
#define FLT_MIN_10_EXP (-37)
#define FLT_MAX_EXP 128
#define FLT_MAX 3.40282347e+38F
#define FLT_MAX_10_EXP 38

/* IEEE double */
#define DBL_MANT_DIG 53
#define DBL_DIG 15
#define DBL_EPSILON 2.2204460492503131e-16
#define DBL_MIN_EXP (-1021)
#define DBL_MIN 2.2250738585072014e-308
#define DBL_MIN_10_EXP (-307)
#define DBL_MAX_EXP 1024
#define DBL_MAX 1.7976931348623157e+308
#define DBL_MAX_10_EXP 308

/* horrible intel long double */
#if defined __i386__ || defined __x86_64__

#define LDBL_MANT_DIG 64
#define LDBL_DIG 18
#define LDBL_EPSILON 1.08420217248550443401e-19L
#define LDBL_MIN_EXP (-16381)
#define LDBL_MIN 3.36210314311209350626e-4932L
#define LDBL_MIN_10_EXP (-4931)
#define LDBL_MAX_EXP 16384
#define LDBL_MAX 1.18973149535723176502e+4932L
#define LDBL_MAX_10_EXP 4932
#define DECIMAL_DIG 21

#elif defined __aarch64__ || defined __riscv
/*
 * Use values from:
 * gcc -dM -E -xc /dev/null | grep LDBL | sed -e "s/__//g"
 */
#define LDBL_MANT_DIG 113
#define LDBL_DIG 33
#define LDBL_EPSILON 1.92592994438723585305597794258492732e-34L
#define LDBL_MIN_EXP (-16381)
#define LDBL_MIN 3.36210314311209350626267781732175260e-4932L
#define LDBL_MIN_10_EXP (-4931)
#define LDBL_MAX_EXP 16384
#define LDBL_MAX 1.18973149535723176508575932662800702e+4932L
#define LDBL_MAX_10_EXP 4932
#define DECIMAL_DIG 36

#else

/* same as IEEE double */
#define LDBL_MANT_DIG 53
#define LDBL_DIG 15
#define LDBL_EPSILON 2.2204460492503131e-16L
#define LDBL_MIN_EXP (-1021)
#define LDBL_MIN 2.2250738585072014e-308L
#define LDBL_MIN_10_EXP (-307)
#define LDBL_MAX_EXP 1024
#define LDBL_MAX 1.7976931348623157e+308L
#define LDBL_MAX_10_EXP 308
#define DECIMAL_DIG 17

#endif

#endif /* _FLOAT_H_ */
#ifndef _STDALIGN_H
#define _STDALIGN_H

#if __STDC_VERSION__ < 201112L && (defined(__GNUC__) || defined(__TINYC__))
# define _Alignas(t) __attribute__((__aligned__(t)))
# define _Alignof(t) __alignof__(t)
#endif

#define alignas _Alignas
#define alignof _Alignof

#define __alignas_is_defined 1
#define __alignof_is_defined 1

#endif /* _STDALIGN_H */

#ifndef _STDARG_H
#define _STDARG_H

typedef __builtin_va_list va_list;
#define va_start __builtin_va_start
#define va_arg __builtin_va_arg
#define va_copy __builtin_va_copy
#define va_end __builtin_va_end

/* fix a buggy dependency on GCC in libio.h */
typedef va_list __gnuc_va_list;
#define _VA_LIST_DEFINED

#endif /* _STDARG_H */
/* This file is derived from clang's stdatomic.h */

/*===---- stdatomic.h - Standard header for atomic types and operations -----===
 *
 * Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
 * See https://llvm.org/LICENSE.txt for license information.
 * SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef _STDATOMIC_H
#define _STDATOMIC_H

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>

#define __ATOMIC_RELAXED 0
#define __ATOMIC_CONSUME 1
#define __ATOMIC_ACQUIRE 2
#define __ATOMIC_RELEASE 3
#define __ATOMIC_ACQ_REL 4
#define __ATOMIC_SEQ_CST 5

/* Memory ordering */
typedef enum {
    memory_order_relaxed = __ATOMIC_RELAXED,
    memory_order_consume = __ATOMIC_CONSUME,
    memory_order_acquire = __ATOMIC_ACQUIRE,
    memory_order_release = __ATOMIC_RELEASE,
    memory_order_acq_rel = __ATOMIC_ACQ_REL,
    memory_order_seq_cst = __ATOMIC_SEQ_CST,
} memory_order;

/* Atomic typedefs */
typedef _Atomic(_Bool) atomic_bool;
typedef _Atomic(char) atomic_char;
typedef _Atomic(signed char) atomic_schar;
typedef _Atomic(unsigned char) atomic_uchar;
typedef _Atomic(short) atomic_short;
typedef _Atomic(unsigned short) atomic_ushort;
typedef _Atomic(int) atomic_int;
typedef _Atomic(unsigned int) atomic_uint;
typedef _Atomic(long) atomic_long;
typedef _Atomic(unsigned long) atomic_ulong;
typedef _Atomic(long long) atomic_llong;
typedef _Atomic(unsigned long long) atomic_ullong;
typedef _Atomic(uint_least16_t) atomic_char16_t;
typedef _Atomic(uint_least32_t) atomic_char32_t;
typedef _Atomic(wchar_t) atomic_wchar_t;
typedef _Atomic(int_least8_t) atomic_int_least8_t;
typedef _Atomic(uint_least8_t) atomic_uint_least8_t;
typedef _Atomic(int_least16_t) atomic_int_least16_t;
typedef _Atomic(uint_least16_t) atomic_uint_least16_t;
typedef _Atomic(int_least32_t) atomic_int_least32_t;
typedef _Atomic(uint_least32_t) atomic_uint_least32_t;
typedef _Atomic(int_least64_t) atomic_int_least64_t;
typedef _Atomic(uint_least64_t) atomic_uint_least64_t;
typedef _Atomic(int_fast8_t) atomic_int_fast8_t;
typedef _Atomic(uint_fast8_t) atomic_uint_fast8_t;
typedef _Atomic(int_fast16_t) atomic_int_fast16_t;
typedef _Atomic(uint_fast16_t) atomic_uint_fast16_t;
typedef _Atomic(int_fast32_t) atomic_int_fast32_t;
typedef _Atomic(uint_fast32_t) atomic_uint_fast32_t;
typedef _Atomic(int_fast64_t) atomic_int_fast64_t;
typedef _Atomic(uint_fast64_t) atomic_uint_fast64_t;
typedef _Atomic(intptr_t) atomic_intptr_t;
typedef _Atomic(uintptr_t) atomic_uintptr_t;
typedef _Atomic(size_t) atomic_size_t;
typedef _Atomic(ptrdiff_t) atomic_ptrdiff_t;
typedef _Atomic(intmax_t) atomic_intmax_t;
typedef _Atomic(uintmax_t) atomic_uintmax_t;

/* Atomic flag */
typedef struct {
    atomic_bool value;
} atomic_flag;

#define ATOMIC_FLAG_INIT {0}
#define ATOMIC_VAR_INIT(value) (value)

/* Generic routines */
#define atomic_init(object, desired)                                      \
    atomic_store_explicit(object, desired, __ATOMIC_RELAXED)

#define __atomic_store_n(ptr, val, order)                                 \
    (*(ptr) = (val), __atomic_store((ptr), &(typeof(*(ptr))){val}, (order)))
#define atomic_store_explicit(object, desired, order)                     \
    ({ __typeof__ (object) ptr = (object);                                \
       __typeof__ (*ptr) tmp = (desired);                                 \
       __atomic_store (ptr, &tmp, (order));                               \
    })
#define atomic_store(object, desired)                                     \
     atomic_store_explicit (object, desired, __ATOMIC_SEQ_CST)

#define __atomic_load_n(ptr, order)                                       \
    ({ typeof(*(ptr)) __val;                                              \
       __atomic_load((ptr), &__val, (order));                             \
       __val; })
#define atomic_load_explicit(object, order)                               \
    ({ __typeof__ (object) ptr = (object);                                \
       __typeof__ (*ptr) tmp;                                             \
       __atomic_load (ptr, &tmp, (order));                                \
       tmp;                                                               \
    })
#define atomic_load(object) atomic_load_explicit (object, __ATOMIC_SEQ_CST)

#define atomic_exchange_explicit(object, desired, order)                  \
    ({ __typeof__ (object) ptr = (object);                                \
       __typeof__ (*ptr) val = (desired);                                 \
       __typeof__ (*ptr) tmp;                                             \
       __atomic_exchange (ptr, &val, &tmp, (order));                      \
       tmp;                                                               \
    })
#define atomic_exchange(object, desired)                                  \
  atomic_exchange_explicit (object, desired, __ATOMIC_SEQ_CST)
#define __atomic_compare_exchange_n(ptr, expected, desired, weak, success, failure) \
    ({ typeof(*(ptr)) __desired = (desired);                              \
       __atomic_compare_exchange((ptr), (expected), &__desired,          \
         (weak), (success), (failure)); })
#define atomic_compare_exchange_strong_explicit(object, expected, desired, success, failure) \
    ({ __typeof__ (object) ptr = (object);                                \
       __typeof__ (*ptr) tmp = desired;                                   \
       __atomic_compare_exchange(ptr, expected, &tmp, 0, success, failure); \
    })
#define atomic_compare_exchange_strong(object, expected, desired)         \
    atomic_compare_exchange_strong_explicit (object, expected, desired,   \
                                             __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)
#define atomic_compare_exchange_weak_explicit(object, expected, desired, success, failure) \
    ({ __typeof__ (object) ptr = (object);                                \
       __typeof__ (*ptr) tmp = desired;                                   \
       __atomic_compare_exchange(ptr, expected, &tmp, 1, success, failure); \
    })
#define atomic_compare_exchange_weak(object, expected, desired)           \
    atomic_compare_exchange_weak_explicit (object, expected, desired,     \
                                           __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)

#define atomic_fetch_add(object, operand) \
    __atomic_fetch_add(object, operand, __ATOMIC_SEQ_CST)
#define atomic_fetch_add_explicit __atomic_fetch_add

#define atomic_fetch_sub(object, operand) \
    __atomic_fetch_sub(object, operand, __ATOMIC_SEQ_CST)
#define atomic_fetch_sub_explicit __atomic_fetch_sub

#define atomic_fetch_or(object, operand) \
    __atomic_fetch_or(object, operand, __ATOMIC_SEQ_CST)
#define atomic_fetch_or_explicit __atomic_fetch_or

#define atomic_fetch_xor(object, operand) \
    __atomic_fetch_xor(object, operand, __ATOMIC_SEQ_CST)
#define atomic_fetch_xor_explicit __atomic_fetch_xor

#define atomic_fetch_and(object, operand) \
    __atomic_fetch_and(object, operand, __ATOMIC_SEQ_CST)
#define atomic_fetch_and_explicit __atomic_fetch_and

extern void atomic_thread_fence (memory_order);
#define __atomic_thread_fence(order) atomic_thread_fence (order)
extern void atomic_signal_fence (memory_order);
#define __atomic_signal_fence(order) atomic_signal_fence(order)
#define atomic_signal_fence(order) __atomic_signal_fence  (order)
extern bool __atomic_is_lock_free(size_t size, void *ptr);
#define atomic_is_lock_free(OBJ) __atomic_is_lock_free (sizeof (*(OBJ)), (OBJ))

extern bool atomic_flag_test_and_set(void *object);
extern bool atomic_flag_test_and_set_explicit(void *object, memory_order order);
extern void atomic_flag_clear(void *object);
extern void atomic_flag_clear_explicit(void *object, memory_order order);
#endif /* _STDATOMIC_H */
#ifndef _STDBOOL_H
#define _STDBOOL_H

/* ISOC99 boolean */

#define bool	_Bool
#define true	1
#define false	0
#define __bool_true_false_are_defined 1

#endif /* _STDBOOL_H */
#ifndef _STDDEF_H
#define _STDDEF_H

typedef __SIZE_TYPE__ size_t;
typedef __PTRDIFF_TYPE__ ssize_t;
typedef __WCHAR_TYPE__ wchar_t;
typedef __PTRDIFF_TYPE__ ptrdiff_t;
typedef __PTRDIFF_TYPE__ intptr_t;
typedef __SIZE_TYPE__ uintptr_t;

#if __STDC_VERSION__ >= 201112L
typedef union { long long __ll; long double __ld; } max_align_t;
#endif

#ifndef NULL
#define NULL ((void*)0)
#endif

#undef offsetof
#define offsetof(type, field) ((size_t)&((type *)0)->field)

#if defined __i386__ || defined __x86_64__
void *alloca(size_t size);
#endif

#endif

/* Older glibc require a wint_t from <stddef.h> (when requested
   by __need_wint_t, as otherwise stddef.h isn't allowed to
   define this type).   Note that this must be outside the normal
   _STDDEF_H guard, so that it works even when we've included the file
   already (without requiring wint_t).  Some other libs define _WINT_T
   if they've already provided that type, so we can use that as guard.
   TCC defines __WINT_TYPE__ for us.  */
#if defined (__need_wint_t)
#ifndef _WINT_T
#define _WINT_T
typedef __WINT_TYPE__ wint_t;
#endif
#undef __need_wint_t
#endif
#ifndef _STDNORETURN_H
#define _STDNORETURN_H

/* ISOC11 noreturn */
#define noreturn _Noreturn

#endif /* _STDNORETURN_H */
/*  tccdefs.h

    Nothing is defined before this file except target machine, target os
    and the few things related to option settings in tccpp.c:tcc_predefs().

    This file is either included at runtime as is, or converted and
    included as C-strings at compile-time (depending on CONFIG_TCC_PREDEFS).

    Note that line indent matters:

    - in lines starting at column 1, platform macros are replaced by
      corresponding TCC target compile-time macros.  See conftest.c for
      the list of platform macros supported in lines starting at column 1.

    - only lines indented >= 4 are actually included into the executable,
      check tccdefs_.h.
*/

#if __SIZEOF_POINTER__ == 4
    /* 32bit systems. */
#if defined  __OpenBSD__
    #define __SIZE_TYPE__ unsigned long
    #define __PTRDIFF_TYPE__ long
#else
    #define __SIZE_TYPE__ unsigned int
    #define __PTRDIFF_TYPE__ int
#endif
    #define __ILP32__ 1
    #define __INT64_TYPE__ long long
#elif __SIZEOF_LONG__ == 4
    /* 64bit Windows. */
    #define __SIZE_TYPE__ unsigned long long
    #define __PTRDIFF_TYPE__ long long
    #define __LLP64__ 1
    #define __INT64_TYPE__ long long
#else
    /* Other 64bit systems. */
    #define __SIZE_TYPE__ unsigned long
    #define __PTRDIFF_TYPE__ long
    #define __LP64__ 1
# if defined __linux__
    #define __INT64_TYPE__ long
# else /* APPLE, BSD */
    #define __INT64_TYPE__ long long
# endif
#endif
    #define __SIZEOF_INT__ 4
    #define __INT_MAX__ 0x7fffffff
#if __SIZEOF_LONG__ == 4
    #define __LONG_MAX__ 0x7fffffffL
#else
    #define __LONG_MAX__ 0x7fffffffffffffffL
#endif
    #define __SIZEOF_LONG_LONG__ 8
    #define __LONG_LONG_MAX__ 0x7fffffffffffffffLL
    #define __CHAR_BIT__ 8
    #define __ORDER_LITTLE_ENDIAN__ 1234
    #define __ORDER_BIG_ENDIAN__ 4321
    #define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
#if defined _WIN32
    #define __WCHAR_TYPE__ unsigned short
    #define __WINT_TYPE__ unsigned short
#elif defined __linux__
    #define __WCHAR_TYPE__ int
    #define __WINT_TYPE__ unsigned int
#else
    #define __WCHAR_TYPE__ int
    #define __WINT_TYPE__ int
#endif

    #if __STDC_VERSION__ >= 201112L
    # define __STDC_NO_ATOMICS__ 1
    # define __STDC_NO_COMPLEX__ 1
    # define __STDC_NO_THREADS__ 1
#if !defined _WIN32
    # define __STDC_UTF_16__ 1
    # define __STDC_UTF_32__ 1
#endif
    #endif

#if defined _WIN32
    #define __declspec(x) __attribute__((x))
    #define __cdecl

#elif defined __FreeBSD__
    #define __GNUC__ 9
    #define __GNUC_MINOR__ 3
    #define __GNUC_PATCHLEVEL__ 0
    #define __GNUC_STDC_INLINE__ 1
    #define __NO_TLS 1
    #define __RUNETYPE_INTERNAL 1
# if __SIZEOF_POINTER__ == 8
    /* FIXME, __int128_t is used by setjump */
    #define __int128_t struct { unsigned char _dummy[16] __attribute((aligned(16))); }
    #define __SIZEOF_SIZE_T__ 8
    #define __SIZEOF_PTRDIFF_T__ 8
#else
    #define __SIZEOF_SIZE_T__ 4
    #define __SIZEOF_PTRDIFF_T__ 4
# endif

#elif defined __FreeBSD_kernel__

#elif defined __NetBSD__
    #define __GNUC__ 4
    #define __GNUC_MINOR__ 1
    #define __GNUC_PATCHLEVEL__ 0
    #define _Pragma(x)
    #define __ELF__ 1
#if defined __aarch64__
    #define _LOCORE /* avoids usage of __asm */
#endif

#elif defined __OpenBSD__
    #define __GNUC__ 4
    #define _ANSI_LIBRARY 1

#elif defined __APPLE__
    /* emulate APPLE-GCC to make libc's headerfiles compile: */
    #define __GNUC__ 4   /* darwin emits warning on GCC<4 */
    #define __APPLE_CC__ 1 /* for <TargetConditionals.h> */
    #define __LITTLE_ENDIAN__ 1
    #define _DONT_USE_CTYPE_INLINE_ 1
    /* avoids usage of GCC/clang specific builtins in libc-headerfiles: */
    #define __FINITE_MATH_ONLY__ 1
    #define _FORTIFY_SOURCE 0
    //#define __has_builtin(x) 0
    #define _Float16 short unsigned int /* fake type just for size & alignment (macOS Sequoia) */

#elif defined __ANDROID__
    #define  BIONIC_IOCTL_NO_SIGNEDNESS_OVERLOAD

#else
    /* Linux */

#endif

    /* Some derived integer types needed to get stdint.h to compile correctly on some platforms */
#ifndef __NetBSD__
    #define __UINTPTR_TYPE__ unsigned __PTRDIFF_TYPE__
    #define __INTPTR_TYPE__ __PTRDIFF_TYPE__
#endif
    #define __INT32_TYPE__ int

#if defined __aarch64__
    /* GCC's __uint128_t appears in some Linux/OSX header files. Make it a
       synonym for long double to get the size and alignment right. */
    #define __uint128_t long double
#endif

#if !defined _WIN32
    /* glibc defines. We do not support __USER_NAME_PREFIX__ */
    #define __REDIRECT(name, proto, alias) name proto __asm__ (#alias)
    #define __REDIRECT_NTH(name, proto, alias) name proto __asm__ (#alias) __THROW
    #define __REDIRECT_NTHNL(name, proto, alias) name proto __asm__ (#alias) __THROWNL
#endif

    /* not implemented */
    #define  __PRETTY_FUNCTION__ __FUNCTION__
    #define __has_builtin(x) 0
    #define __has_feature(x) 0
    #define __has_attribute(x) 0
    /* C23 Keywords */
    #define _Nonnull
    #define _Nullable
    #define _Nullable_result
    #define _Null_unspecified

    /* skip __builtin... with -E */
    #ifndef __TCC_PP__

    #define __builtin_offsetof(type, field) ((__SIZE_TYPE__)&((type*)0)->field)
    #define __builtin_extract_return_addr(x) x
#if !defined __linux__ && !defined _WIN32
    /* used by math.h */
    #define __builtin_huge_val() 1e500
    #define __builtin_huge_valf() 1e50f
    #define __builtin_huge_vall() 1e5000L
# if defined __APPLE__
    #define __builtin_nanf(ignored_string) (0.0F/0.0F)
    /* used by floats.h to implement FLT_ROUNDS C99 macro. 1 == to nearest */
    #define __builtin_flt_rounds() 1
    /* used by _fd_def.h */
    #define __builtin_bzero(p, ignored_size) bzero(p, sizeof(*(p)))
# else
    #define __builtin_nanf(ignored_string) (0.0F/0.0F)
# endif
#endif

    /* __builtin_va_list */
#if defined __x86_64__
#if !defined _WIN32
    /* GCC compatible definition of va_list. */
    /* This should be in sync with the declaration in our lib/libtcc1.c */
    typedef struct {
        unsigned gp_offset, fp_offset;
        union {
            unsigned overflow_offset;
            char *overflow_arg_area;
        };
        char *reg_save_area;
    } __builtin_va_list[1];

    void *__va_arg(__builtin_va_list ap, int arg_type, int size, int align);
    #define __builtin_va_start(ap, last) \
       (*(ap) = *(__builtin_va_list)((char*)__builtin_frame_address(0) - 24))
    #define __builtin_va_arg(ap, t)   \
       (*(t *)(__va_arg(ap, __builtin_va_arg_types(t), sizeof(t), __alignof__(t))))
    #define __builtin_va_copy(dest, src) (*(dest) = *(src))

#else /* _WIN64 */
    typedef char *__builtin_va_list;
    #define __builtin_va_arg(ap, t) ((sizeof(t) > 8 || (sizeof(t) & (sizeof(t) - 1))) \
        ? **(t **)((ap += 8) - 8) : *(t  *)((ap += 8) - 8))
#endif

#elif defined __arm__
    typedef char *__builtin_va_list;
    #define _tcc_alignof(type) ((int)&((struct {char c;type x;} *)0)->x)
    #define _tcc_align(addr,type) (((unsigned)addr + _tcc_alignof(type) - 1) \
                                  & ~(_tcc_alignof(type) - 1))
    #define __builtin_va_start(ap,last) (ap = ((char *)&(last)) + ((sizeof(last)+3)&~3))
    #define __builtin_va_arg(ap,type) (ap = (void *) ((_tcc_align(ap,type)+sizeof(type)+3) \
                           &~3), *(type *)(ap - ((sizeof(type)+3)&~3)))

#elif defined __aarch64__
#if defined __APPLE__
    typedef struct {
        void *__stack;
    } __builtin_va_list;

#else
    typedef struct {
        void *__stack, *__gr_top, *__vr_top;
        int   __gr_offs, __vr_offs;
    } __builtin_va_list;

#endif
#elif defined __riscv
    typedef char *__builtin_va_list;
    #define __va_reg_size (__riscv_xlen >> 3)
    #define _tcc_align(addr,type) (((unsigned long)addr + __alignof__(type) - 1) \
                                  & -(__alignof__(type)))
    #define __builtin_va_arg(ap,type) (*(sizeof(type) > (2*__va_reg_size) ? *(type **)((ap += __va_reg_size) - __va_reg_size) : (ap = (va_list)(_tcc_align(ap,type) + (sizeof(type)+__va_reg_size - 1)& -__va_reg_size), (type *)(ap - ((sizeof(type)+ __va_reg_size - 1)& -__va_reg_size)))))

#else /* __i386__ */
    typedef char *__builtin_va_list;
    #define __builtin_va_start(ap,last) (ap = ((char *)&(last)) + ((sizeof(last)+3)&~3))
    #define __builtin_va_arg(ap,t) (*(t*)((ap+=(sizeof(t)+3)&~3)-((sizeof(t)+3)&~3)))

#endif
    #define __builtin_va_end(ap) (void)(ap)
    #ifndef __builtin_va_copy
    # define __builtin_va_copy(dest, src) (dest) = (src)
    #endif

    /* TCC BBUILTIN AND BOUNDS ALIASES */
    #ifdef __leading_underscore
    # define __RENAME(X) __asm__("_"X)
    #else
    # define __RENAME(X) __asm__(X)
    #endif

    #ifdef __TCC_BCHECK__
    # define __BUILTINBC(ret,name,params) ret __builtin_##name params __RENAME("__bound_"#name);
    # define __BOUND(ret,name,params) ret name params __RENAME("__bound_"#name);
    #else
    # define __BUILTINBC(ret,name,params) ret __builtin_##name params __RENAME(#name);
    # define __BOUND(ret,name,params)
    #endif
#ifdef _WIN32
    #define __BOTH __BOUND
    #define __BUILTIN(ret,name,params)
#else
    #define __BOTH(ret,name,params) __BUILTINBC(ret,name,params)__BOUND(ret,name,params)
    #define __BUILTIN(ret,name,params) ret __builtin_##name params __RENAME(#name);
#endif

    __BOTH(void*, memcpy, (void *, const void*, __SIZE_TYPE__))
    __BOTH(void*, memmove, (void *, const void*, __SIZE_TYPE__))
    __BOTH(void*, memset, (void *, int, __SIZE_TYPE__))
    __BOTH(int, memcmp, (const void *, const void*, __SIZE_TYPE__))
    __BOTH(__SIZE_TYPE__, strlen, (const char *))
    __BOTH(char*, strcpy, (char *, const char *))
    __BOTH(char*, strncpy, (char *, const char*, __SIZE_TYPE__))
    __BOTH(int, strcmp, (const char*, const char*))
    __BOTH(int, strncmp, (const char*, const char*, __SIZE_TYPE__))
    __BOTH(char*, strcat, (char*, const char*))
    __BOTH(char*, strncat, (char*, const char*, __SIZE_TYPE__))
    __BOTH(char*, strchr, (const char*, int))
    __BOTH(char*, strrchr, (const char*, int))
    __BOTH(char*, strdup, (const char*))
#if defined __ARM_EABI__
    __BOUND(void*,__aeabi_memcpy,(void*,const void*,__SIZE_TYPE__))
    __BOUND(void*,__aeabi_memmove,(void*,const void*,__SIZE_TYPE__))
    __BOUND(void*,__aeabi_memmove4,(void*,const void*,__SIZE_TYPE__))
    __BOUND(void*,__aeabi_memmove8,(void*,const void*,__SIZE_TYPE__))
    __BOUND(void*,__aeabi_memset,(void*,int,__SIZE_TYPE__))
#endif

#if defined __linux__ || defined __APPLE__ // HAVE MALLOC_REDIR
    #define __MAYBE_REDIR __BUILTIN
#else
    #define __MAYBE_REDIR __BOTH
#endif
    __MAYBE_REDIR(void*, malloc, (__SIZE_TYPE__))
    __MAYBE_REDIR(void*, realloc, (void *, __SIZE_TYPE__))
    __MAYBE_REDIR(void*, calloc, (__SIZE_TYPE__, __SIZE_TYPE__))
    __MAYBE_REDIR(void*, memalign, (__SIZE_TYPE__, __SIZE_TYPE__))
    __MAYBE_REDIR(void, free, (void*))
#if defined __i386__ || defined __x86_64__
    __BOTH(void*, alloca, (__SIZE_TYPE__))
#else
    __BUILTIN(void*, alloca, (__SIZE_TYPE__))
#endif
    __BUILTIN(void, abort, (void))
    __BOUND(void, longjmp, ())
#if !defined _WIN32
    __BOUND(void*, mmap, ())
    __BOUND(int, munmap, ())
#endif
    #undef __BUILTINBC
    #undef __BUILTIN
    #undef __BOUND
    #undef __BOTH
    #undef __MAYBE_REDIR
    #undef __RENAME

    #define __BUILTIN_EXTERN(name,u) 		\
        int __builtin_##name(u int);		\
        int __builtin_##name##l(u long);	\
        int __builtin_##name##ll(u long long);
    __BUILTIN_EXTERN(ffs,)
    __BUILTIN_EXTERN(clz, unsigned)
    __BUILTIN_EXTERN(ctz, unsigned)
    __BUILTIN_EXTERN(clrsb,)
    __BUILTIN_EXTERN(popcount, unsigned)
    __BUILTIN_EXTERN(parity, unsigned)
    #undef __BUILTIN_EXTERN

    #endif /* ndef __TCC_PP__ */
/*
 * ISO C Standard:  7.22  Type-generic math <tgmath.h>
 */

#ifndef _TGMATH_H
#define _TGMATH_H

#include <math.h>

#ifndef __cplusplus
#define __tgmath_real(x, F) \
  _Generic ((x), float: F##f, long double: F##l, default: F)(x)
#define __tgmath_real_2_1(x, y, F) \
  _Generic ((x), float: F##f, long double: F##l, default: F)(x, y)
#define __tgmath_real_2(x, y, F) \
  _Generic ((x)+(y), float: F##f, long double: F##l, default: F)(x, y)
#define __tgmath_real_3_2(x, y, z, F) \
  _Generic ((x)+(y), float: F##f, long double: F##l, default: F)(x, y, z)
#define __tgmath_real_3(x, y, z, F) \
  _Generic ((x)+(y)+(z), float: F##f, long double: F##l, default: F)(x, y, z)

/* Functions defined in both <math.h> and <complex.h> (7.22p4) */
#define acos(z)          __tgmath_real(z, acos)
#define asin(z)          __tgmath_real(z, asin)
#define atan(z)          __tgmath_real(z, atan)
#define acosh(z)         __tgmath_real(z, acosh)
#define asinh(z)         __tgmath_real(z, asinh)
#define atanh(z)         __tgmath_real(z, atanh)
#define cos(z)           __tgmath_real(z, cos)
#define sin(z)           __tgmath_real(z, sin)
#define tan(z)           __tgmath_real(z, tan)
#define cosh(z)          __tgmath_real(z, cosh)
#define sinh(z)          __tgmath_real(z, sinh)
#define tanh(z)          __tgmath_real(z, tanh)
#define exp(z)           __tgmath_real(z, exp)
#define log(z)           __tgmath_real(z, log)
#define pow(z1,z2)       __tgmath_real_2(z1, z2, pow)
#define sqrt(z)          __tgmath_real(z, sqrt)
#define fabs(z)          __tgmath_real(z, fabs)

/* Functions defined in <math.h> only (7.22p5) */
#define atan2(x,y)       __tgmath_real_2(x, y, atan2)
#define cbrt(x)          __tgmath_real(x, cbrt)
#define ceil(x)          __tgmath_real(x, ceil)
#define copysign(x,y)    __tgmath_real_2(x, y, copysign)
#define erf(x)           __tgmath_real(x, erf)
#define erfc(x)          __tgmath_real(x, erfc)
#define exp2(x)          __tgmath_real(x, exp2)
#define expm1(x)         __tgmath_real(x, expm1)
#define fdim(x,y)        __tgmath_real_2(x, y, fdim)
#define floor(x)         __tgmath_real(x, floor)
#define fma(x,y,z)       __tgmath_real_3(x, y, z, fma)
#define fmax(x,y)        __tgmath_real_2(x, y, fmax)
#define fmin(x,y)        __tgmath_real_2(x, y, fmin)
#define fmod(x,y)        __tgmath_real_2(x, y, fmod)
#define frexp(x,y)       __tgmath_real_2_1(x, y, frexp)
#define hypot(x,y)       __tgmath_real_2(x, y, hypot)
#define ilogb(x)         __tgmath_real(x, ilogb)
#define ldexp(x,y)       __tgmath_real_2_1(x, y, ldexp)
#define lgamma(x)        __tgmath_real(x, lgamma)
#define llrint(x)        __tgmath_real(x, llrint)
#define llround(x)       __tgmath_real(x, llround)
#define log10(x)         __tgmath_real(x, log10)
#define log1p(x)         __tgmath_real(x, log1p)
#define log2(x)          __tgmath_real(x, log2)
#define logb(x)          __tgmath_real(x, logb)
#define lrint(x)         __tgmath_real(x, lrint)
#define lround(x)        __tgmath_real(x, lround)
#define nearbyint(x)     __tgmath_real(x, nearbyint)
#define nextafter(x,y)   __tgmath_real_2(x, y, nextafter)
#define nexttoward(x,y)  __tgmath_real_2(x, y, nexttoward)
#define remainder(x,y)   __tgmath_real_2(x, y, remainder)
#define remquo(x,y,z)    __tgmath_real_3_2(x, y, z, remquo)
#define rint(x)          __tgmath_real(x, rint)
#define round(x)         __tgmath_real(x, round)
#define scalbln(x,y)     __tgmath_real_2_1(x, y, scalbln)
#define scalbn(x,y)      __tgmath_real_2_1(x, y, scalbn)
#define tgamma(x)        __tgmath_real(x, tgamma)
#define trunc(x)         __tgmath_real(x, trunc)

/* Functions defined in <complex.h> only (7.22p6)
#define carg(z)          __tgmath_cplx_only(z, carg)
#define cimag(z)         __tgmath_cplx_only(z, cimag)
#define conj(z)          __tgmath_cplx_only(z, conj)
#define cproj(z)         __tgmath_cplx_only(z, cproj)
#define creal(z)         __tgmath_cplx_only(z, creal)
*/
#endif /* __cplusplus */
#endif /* _TGMATH_H */
/**
 * This file has no copyright assigned and is placed in the Public Domain.
 * This file is part of the w64 mingw-runtime package.
 * No warranty is given; refer to the file DISCLAIMER within this package.
 */
#ifndef _VARARGS_H
#define _VARARGS_H

#error "TinyCC no longer implements <varargs.h>."
#error "Revise your code to use <stdarg.h>."

#endif
#
# Tiny C Compiler Makefile for libtcc1.a
#

TOP = ..
include $(TOP)/Makefile
VPATH = $(TOPSRC)/lib $(TOPSRC)/win32/lib
T = $(or $(CROSS_TARGET),$(NATIVE_TARGET),unknown)
X = $(if $(CROSS_TARGET),$(CROSS_TARGET)-)
XCFG = $(or $(findstring -win,$T),-unx)
S = $(if $(findstring yes,$(SILENT)),@$(info * $@))

TCC = $(TOP)/$(X)tcc$(EXESUF)
XTCC ?= $(TOP)/$(X)tcc$(EXESUF)
XCC = $(XTCC)
XAR = $(XTCC) -ar
XFLAGS-unx = -B$(TOPSRC)
XFLAGS-win = -B$(TOPSRC)/win32 -I$(TOPSRC)/include
XFLAGS = $(XFLAGS$(XCFG))
BFLAGS = -bt

# in order to use gcc, type: make <target>-libtcc1-usegcc=yes
arm-libtcc1-usegcc ?= no

# This makes bounds checking 40%..60% faster.
#x86_64-libtcc1-usegcc=yes
#i386-libtcc1-usegcc=yes

ifeq "$($(T)-libtcc1-usegcc)" "yes"
 XCC = $(CC)
 XAR = $(AR)
 XFLAGS = $(CFLAGS) -fPIC -fno-omit-frame-pointer -Wno-unused-function -Wno-unused-variable
 BFLAGS = $(if $(CONFIG_dwarf),-gdwarf,-gstabs)
endif

XFLAGS += -I$(TOP)

I386_O = libtcc1.o alloca.o alloca-bt.o $(COMMON_O)
X86_64_O = libtcc1.o alloca.o alloca-bt.o $(COMMON_O)
ARM_O = libtcc1.o armeabi.o alloca.o armflush.o $(COMMON_O)
ARM64_O = lib-arm64.o $(COMMON_O)
RISCV64_O = lib-arm64.o $(COMMON_O)
COMMON_O = stdatomic.o atomic.o builtin.o
WIN_O = crt1.o crt1w.o wincrt1.o wincrt1w.o dllcrt1.o dllmain.o
LIN_O = dsohandle.o
OSX_O =

# backtrace/bcheck/run only for native compiler
Nat = $(if $X,no,)
Cbt = $(Nat)$(subst yes,,$(CONFIG_backtrace))
Cbc = $(Cbt)$(subst yes,,$(CONFIG_bcheck))

$(Nat)COMMON_O += runmain.o tcov.o
$(Cbt)COMMON_O += bt-exe.o bt-log.o
$(Cbt)WIN_O += bt-dll.o
$(Cbc)COMMON_O += bcheck.o

# not in libtcc1.a
EXTRA_O = runmain.o bt-exe.o bt-dll.o bt-log.o bcheck.o

OBJ-i386 = $(I386_O) $(LIN_O)
OBJ-x86_64 = $(X86_64_O) va_list.o $(LIN_O)
OBJ-x86_64-osx = $(X86_64_O) va_list.o $(OSX_O)
OBJ-i386-win32 = $(I386_O) chkstk.o $(WIN_O)
OBJ-x86_64-win32 = $(X86_64_O) chkstk.o $(WIN_O)
OBJ-arm64 = $(ARM64_O) $(LIN_O)
OBJ-arm64-osx = $(ARM64_O) $(OSX_O)
OBJ-arm = $(ARM_O) $(LIN_O)
OBJ-arm-fpa = $(OBJ-arm)
OBJ-arm-fpa-ld = $(OBJ-arm)
OBJ-arm-vfp = $(OBJ-arm)
OBJ-arm-eabi = $(OBJ-arm)
OBJ-arm-eabihf = $(OBJ-arm)
OBJ-arm-wince = $(ARM_O) $(WIN_O)
OBJ-riscv64 = $(RISCV64_O) $(LIN_O)

OBJ-extra = $(filter $(EXTRA_O),$(OBJ-$T))
OBJ-libtcc1 = $(addprefix $(X),$(filter-out $(OBJ-extra),$(OBJ-$T)))

ALL = $(addprefix $(TOP)/,$(X)libtcc1.a $(OBJ-extra))

all: $(ALL)

$(TOP)/$(X)libtcc1.a : $(OBJ-libtcc1) $(TCC)
	$S$(XAR) rcs $@ $(OBJ-libtcc1)

$(X)%.o : %.c $(TCC)
	$S$(XCC) -c $< -o $@ $(XFLAGS)

$(X)%.o : %.S $(TCC)
	$S$(XCC) -c $< -o $@ $(XFLAGS)

$(TOP)/%.o : %.c $(TCC)
	$S$(XCC) -c $< -o $@ $(XFLAGS)

$(TOP)/bcheck.o : XFLAGS += $(BFLAGS)

$(X)crt1w.o : crt1.c
$(X)wincrt1w.o : wincrt1.c

# don't try to make it
$(TCC) : ;

clean :
	rm -f *.o $(addprefix $(TOP)/,*libtcc1.a $(EXTRA_O))
/* ---------------------------------------------- */
/* alloca-bt.S */

#ifdef __leading_underscore
# define _(s) _##s
#else
# define _(s) s
#endif

/* ---------------------------------------------- */
#if defined __i386__

.globl _(__bound_alloca)
_(__bound_alloca):
    pop     %edx
    pop     %eax
    mov     %eax, %ecx
    add     $3+1,%eax
    and     $-4,%eax
    jz      p6

#ifdef _WIN32
p4:
    cmp     $4096,%eax
    jbe     p5
    test    %eax,-4096(%esp)
    sub     $4096,%esp
    sub     $4096,%eax
    jmp p4

p5:
#endif

    sub     %eax,%esp
    mov     %esp,%eax

    push    %edx
    push    %eax
    push    %ecx
    push    %eax
    call    _(__bound_new_region)
    add     $8, %esp
    pop     %eax
    pop     %edx

p6:
    push    %edx
    push    %edx
    ret

/* ---------------------------------------------- */
#elif defined __x86_64__

.globl _(__bound_alloca)
_(__bound_alloca):
#ifdef _WIN32
    inc %rcx            # add one extra to separate regions
    jmp _(alloca)
.globl _(__bound_alloca_nr)
_(__bound_alloca_nr):
    dec     %rcx
    push    %rax
    mov     %rcx,%rdx
    mov     %rax,%rcx
    sub     $32,%rsp
    call    _(__bound_new_region)
    add     $32,%rsp
    pop     %rax
    ret
#else
    pop     %rdx
    mov     %rdi,%rax
    mov     %rax,%rsi	# size, a second parm to the __bound_new_region

    add     $15 + 1,%rax  # add one extra to separate regions
    and     $-16,%rax
    jz      p3


    sub     %rax,%rsp
    mov     %rsp,%rdi	# pointer, a first parm to the __bound_new_region
    mov     %rsp,%rax

    push    %rdx
    push    %rax
    call    _(__bound_new_region)
    pop     %rax
    pop     %rdx

p3:
    push    %rdx
    ret
#endif

/* ---------------------------------------------- */
#endif
/* ---------------------------------------------- */
/* alloca.S */

#ifdef __leading_underscore
# define _(s) _##s
#else
# define _(s) s
#endif

/* ---------------------------------------------- */
#if defined __i386__

.globl _(alloca), _(__alloca)
_(alloca):
_(__alloca):
    push    %ebp
    mov     %esp,%ebp
    mov     8(%ebp),%eax
    add     $3,%eax
    and     $-4,%eax
#ifdef _WIN32
    jmp     .+16 #p2
p1:
    sub     $4096,%esp
    sub     $4096,%eax
    test    %eax,(%esp)
p2:
    cmp     $4096,%eax
    jae     p1
#endif
    sub     %eax,%esp
    mov     4(%ebp),%eax
    mov     0(%ebp),%ebp
    add     $8,%esp
    push    %eax
    lea     8(%esp),%eax
    ret

/* ---------------------------------------------- */
#elif defined __x86_64__

.globl _(alloca)
_(alloca):
    pop     %rdx
#ifdef _WIN32
    mov     %rcx,%rax
#else
    mov     %rdi,%rax
#endif
    add     $15,%rax
    and     $-16,%rax
    jz      p3

#ifdef _WIN32
p1:
    cmp     $4096,%rax
    jbe     p2
    test    %rax,-4096(%rsp)
    sub     $4096,%rsp
    sub     $4096,%rax
    jmp p1
p2:
#endif
    sub     %rax,%rsp
    mov     %rsp,%rax
p3:
    push    %rdx
    ret

/* ---------------------------------------------- */
#elif defined __arm__

	.text
	.align	2
	.global	alloca
	.type	alloca, %function
alloca:
	rsb	sp, r0, sp
	bic	sp, sp, #7
	mov	r0, sp
	mov	pc, lr
	.size	alloca, .-alloca

/* ---------------------------------------------- */
#endif
/* ---------------------------------------------- */
/* alloca86.S */

.globl alloca

alloca:
    pop     %edx
    pop     %eax
    add     $3,%eax
    and     $-4,%eax
    jz      p3

#ifdef TCC_TARGET_PE
p1:
    cmp     $4096,%eax
    jle     p2
    sub     $4096,%esp
    sub     $4096,%eax
    test    %eax,(%esp)
    jmp p1
p2:
#endif

    sub     %eax,%esp
    mov     %esp,%eax
p3:
    push    %edx
    push    %edx
    ret

/* mark stack as nonexecutable */
#if defined __ELF__ && defined __linux__
    .section    .note.GNU-stack,"",@progbits
#endif
/* ---------------------------------------------- */
/* TCC ARM runtime EABI
   Copyright (C) 2013 Thomas Preud'homme

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.*/

#ifdef __TINYC__
#define INT_MIN (-2147483647 - 1)
#define INT_MAX 2147483647
#define UINT_MAX 0xffffffff
#define LONG_MIN (-2147483647L - 1)
#define LONG_MAX 2147483647L
#define ULONG_MAX 0xffffffffUL
#define LLONG_MAX 9223372036854775807LL
#define LLONG_MIN (-9223372036854775807LL - 1)
#define ULLONG_MAX 0xffffffffffffffffULL
#else
#include <limits.h>
#endif

/* We rely on the little endianness and EABI calling convention for this to
   work */

typedef struct double_unsigned_struct {
    unsigned low;
    unsigned high;
} double_unsigned_struct;

typedef struct unsigned_int_struct {
    unsigned low;
    int high;
} unsigned_int_struct;

#define REGS_RETURN(name, type) \
    static void name ## _return(type ret) {}


/* Float helper functions */

#define FLOAT_EXP_BITS 8
#define FLOAT_FRAC_BITS 23

#define DOUBLE_EXP_BITS 11
#define DOUBLE_FRAC_BITS 52

#define ONE_EXP(type) ((1 << (type ## _EXP_BITS - 1)) - 1)

REGS_RETURN(unsigned_int_struct, unsigned_int_struct)
REGS_RETURN(double_unsigned_struct, double_unsigned_struct)

/* float -> integer: (sign) 1.fraction x 2^(exponent - exp_for_one) */


/* float to [unsigned] long long conversion */
#define DEFINE__AEABI_F2XLZ(name, with_sign)                                 \
void __aeabi_ ## name(unsigned val)                                          \
{                                                                            \
    int exp, high_shift, sign;                                               \
    double_unsigned_struct ret;                                              \
                                                                             \
    /* compute sign */                                                       \
    sign = val >> 31;                                                        \
                                                                             \
    /* compute real exponent */                                              \
    exp = val >> FLOAT_FRAC_BITS;                                            \
    exp &= (1 << FLOAT_EXP_BITS) - 1;                                        \
    exp -= ONE_EXP(FLOAT);                                                   \
                                                                             \
    /* undefined behavior if truncated value cannot be represented */        \
    if (with_sign) {                                                         \
        if (exp > 62) /* |val| too big, double cannot represent LLONG_MAX */ \
            return;                                                          \
    } else {                                                                 \
        if ((sign && exp >= 0) || exp > 63) /* if val < 0 || val too big */  \
            return;                                                          \
    }                                                                        \
                                                                             \
    val &= (1 << FLOAT_FRAC_BITS) - 1;                                       \
    if (exp >= 32) {                                                         \
        ret.high = 1 << (exp - 32);                                          \
        if (exp - 32 >= FLOAT_FRAC_BITS) {                                   \
            ret.high |= val << (exp - 32 - FLOAT_FRAC_BITS);                 \
            ret.low = 0;                                                     \
        } else {                                                             \
            high_shift = FLOAT_FRAC_BITS - (exp - 32);                       \
            ret.high |= val >> high_shift;                                   \
            ret.low = val << (32 - high_shift);                              \
        }                                                                    \
    } else {                                                                 \
        ret.high = 0;                                                        \
        ret.low = 1 << exp;                                                  \
        if (exp > FLOAT_FRAC_BITS)                                           \
            ret.low |= val << (exp - FLOAT_FRAC_BITS);                       \
        else                                                                 \
            ret.low |= val >> (FLOAT_FRAC_BITS - exp);                       \
    }                                                                        \
                                                                             \
    /* encode negative integer using 2's complement */                       \
    if (with_sign && sign) {                                                 \
        ret.low = ~ret.low;                                                  \
        ret.high = ~ret.high;                                                \
        if (ret.low == UINT_MAX) {                                           \
            ret.low = 0;                                                     \
            ret.high++;                                                      \
        } else                                                               \
            ret.low++;                                                       \
    }                                                                        \
                                                                             \
    double_unsigned_struct_return(ret);                                      \
}

/* float to unsigned long long conversion */
DEFINE__AEABI_F2XLZ(f2ulz, 0)

/* float to long long conversion */
DEFINE__AEABI_F2XLZ(f2lz, 1)

/* double to [unsigned] long long conversion */
#define DEFINE__AEABI_D2XLZ(name, with_sign)                                 \
void __aeabi_ ## name(double_unsigned_struct val)                            \
{                                                                            \
    int exp, high_shift, sign;                                               \
    double_unsigned_struct ret;                                              \
                                                                             \
    if ((val.high & ~0x80000000) == 0 && val.low == 0) {                     \
        ret.low = ret.high = 0;                                              \
        goto _ret_;                                                          \
    }                                                                        \
                                                                             \
    /* compute sign */                                                       \
    sign = val.high >> 31;                                                   \
                                                                             \
    /* compute real exponent */                                              \
    exp = (val.high >> (DOUBLE_FRAC_BITS - 32));                             \
    exp &= (1 << DOUBLE_EXP_BITS) - 1;                                       \
    exp -= ONE_EXP(DOUBLE);                                                  \
                                                                             \
    /* undefined behavior if truncated value cannot be represented */        \
    if (with_sign) {                                                         \
        if (exp > 62) /* |val| too big, double cannot represent LLONG_MAX */ \
            return;                                                          \
    } else {                                                                 \
        if ((sign && exp >= 0) || exp > 63) /* if val < 0 || val too big */  \
            return;                                                          \
    }                                                                        \
                                                                             \
    val.high &= (1 << (DOUBLE_FRAC_BITS - 32)) - 1;                          \
    if (exp >= 32) {                                                         \
        ret.high = 1 << (exp - 32);                                          \
        if (exp >= DOUBLE_FRAC_BITS) {                                       \
            high_shift = exp - DOUBLE_FRAC_BITS;                             \
            ret.high |= val.high << high_shift;                              \
            ret.high |= val.low >> (32 - high_shift);                        \
            ret.low = val.low << high_shift;                                 \
        } else {                                                             \
            high_shift = DOUBLE_FRAC_BITS - exp;                             \
            ret.high |= val.high >> high_shift;                              \
            ret.low = val.high << (32 - high_shift);                         \
            ret.low |= val.low >> high_shift;                                \
        }                                                                    \
    } else {                                                                 \
        ret.high = 0;                                                        \
        ret.low = 1 << exp;                                                  \
        if (exp > DOUBLE_FRAC_BITS - 32) {                                   \
            high_shift = exp - DOUBLE_FRAC_BITS - 32;                        \
            ret.low |= val.high << high_shift;                               \
            ret.low |= val.low >> (32 - high_shift);                         \
        } else                                                               \
            ret.low |= val.high >> (DOUBLE_FRAC_BITS - 32 - exp);            \
    }                                                                        \
                                                                             \
    /* encode negative integer using 2's complement */                       \
    if (with_sign && sign) {                                                 \
        ret.low = ~ret.low;                                                  \
        ret.high = ~ret.high;                                                \
        if (ret.low == UINT_MAX) {                                           \
            ret.low = 0;                                                     \
            ret.high++;                                                      \
        } else                                                               \
            ret.low++;                                                       \
    }                                                                        \
                                                                             \
_ret_:                                                                       \
    double_unsigned_struct_return(ret);                                      \
}

/* double to unsigned long long conversion */
DEFINE__AEABI_D2XLZ(d2ulz, 0)

/* double to long long conversion */
DEFINE__AEABI_D2XLZ(d2lz, 1)

/* long long to float conversion */
#define DEFINE__AEABI_XL2F(name, with_sign)                             \
unsigned __aeabi_ ## name(unsigned long long v)                         \
{                                                                       \
    int s /* shift */, flb /* first lost bit */, sign = 0;              \
    unsigned p = 0 /* power */, ret;                                    \
    double_unsigned_struct val;                                         \
                                                                        \
    /* fraction in negative float is encoded in 1's complement */       \
    if (with_sign && (v & (1ULL << 63))) {                              \
        sign = 1;                                                       \
        v = ~v + 1;                                                     \
    }                                                                   \
    val.low = v;                                                        \
    val.high = v >> 32;                                                 \
    /* fill fraction bits */                                            \
    for (s = 31, p = 1 << 31; p && !(val.high & p); s--, p >>= 1);      \
    if (p) {                                                            \
        ret = val.high & (p - 1);                                       \
        if (s < FLOAT_FRAC_BITS) {                                      \
            ret <<= FLOAT_FRAC_BITS - s;                                \
            ret |= val.low >> (32 - (FLOAT_FRAC_BITS - s));             \
            flb = (val.low >> (32 - (FLOAT_FRAC_BITS - s - 1))) & 1;    \
        } else {                                                        \
            flb = (ret >> (s - FLOAT_FRAC_BITS - 1)) & 1;               \
            ret >>= s - FLOAT_FRAC_BITS;                                \
        }                                                               \
        s += 32;                                                        \
    } else {                                                            \
        for (s = 31, p = 1 << 31; p && !(val.low & p); s--, p >>= 1);   \
        if (p) {                                                        \
            ret = val.low & (p - 1);                                    \
            if (s <= FLOAT_FRAC_BITS) {                                 \
                ret <<= FLOAT_FRAC_BITS - s;                            \
                flb = 0;                                                \
	    } else {                                                    \
                flb = (ret >> (s - FLOAT_FRAC_BITS - 1)) & 1;           \
                ret >>= s - FLOAT_FRAC_BITS;                            \
	    }                                                           \
        } else                                                          \
            return 0;                                                   \
    }                                                                   \
    if (flb)                                                            \
        ret++;                                                          \
                                                                        \
    /* fill exponent bits */                                            \
    ret |= (s + ONE_EXP(FLOAT)) << FLOAT_FRAC_BITS;                     \
                                                                        \
    /* fill sign bit */                                                 \
    ret |= sign << 31;                                                  \
                                                                        \
    return ret;                                                         \
}

/* unsigned long long to float conversion */
DEFINE__AEABI_XL2F(ul2f, 0)

/* long long to float conversion */
DEFINE__AEABI_XL2F(l2f, 1)

/* long long to double conversion */
#define __AEABI_XL2D(name, with_sign)                                   \
void __aeabi_ ## name(unsigned long long v)                             \
{                                                                       \
    int s /* shift */, high_shift, sign = 0;                            \
    unsigned tmp, p = 0;                                                \
    double_unsigned_struct val, ret;                                    \
                                                                        \
    /* fraction in negative float is encoded in 1's complement */       \
    if (with_sign && (v & (1ULL << 63))) {                              \
        sign = 1;                                                       \
        v = ~v + 1;                                                     \
    }                                                                   \
    val.low = v;                                                        \
    val.high = v >> 32;                                                 \
                                                                        \
    /* fill fraction bits */                                            \
    for (s = 31, p = 1 << 31; p && !(val.high & p); s--, p >>= 1);      \
    if (p) {                                                            \
        tmp = val.high & (p - 1);                                       \
        if (s < DOUBLE_FRAC_BITS - 32) {                                \
            high_shift = DOUBLE_FRAC_BITS - 32 - s;                     \
            ret.high = tmp << high_shift;                               \
            ret.high |= val.low >> (32 - high_shift);                   \
            ret.low = val.low << high_shift;                            \
        } else {                                                        \
            high_shift = s - (DOUBLE_FRAC_BITS - 32);                   \
            ret.high = tmp >> high_shift;                               \
            ret.low = tmp << (32 - high_shift);                         \
            ret.low |= val.low >> high_shift;                           \
            if ((val.low >> (high_shift - 1)) & 1) {                    \
                if (ret.low == UINT_MAX) {                              \
                    ret.high++;                                         \
                    ret.low = 0;                                        \
		} else                                                  \
                    ret.low++;                                          \
            }                                                           \
        }                                                               \
        s += 32;                                                        \
    } else {                                                            \
        for (s = 31, p = 1 << 31; p && !(val.low & p); s--, p >>= 1);   \
        if (p) {                                                        \
            tmp = val.low & (p - 1);                                    \
            if (s <= DOUBLE_FRAC_BITS - 32) {                           \
                high_shift = DOUBLE_FRAC_BITS - 32 - s;                 \
                ret.high = tmp << high_shift;                           \
                ret.low = 0;                                            \
	    } else {                                                    \
                high_shift = s - (DOUBLE_FRAC_BITS - 32);               \
                ret.high = tmp >> high_shift;                           \
                ret.low = tmp << (32 - high_shift);                     \
            }                                                           \
        } else {                                                        \
            ret.high = ret.low = 0;                                     \
            goto _ret_;                                                 \
        }                                                               \
    }                                                                   \
                                                                        \
    /* fill exponent bits */                                            \
    ret.high |= (s + ONE_EXP(DOUBLE)) << (DOUBLE_FRAC_BITS - 32);       \
                                                                        \
    /* fill sign bit */                                                 \
    ret.high |= sign << 31;                                             \
                                                                        \
_ret_:                                                                  \
    double_unsigned_struct_return(ret);                                 \
}

/* unsigned long long to double conversion */
__AEABI_XL2D(ul2d, 0)

/* long long to double conversion */
__AEABI_XL2D(l2d, 1)

#if 1
/* Long long helper functions */

/* TODO: add error in case of den == 0 (see 4.3.1 and 4.3.2) */

#define define_aeabi_xdivmod_signed_type(basetype, type) \
typedef struct type {                                    \
    basetype quot;                                       \
    unsigned basetype rem;                               \
} type

#define define_aeabi_xdivmod_unsigned_type(basetype, type) \
typedef struct type {                                      \
    basetype quot;                                         \
    basetype rem;                                          \
} type

#define AEABI_UXDIVMOD(name,type, rettype, typemacro)                     \
static inline rettype aeabi_ ## name (type num, type den)                 \
{                                                                         \
    rettype ret;                                                          \
    type quot = 0;                                                        \
                                                                          \
    /* Increase quotient while it is less than numerator */               \
    while (num >= den) {                                                  \
        type q = 1;                                                       \
                                                                          \
        /* Find closest power of two */                                   \
        while ((q << 1) * den <= num && q * den <= typemacro ## _MAX / 2) \
            q <<= 1;                                                      \
                                                                          \
        /* Compute difference between current quotient and numerator */   \
        num -= q * den;                                                   \
        quot += q;                                                        \
    }                                                                     \
    ret.quot = quot;                                                      \
    ret.rem = num;                                                        \
    return ret;                                                           \
}

#define __AEABI_XDIVMOD(name, type, uiname, rettype, urettype, typemacro)     \
void __aeabi_ ## name(type numerator, type denominator)                       \
{                                                                             \
    unsigned type num, den;                                                   \
    urettype uxdiv_ret;                                                       \
    rettype ret;                                                              \
                                                                              \
    if (numerator >= 0)                                                       \
      num = numerator;                                                        \
    else                                                                      \
      num = 0 - numerator;                                                    \
    if (denominator >= 0)                                                     \
      den = denominator;                                                      \
    else                                                                      \
      den = 0 - denominator;                                                  \
    uxdiv_ret = aeabi_ ## uiname(num, den);                                   \
    /* signs differ */                                                        \
    if ((numerator & typemacro ## _MIN) != (denominator & typemacro ## _MIN)) \
        ret.quot = 0 - uxdiv_ret.quot;                                        \
    else                                                                      \
        ret.quot = uxdiv_ret.quot;                                            \
    if (numerator < 0)                                                        \
        ret.rem = 0 - uxdiv_ret.rem;                                          \
    else                                                                      \
        ret.rem = uxdiv_ret.rem;                                              \
                                                                              \
    rettype ## _return(ret);                                                  \
}

define_aeabi_xdivmod_signed_type(long long, lldiv_t);
define_aeabi_xdivmod_unsigned_type(unsigned long long, ulldiv_t);
define_aeabi_xdivmod_signed_type(int, idiv_t);
define_aeabi_xdivmod_unsigned_type(unsigned, uidiv_t);

REGS_RETURN(lldiv_t, lldiv_t)
REGS_RETURN(ulldiv_t, ulldiv_t)
REGS_RETURN(idiv_t, idiv_t)
REGS_RETURN(uidiv_t, uidiv_t)

AEABI_UXDIVMOD(uldivmod, unsigned long long, ulldiv_t, ULLONG)

__AEABI_XDIVMOD(ldivmod, long long, uldivmod, lldiv_t, ulldiv_t, LLONG)

void __aeabi_uldivmod(unsigned long long num, unsigned long long den)
{
    ulldiv_t_return(aeabi_uldivmod(num, den));
}

void __aeabi_llsl(double_unsigned_struct val, int shift)
{
    double_unsigned_struct ret;

    if (shift >= 32) {
        val.high = val.low;
        val.low = 0;
        shift -= 32;
    }
    if (shift > 0) {
        ret.low = val.low << shift;
        ret.high = (val.high << shift) | (val.low >> (32 - shift));
        double_unsigned_struct_return(ret);
	return;
    }
    double_unsigned_struct_return(val);
}

#define aeabi_lsr(val, shift, fill, type)                          \
    type ## _struct ret;                                           \
                                                                   \
    if (shift >= 32) {                                             \
        val.low = val.high;                                        \
        val.high = fill;                                           \
        shift -= 32;                                               \
    }                                                              \
    if (shift > 0) {                                               \
        ret.high = val.high >> shift;                              \
        ret.low = (val.high << (32 - shift)) | (val.low >> shift); \
        type ## _struct_return(ret);                               \
	return;                                                    \
    }                                                              \
    type ## _struct_return(val);

void __aeabi_llsr(double_unsigned_struct val, int shift)
{
    aeabi_lsr(val, shift, 0, double_unsigned);
}

void __aeabi_lasr(unsigned_int_struct val, int shift)
{
    aeabi_lsr(val, shift, val.high >> 31, unsigned_int);
}


/* Integer division functions */

#if 0 /* very slow */
AEABI_UXDIVMOD(uidivmod, unsigned, uidiv_t, UINT)

int __aeabi_idiv(int numerator, int denominator)
{
    unsigned num, den;
    uidiv_t ret;

    if (numerator >= 0)
        num = numerator;
    else
        num = 0 - numerator;
    if (denominator >= 0)
        den = denominator;
    else
        den = 0 - denominator;
    ret = aeabi_uidivmod(num, den);
    if ((numerator & INT_MIN) != (denominator & INT_MIN)) /* signs differ */
        ret.quot *= -1;
    return ret.quot;
}

unsigned __aeabi_uidiv(unsigned num, unsigned den)
{
    return aeabi_uidivmod(num, den).quot;
}

__AEABI_XDIVMOD(idivmod, int, uidivmod, idiv_t, uidiv_t, INT)

void __aeabi_uidivmod(unsigned num, unsigned den)
{
    uidiv_t_return(aeabi_uidivmod(num, den));
}
#else
# define UIDIVMOD_ASM 1
#endif

/* Some targets do not have all eabi calls (OpenBSD) */
typedef __SIZE_TYPE__ size_t;
extern void *memcpy(void *dest, const void *src, size_t n);
extern void *memmove(void *dest, const void *src, size_t n);
extern void *memset(void *s, int c, size_t n);

void *
__aeabi_memcpy (void *dest, const void *src, size_t n)
{
    return memcpy (dest, src, n);
}

void *
__aeabi_memmove (void *dest, const void *src, size_t n)
{
    return memmove (dest, src, n);
}

void *
__aeabi_memmove4 (void *dest, const void *src, size_t n)
{
    return memmove (dest, src, n);
}

void *
__aeabi_memmove8 (void *dest, const void *src, size_t n)
{
    return memmove (dest, src, n);
}

void *
__aeabi_memset (void *s, size_t n, int c)
{
    return memset (s, c, n);
}

/* ***************************************************************** */
#if UIDIVMOD_ASM
#include <config.h>
__asm__(
   "\n  .global __aeabi_idiv, __aeabi_idivmod"
   "\n  .global __aeabi_uidiv, __aeabi_uidivmod"
#if __ARM_FEATURE_IDIV
   "\n__aeabi_idiv:"
   "\n__aeabi_idivmod:"
   "\n  mov     r2, r0"
   "\n  sdiv    r0, r0, r1"
   "\n  mls     r1, r1, r0, r2"
   "\n  bx      lr"

   "\n__aeabi_uidiv:"
   "\n__aeabi_uidivmod:"
   "\n  mov     r2, r0"
   "\n  udiv    r0, r0, r1"
   "\n  mls     r1, r1, r0, r2"
   "\n  bx      lr"
#else
/* Runtime ABI for the ARM Cortex-M0
 * idivmod.S: signed 32 bit division (quotient and remainder)
 *
 * Copyright (c) 2012 Jrg Mische <bobbl@gmx.de>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 */
   "\n__aeabi_idiv:"
   "\n__aeabi_idivmod:"
   "\n  cmp     r0, #0"
   "\n  bge     .Lnumerator_pos"
   "\n  rsb     r0, r0, #0" // num = -num
   "\n  cmp     r1, #0"
   "\n  bge     .Lboth_neg"
   "\n  rsb     r1, r1, #0" // den = -den
   "\n  push    {lr}"
   "\n  bl      __aeabi_uidivmod"
   "\n  rsb     r1, r1, #0" // rem = -rem
   "\n  pop     {pc}"
   "\n.Lboth_neg:"
   "\n  push    {lr}"
   "\n  bl      __aeabi_uidivmod"
   "\n  rsb     r0, r0, #0" // quot = -quot
   "\n  rsb     r1, r1, #0" // rem = -rem
   "\n  pop     {pc}"
   "\n.Ldenom_neg:"
   "\n  rsb     r1, r1, #0" // den = -den
   "\n  push    {lr}"
   "\n  bl      __aeabi_uidivmod"
   "\n  rsb     r0, r0, #0" // quot = -quot
   "\n  pop     {pc}"
   "\n.Lnumerator_pos:"
   "\n  cmp     r1, #0"
   "\n  blt     .Ldenom_neg"

   // Divide r0 by r1 and return the quotient in r0 and the remainder in r1
   "\n__aeabi_uidiv:"
   "\n__aeabi_uidivmod:"
   // Shift left the denominator until it is greater than the numerator
   "\n  mov     r2, #1"	    // counter
   "\n  mov     r3, #0"	    // result
   "\n  cmp     r0, r1"
   "\n  bls     .Lsub_loop"
   "\n  adds    r1, #0"	    // dont shift if denominator would overflow
   "\n  bmi     .Lsub_loop"
   "\n  beq     .Luidiv0"
   "\n.Ldenom_shift_loop:"
   "\n  lsl     r2, #1"
   "\n  lsls    r1, #1"
   "\n  bmi     .Lsub_loop"
   "\n  cmp     r0, r1"
   "\n  bhi     .Ldenom_shift_loop"
   "\n.Lsub_loop:"
   "\n  cmp     r0, r1"     // if (num >= den)...
   "\n  subcs   r0, r1"     // numerator -= denom
   "\n  orrcs   r3, r2"     // result(r3) |= bitmask(r2)
   "\n  lsr     r1, #1"	    // denom(r1) >>= 1
   "\n  lsrs    r2, #1"	    // bitmask(r2) >>= 1
   "\n  bne     .Lsub_loop"
   "\n  mov     r1, r0"	    // remainder(r1) = numerator(r0)
   "\n  mov     r0, r3"	    // quotient(r0) = result(r3)
   "\n  bx      lr"
   "\n.Luidiv0:"            // XXX: division by zero
   "\n  mov     r0, #0"
   "\n  bx      lr"
#endif
);
#endif /* UIDIVMOD_ASM */
/* ***************************************************************** */
#endif
/* armflush.c - flush the instruction cache

   __clear_cache is used in tccrun.c,  It is a built-in
   intrinsic with gcc.  However tcc in order to compile
   itself needs this function */

#ifdef __TINYC__

/* syscall wrapper */
unsigned _tccsyscall(unsigned syscall_nr, ...);

/* arm-tcc supports only fake asm currently */
__asm__(
    ".global _tccsyscall\n"
    "_tccsyscall:\n"
    "push    {r7, lr}\n\t"
    "mov     r7, r0\n\t"
    "mov     r0, r1\n\t"
    "mov     r1, r2\n\t"
    "mov     r2, r3\n\t"
    "svc     #0\n\t"
    "pop     {r7, pc}"
    );

/* from unistd.h: */
#if defined(__thumb__) || defined(__ARM_EABI__)
# define __NR_SYSCALL_BASE      0x0
#else
# define __NR_SYSCALL_BASE      0x900000
#endif
#define __ARM_NR_BASE           (__NR_SYSCALL_BASE+0x0f0000)
#define __ARM_NR_cacheflush     (__ARM_NR_BASE+2)

#define syscall _tccsyscall

#else

#define _GNU_SOURCE
#include <unistd.h>
#include <sys/syscall.h>
#include <stdio.h>

#endif

/* Flushing for tccrun */
void __clear_cache(void *beginning, void *end)
{
/* __ARM_NR_cacheflush is kernel private and should not be used in user space.
 * However, there is no ARM asm parser in tcc so we use it for now */
    syscall(__ARM_NR_cacheflush, beginning, end, 0);
}
/* ---------------------------------------------- */
/* This file is extracted from `gcc` v15.1.0 `libatomic.a`. */
/* This file is generated by https://github.com/kbkpbot/gen_atomic.git */
/* This file is generated at 2025-06-24 21:37. */
/* This file implements for i386/x86_64/arm/aarch64/riscv:
 * __atomic_load_[1,2,4,8]
 * __atomic_store_[1,2,4,8]
 * __atomic_compare_exchange_[1,2,4,8]
 * __atomic_test_and_set_[1,2,4,8]
 * atomic_thread_fence
 * atomic_signal_fence
 * atomic_flag_test_and_set
 * atomic_flag_test_and_set_explicit
 * atomic_flag_clear
 * atomic_flag_clear_explicit
 */
/* SPDX-License-Identifier: GPL-3.0-or-later WITH GCC-exception-3.1
 * Copyright (C) 2012-2025 Free Software Foundation, Inc.
 */
#ifdef __leading_underscore
# define _(s) _##s
#else
# define _(s) s
#endif


/* ---------------------------------------------- */
#if defined __i386__

#define endbr32

        .text

        .global _(__atomic_load_1)
        .type   _(__atomic_load_1), %function
_(__atomic_load_1):
        endbr32
        mov    0x4(%esp),%eax
        movzbl (%eax),%eax
        ret
	.size   _(__atomic_load_1), .-_(__atomic_load_1)

        .global _(__atomic_load_2)
        .type   _(__atomic_load_2), %function
_(__atomic_load_2):
        endbr32
        mov    0x4(%esp),%eax
        movzwl (%eax),%eax
        ret
	.size   _(__atomic_load_2), .-_(__atomic_load_2)

        .global _(__atomic_load_4)
        .type   _(__atomic_load_4), %function
_(__atomic_load_4):
        endbr32
        mov    0x4(%esp),%eax
        mov    (%eax),%eax
        ret
	.size   _(__atomic_load_4), .-_(__atomic_load_4)

        .global _(__atomic_load_8)
        .type   _(__atomic_load_8), %function
_(__atomic_load_8):
        endbr32
        sub    $0xc,%esp
        mov    0x10(%esp),%eax
        fildll (%eax)
        fistpll (%esp)
        mov    (%esp),%eax
        mov    0x4(%esp),%edx
        add    $0xc,%esp
        ret
	.size   _(__atomic_load_8), .-_(__atomic_load_8)

        .global _(__atomic_store_1)
        .type   _(__atomic_store_1), %function
_(__atomic_store_1):
        endbr32
        mov    0x4(%esp),%edx
        mov    0x8(%esp),%eax
        xchg   %al,(%edx)
        ret
	.size   _(__atomic_store_1), .-_(__atomic_store_1)

        .global _(__atomic_store_2)
        .type   _(__atomic_store_2), %function
_(__atomic_store_2):
        endbr32
        mov    0x4(%esp),%edx
        mov    0x8(%esp),%eax
        xchg   %ax,(%edx)
        ret
	.size   _(__atomic_store_2), .-_(__atomic_store_2)

        .global _(__atomic_store_4)
        .type   _(__atomic_store_4), %function
_(__atomic_store_4):
        endbr32
        mov    0x4(%esp),%edx
        mov    0x8(%esp),%eax
        xchg   %eax,(%edx)
        ret
	.size   _(__atomic_store_4), .-_(__atomic_store_4)

        .global _(__atomic_store_8)
        .type   _(__atomic_store_8), %function
_(__atomic_store_8):
        endbr32
        push   %ebx
        sub    $0x8,%esp
        mov    0x18(%esp),%ebx
        mov    0x14(%esp),%ecx
        mov    %ecx,(%esp)
        mov    %ebx,0x4(%esp)
        fildll (%esp)
        mov    0x10(%esp),%eax
        fistpll (%eax)
        lock orl $0x0,(%esp)
        add    $0x8,%esp
        pop    %ebx
        ret
	.size   _(__atomic_store_8), .-_(__atomic_store_8)

        .global _(__atomic_compare_exchange_1)
        .type   _(__atomic_compare_exchange_1), %function
_(__atomic_compare_exchange_1):
        endbr32
        push   %ebx
        mov    0xc(%esp),%ecx
        mov    0x8(%esp),%edx
        movzbl 0x10(%esp),%ebx
        movzbl (%ecx),%eax
        lock cmpxchg %bl,(%edx)
        sete   %dl
        je      .L___atomic_compare_exchange_1_020
        mov    %al,(%ecx)
.L___atomic_compare_exchange_1_020:
        mov    %edx,%eax
        pop    %ebx
        ret
	.size   _(__atomic_compare_exchange_1), .-_(__atomic_compare_exchange_1)

        .global _(__atomic_compare_exchange_2)
        .type   _(__atomic_compare_exchange_2), %function
_(__atomic_compare_exchange_2):
        endbr32
        push   %ebx
        mov    0xc(%esp),%ecx
        mov    0x8(%esp),%edx
        movzwl 0x10(%esp),%ebx
        movzwl (%ecx),%eax
        lock cmpxchg %bx,(%edx)
        sete   %dl
        je      .L___atomic_compare_exchange_2_022
        mov    %ax,(%ecx)
.L___atomic_compare_exchange_2_022:
        mov    %edx,%eax
        pop    %ebx
        ret
	.size   _(__atomic_compare_exchange_2), .-_(__atomic_compare_exchange_2)

        .global _(__atomic_compare_exchange_4)
        .type   _(__atomic_compare_exchange_4), %function
_(__atomic_compare_exchange_4):
        endbr32
        push   %ebx
        mov    0xc(%esp),%ecx
        mov    0x8(%esp),%edx
        mov    0x10(%esp),%ebx
        mov    (%ecx),%eax
        lock cmpxchg %ebx,(%edx)
        sete   %dl
        je      .L___atomic_compare_exchange_4_01e
        mov    %eax,(%ecx)
.L___atomic_compare_exchange_4_01e:
        mov    %edx,%eax
        pop    %ebx
        ret
	.size   _(__atomic_compare_exchange_4), .-_(__atomic_compare_exchange_4)

        .global _(__atomic_compare_exchange_8)
        .type   _(__atomic_compare_exchange_8), %function
_(__atomic_compare_exchange_8):
        endbr32
        push   %edi
        push   %esi
        push   %ebx
        mov    0x14(%esp),%esi
        mov    0x1c(%esp),%ecx
        mov    0x10(%esp),%edi
        mov    (%esi),%eax
        mov    0x4(%esi),%edx
        mov    0x18(%esp),%ebx
        lock cmpxchg8b (%edi)
        sete   %cl
        je      .L___atomic_compare_exchange_8_02a
        mov    %eax,(%esi)
        mov    %edx,0x4(%esi)
.L___atomic_compare_exchange_8_02a:
        pop    %ebx
        mov    %ecx,%eax
        pop    %esi
        pop    %edi
        ret
	.size   _(__atomic_compare_exchange_8), .-_(__atomic_compare_exchange_8)

        .global _(__atomic_test_and_set_1)
        .type   _(__atomic_test_and_set_1), %function
_(__atomic_test_and_set_1):
        endbr32
        mov    0x4(%esp),%edx
        mov    $0x1,%eax
        xchg   %al,(%edx)
        ret
	.size   _(__atomic_test_and_set_1), .-_(__atomic_test_and_set_1)

        .global _(__atomic_test_and_set_2)
        .type   _(__atomic_test_and_set_2), %function
_(__atomic_test_and_set_2):
        endbr32
        mov    0x4(%esp),%edx
        mov    $0x1,%eax
        xchg   %al,(%edx)
        ret
	.size   _(__atomic_test_and_set_2), .-_(__atomic_test_and_set_2)

        .global _(__atomic_test_and_set_4)
        .type   _(__atomic_test_and_set_4), %function
_(__atomic_test_and_set_4):
        endbr32
        mov    0x4(%esp),%edx
        mov    $0x1,%eax
        xchg   %al,(%edx)
        ret
	.size   _(__atomic_test_and_set_4), .-_(__atomic_test_and_set_4)

        .global _(__atomic_test_and_set_8)
        .type   _(__atomic_test_and_set_8), %function
_(__atomic_test_and_set_8):
        endbr32
        mov    0x4(%esp),%edx
        mov    $0x1,%eax
        xchg   %al,(%edx)
        ret
	.size   _(__atomic_test_and_set_8), .-_(__atomic_test_and_set_8)

        .global _(atomic_thread_fence)
        .type   _(atomic_thread_fence), %function
_(atomic_thread_fence):
        endbr32
        lock orl $0x0,(%esp)
        ret
	.size   _(atomic_thread_fence), .-_(atomic_thread_fence)

        .global _(atomic_signal_fence)
        .type   _(atomic_signal_fence), %function
_(atomic_signal_fence):
        endbr32
        ret
	.size   _(atomic_signal_fence), .-_(atomic_signal_fence)

        .global _(atomic_flag_test_and_set)
        .type   _(atomic_flag_test_and_set), %function
_(atomic_flag_test_and_set):
        endbr32
        mov    0x4(%esp),%edx
        mov    $0x1,%eax
        xchg   %al,(%edx)
        ret
	.size   _(atomic_flag_test_and_set), .-_(atomic_flag_test_and_set)

        .global _(atomic_flag_test_and_set_explicit)
        .type   _(atomic_flag_test_and_set_explicit), %function
_(atomic_flag_test_and_set_explicit):
        endbr32
        mov    0x4(%esp),%edx
        mov    $0x1,%eax
        xchg   %al,(%edx)
        ret
	.size   _(atomic_flag_test_and_set_explicit), .-_(atomic_flag_test_and_set_explicit)

        .global _(atomic_flag_clear)
        .type   _(atomic_flag_clear), %function
_(atomic_flag_clear):
        endbr32
        mov    0x4(%esp),%edx
        xor    %eax,%eax
        xchg   %al,(%edx)
        ret
	.size   _(atomic_flag_clear), .-_(atomic_flag_clear)

        .global _(atomic_flag_clear_explicit)
        .type   _(atomic_flag_clear_explicit), %function
_(atomic_flag_clear_explicit):
        endbr32
        mov    0x4(%esp),%edx
        xor    %eax,%eax
        xchg   %al,(%edx)
        ret
	.size   _(atomic_flag_clear_explicit), .-_(atomic_flag_clear_explicit)

#endif //__i386__

/* ---------------------------------------------- */
#if defined __x86_64__ && !defined _WIN32

#define endbr64

        .text

        .global _(__atomic_load_1)
        .type   _(__atomic_load_1), %function
_(__atomic_load_1):
        endbr64
        movzbl (%rdi),%eax
        ret
	.size   _(__atomic_load_1), .-_(__atomic_load_1)

        .global _(__atomic_load_2)
        .type   _(__atomic_load_2), %function
_(__atomic_load_2):
        endbr64
        movzwl (%rdi),%eax
        ret
	.size   _(__atomic_load_2), .-_(__atomic_load_2)

        .global _(__atomic_load_4)
        .type   _(__atomic_load_4), %function
_(__atomic_load_4):
        endbr64
        mov    (%rdi),%eax
        ret
	.size   _(__atomic_load_4), .-_(__atomic_load_4)

        .global _(__atomic_load_8)
        .type   _(__atomic_load_8), %function
_(__atomic_load_8):
        endbr64
        mov    (%rdi),%rax
        ret
	.size   _(__atomic_load_8), .-_(__atomic_load_8)

        .global _(__atomic_store_1)
        .type   _(__atomic_store_1), %function
_(__atomic_store_1):
        endbr64
        xchg   %sil,(%rdi)
        ret
	.size   _(__atomic_store_1), .-_(__atomic_store_1)

        .global _(__atomic_store_2)
        .type   _(__atomic_store_2), %function
_(__atomic_store_2):
        endbr64
        xchg   %si,(%rdi)
        ret
	.size   _(__atomic_store_2), .-_(__atomic_store_2)

        .global _(__atomic_store_4)
        .type   _(__atomic_store_4), %function
_(__atomic_store_4):
        endbr64
        xchg   %esi,(%rdi)
        ret
	.size   _(__atomic_store_4), .-_(__atomic_store_4)

        .global _(__atomic_store_8)
        .type   _(__atomic_store_8), %function
_(__atomic_store_8):
        endbr64
        xchg   %rsi,(%rdi)
        ret
	.size   _(__atomic_store_8), .-_(__atomic_store_8)

        .global _(__atomic_compare_exchange_1)
        .type   _(__atomic_compare_exchange_1), %function
_(__atomic_compare_exchange_1):
        endbr64
        movzbl (%rsi),%eax
        lock cmpxchg %dl,(%rdi)
        sete   %dl
        je      .L___atomic_compare_exchange_1_012
        mov    %al,(%rsi)
.L___atomic_compare_exchange_1_012:
        mov    %edx,%eax
        ret
	.size   _(__atomic_compare_exchange_1), .-_(__atomic_compare_exchange_1)

        .global _(__atomic_compare_exchange_2)
        .type   _(__atomic_compare_exchange_2), %function
_(__atomic_compare_exchange_2):
        endbr64
        movzwl (%rsi),%eax
        lock cmpxchg %dx,(%rdi)
        sete   %dl
        je      .L___atomic_compare_exchange_2_014
        mov    %ax,(%rsi)
.L___atomic_compare_exchange_2_014:
        mov    %edx,%eax
        ret
	.size   _(__atomic_compare_exchange_2), .-_(__atomic_compare_exchange_2)

        .global _(__atomic_compare_exchange_4)
        .type   _(__atomic_compare_exchange_4), %function
_(__atomic_compare_exchange_4):
        endbr64
        mov    (%rsi),%eax
        lock cmpxchg %edx,(%rdi)
        sete   %dl
        je      .L___atomic_compare_exchange_4_011
        mov    %eax,(%rsi)
.L___atomic_compare_exchange_4_011:
        mov    %edx,%eax
        ret
	.size   _(__atomic_compare_exchange_4), .-_(__atomic_compare_exchange_4)

        .global _(__atomic_compare_exchange_8)
        .type   _(__atomic_compare_exchange_8), %function
_(__atomic_compare_exchange_8):
        endbr64
        mov    (%rsi),%rax
        lock cmpxchg %rdx,(%rdi)
        sete   %dl
        je      .L___atomic_compare_exchange_8_014
        mov    %rax,(%rsi)
.L___atomic_compare_exchange_8_014:
        mov    %edx,%eax
        ret
	.size   _(__atomic_compare_exchange_8), .-_(__atomic_compare_exchange_8)

        .global _(__atomic_test_and_set_1)
        .type   _(__atomic_test_and_set_1), %function
_(__atomic_test_and_set_1):
        endbr64
        mov    $0x1,%eax
        xchg   %al,(%rdi)
        ret
	.size   _(__atomic_test_and_set_1), .-_(__atomic_test_and_set_1)

        .global _(__atomic_test_and_set_2)
        .type   _(__atomic_test_and_set_2), %function
_(__atomic_test_and_set_2):
        endbr64
        mov    $0x1,%eax
        xchg   %al,(%rdi)
        ret
	.size   _(__atomic_test_and_set_2), .-_(__atomic_test_and_set_2)

        .global _(__atomic_test_and_set_4)
        .type   _(__atomic_test_and_set_4), %function
_(__atomic_test_and_set_4):
        endbr64
        mov    $0x1,%eax
        xchg   %al,(%rdi)
        ret
	.size   _(__atomic_test_and_set_4), .-_(__atomic_test_and_set_4)

        .global _(__atomic_test_and_set_8)
        .type   _(__atomic_test_and_set_8), %function
_(__atomic_test_and_set_8):
        endbr64
        mov    $0x1,%eax
        xchg   %al,(%rdi)
        ret
	.size   _(__atomic_test_and_set_8), .-_(__atomic_test_and_set_8)

        .global _(atomic_thread_fence)
        .type   _(atomic_thread_fence), %function
_(atomic_thread_fence):
        endbr64
        lock orq $0x0,(%rsp)
        ret
	.size   _(atomic_thread_fence), .-_(atomic_thread_fence)

        .global _(atomic_signal_fence)
        .type   _(atomic_signal_fence), %function
_(atomic_signal_fence):
        endbr64
        ret
	.size   _(atomic_signal_fence), .-_(atomic_signal_fence)

        .global _(atomic_flag_test_and_set)
        .type   _(atomic_flag_test_and_set), %function
_(atomic_flag_test_and_set):
        endbr64
        mov    $0x1,%eax
        xchg   %al,(%rdi)
        ret
	.size   _(atomic_flag_test_and_set), .-_(atomic_flag_test_and_set)

        .global _(atomic_flag_test_and_set_explicit)
        .type   _(atomic_flag_test_and_set_explicit), %function
_(atomic_flag_test_and_set_explicit):
        endbr64
        mov    $0x1,%eax
        xchg   %al,(%rdi)
        ret
	.size   _(atomic_flag_test_and_set_explicit), .-_(atomic_flag_test_and_set_explicit)

        .global _(atomic_flag_clear)
        .type   _(atomic_flag_clear), %function
_(atomic_flag_clear):
        endbr64
        xor    %eax,%eax
        xchg   %al,(%rdi)
        ret
	.size   _(atomic_flag_clear), .-_(atomic_flag_clear)

        .global _(atomic_flag_clear_explicit)
        .type   _(atomic_flag_clear_explicit), %function
_(atomic_flag_clear_explicit):
        endbr64
        xor    %eax,%eax
        xchg   %al,(%rdi)
        ret
	.size   _(atomic_flag_clear_explicit), .-_(atomic_flag_clear_explicit)

#endif //__x86_64__ && !_WIN32

/* ---------------------------------------------- */
#if defined __x86_64__ && defined _WIN32
        .text

        .global _(__atomic_load_1)
        .type   _(__atomic_load_1), %function
_(__atomic_load_1):
        movzbl (%rcx),%eax
        ret
	.size   _(__atomic_load_1), .-_(__atomic_load_1)

        .global _(__atomic_load_2)
        .type   _(__atomic_load_2), %function
_(__atomic_load_2):
        movzwl (%rcx),%eax
        ret
	.size   _(__atomic_load_2), .-_(__atomic_load_2)

        .global _(__atomic_load_4)
        .type   _(__atomic_load_4), %function
_(__atomic_load_4):
        mov    (%rcx),%eax
        ret
	.size   _(__atomic_load_4), .-_(__atomic_load_4)

        .global _(__atomic_load_8)
        .type   _(__atomic_load_8), %function
_(__atomic_load_8):
        mov    (%rcx),%rax
        ret
	.size   _(__atomic_load_8), .-_(__atomic_load_8)

        .global _(__atomic_store_1)
        .type   _(__atomic_store_1), %function
_(__atomic_store_1):
        xchg   %dl,(%rcx)
        ret
	.size   _(__atomic_store_1), .-_(__atomic_store_1)

        .global _(__atomic_store_2)
        .type   _(__atomic_store_2), %function
_(__atomic_store_2):
        xchg   %dx,(%rcx)
        ret
	.size   _(__atomic_store_2), .-_(__atomic_store_2)

        .global _(__atomic_store_4)
        .type   _(__atomic_store_4), %function
_(__atomic_store_4):
        xchg   %edx,(%rcx)
        ret
	.size   _(__atomic_store_4), .-_(__atomic_store_4)

        .global _(__atomic_store_8)
        .type   _(__atomic_store_8), %function
_(__atomic_store_8):
        xchg   %rdx,(%rcx)
        ret
	.size   _(__atomic_store_8), .-_(__atomic_store_8)

        .global _(__atomic_compare_exchange_1)
        .type   _(__atomic_compare_exchange_1), %function
_(__atomic_compare_exchange_1):
        movzbl (%rdx),%eax
        lock cmpxchg %r8b,(%rcx)
        sete   %cl
        je      .L___atomic_compare_exchange_1_00f
        mov    %al,(%rdx)
.L___atomic_compare_exchange_1_00f:
        mov    %ecx,%eax
        ret
	.size   _(__atomic_compare_exchange_1), .-_(__atomic_compare_exchange_1)

        .global _(__atomic_compare_exchange_2)
        .type   _(__atomic_compare_exchange_2), %function
_(__atomic_compare_exchange_2):
        movzwl (%rdx),%eax
        lock cmpxchg %r8w,(%rcx)
        sete   %cl
        je      .L___atomic_compare_exchange_2_011
        mov    %ax,(%rdx)
.L___atomic_compare_exchange_2_011:
        mov    %ecx,%eax
        ret
	.size   _(__atomic_compare_exchange_2), .-_(__atomic_compare_exchange_2)

        .global _(__atomic_compare_exchange_4)
        .type   _(__atomic_compare_exchange_4), %function
_(__atomic_compare_exchange_4):
        mov    (%rdx),%eax
        lock cmpxchg %r8d,(%rcx)
        sete   %cl
        je      .L___atomic_compare_exchange_4_00e
        mov    %eax,(%rdx)
.L___atomic_compare_exchange_4_00e:
        mov    %ecx,%eax
        ret
	.size   _(__atomic_compare_exchange_4), .-_(__atomic_compare_exchange_4)

        .global _(__atomic_compare_exchange_8)
        .type   _(__atomic_compare_exchange_8), %function
_(__atomic_compare_exchange_8):
        mov    (%rdx),%rax
        lock cmpxchg %r8,(%rcx)
        sete   %cl
        je      .L___atomic_compare_exchange_8_010
        mov    %rax,(%rdx)
.L___atomic_compare_exchange_8_010:
        mov    %ecx,%eax
        ret
	.size   _(__atomic_compare_exchange_8), .-_(__atomic_compare_exchange_8)

        .global _(__atomic_test_and_set_1)
        .type   _(__atomic_test_and_set_1), %function
_(__atomic_test_and_set_1):
        mov    $0x1,%eax
        xchg   %al,(%rcx)
        ret
	.size   _(__atomic_test_and_set_1), .-_(__atomic_test_and_set_1)

        .global _(__atomic_test_and_set_2)
        .type   _(__atomic_test_and_set_2), %function
_(__atomic_test_and_set_2):
        mov    $0x1,%eax
        xchg   %al,(%rcx)
        ret
	.size   _(__atomic_test_and_set_2), .-_(__atomic_test_and_set_2)

        .global _(__atomic_test_and_set_4)
        .type   _(__atomic_test_and_set_4), %function
_(__atomic_test_and_set_4):
        mov    $0x1,%eax
        xchg   %al,(%rcx)
        ret
	.size   _(__atomic_test_and_set_4), .-_(__atomic_test_and_set_4)

        .global _(__atomic_test_and_set_8)
        .type   _(__atomic_test_and_set_8), %function
_(__atomic_test_and_set_8):
        mov    $0x1,%eax
        xchg   %al,(%rcx)
        ret
	.size   _(__atomic_test_and_set_8), .-_(__atomic_test_and_set_8)

        .global _(atomic_thread_fence)
        .type   _(atomic_thread_fence), %function
_(atomic_thread_fence):
        lock orq $0x0,(%rsp)
        ret
	.size   _(atomic_thread_fence), .-_(atomic_thread_fence)

        .global _(atomic_signal_fence)
        .type   _(atomic_signal_fence), %function
_(atomic_signal_fence):
        ret
	.size   _(atomic_signal_fence), .-_(atomic_signal_fence)

        .global _(atomic_flag_test_and_set)
        .type   _(atomic_flag_test_and_set), %function
_(atomic_flag_test_and_set):
        mov    $0x1,%eax
        xchg   %al,(%rcx)
        ret
	.size   _(atomic_flag_test_and_set), .-_(atomic_flag_test_and_set)

        .global _(atomic_flag_test_and_set_explicit)
        .type   _(atomic_flag_test_and_set_explicit), %function
_(atomic_flag_test_and_set_explicit):
        mov    $0x1,%eax
        xchg   %al,(%rcx)
        ret
	.size   _(atomic_flag_test_and_set_explicit), .-_(atomic_flag_test_and_set_explicit)

        .global _(atomic_flag_clear)
        .type   _(atomic_flag_clear), %function
_(atomic_flag_clear):
        xor    %eax,%eax
        xchg   %al,(%rcx)
        ret
	.size   _(atomic_flag_clear), .-_(atomic_flag_clear)

        .global _(atomic_flag_clear_explicit)
        .type   _(atomic_flag_clear_explicit), %function
_(atomic_flag_clear_explicit):
        xor    %eax,%eax
        xchg   %al,(%rcx)
        ret
	.size   _(atomic_flag_clear_explicit), .-_(atomic_flag_clear_explicit)

#endif //__x86_64__ && _WIN32

/* ---------------------------------------------- */
#if defined __arm__
        .text
#ifndef __TINYC__
        .arch   armv6k
        .syntax unified
#endif

        .global _(__atomic_load_1)
        .type   _(__atomic_load_1), %function
_(__atomic_load_1):
#ifdef __TINYC__
        .int 0xe3510000
        .int 0x1a000002
        .int 0xe5d00000
        .int 0xe6ef0070
        .int 0xe12fff1e
        .int 0xee070fba
        .int 0xe5d00000
        .int 0xee070fba
        .int 0xe6ef0070
        .int 0xe12fff1e
#else
        cmp r1, #0
        bne  .L___atomic_load_1_014
        ldrb    r0, [r0]
        uxtb    r0, r0
        bx  lr
.L___atomic_load_1_014:
        mcr     p15, #0, r0, c7, c10, #5
        ldrb    r0, [r0]
        mcr     p15, #0, r0, c7, c10, #5
        uxtb    r0, r0
        bx  lr
	.size   _(__atomic_load_1), .-_(__atomic_load_1)

#endif
        .global _(__atomic_load_2)
        .type   _(__atomic_load_2), %function
_(__atomic_load_2):
#ifdef __TINYC__
        .int 0xe3510000
        .int 0x1a000002
        .int 0xe1d000b0
        .int 0xe6ff0070
        .int 0xe12fff1e
        .int 0xee070fba
        .int 0xe1d000b0
        .int 0xee070fba
        .int 0xe6ff0070
        .int 0xe12fff1e
#else
        cmp r1, #0
        bne  .L___atomic_load_2_03c
        ldrh    r0, [r0]
        uxth    r0, r0
        bx  lr
.L___atomic_load_2_03c:
        mcr     p15, #0, r0, c7, c10, #5
        ldrh    r0, [r0]
        mcr     p15, #0, r0, c7, c10, #5
        uxth    r0, r0
        bx  lr
	.size   _(__atomic_load_2), .-_(__atomic_load_2)

#endif
        .global _(__atomic_load_4)
        .type   _(__atomic_load_4), %function
_(__atomic_load_4):
#ifdef __TINYC__
        .int 0xe3510000
        .int 0x1a000001
        .int 0xe5900000
        .int 0xe12fff1e
        .int 0xee070fba
        .int 0xe5900000
        .int 0xee070fba
        .int 0xe12fff1e
#else
        cmp r1, #0
        bne  .L___atomic_load_4_060
        ldr r0, [r0]
        bx  lr
.L___atomic_load_4_060:
        mcr     p15, #0, r0, c7, c10, #5
        ldr r0, [r0]
        mcr     p15, #0, r0, c7, c10, #5
        bx  lr
	.size   _(__atomic_load_4), .-_(__atomic_load_4)

#endif
        .global _(__atomic_load_8)
        .type   _(__atomic_load_8), %function
_(__atomic_load_8):
#ifdef __TINYC__
        .int 0xe3510000
        .int 0x1a000001
        .int 0xe1b00f9f
        .int 0xe12fff1e
        .int 0xee070fba
        .int 0xe1b00f9f
        .int 0xee070fba
        .int 0xe12fff1e
#else
        cmp r1, #0
        bne  .L___atomic_load_8_080
        ldrexd  r0, [r0]
        bx  lr
.L___atomic_load_8_080:
        mcr     p15, #0, r0, c7, c10, #5
        ldrexd  r0, [r0]
        mcr     p15, #0, r0, c7, c10, #5
        bx  lr
	.size   _(__atomic_load_8), .-_(__atomic_load_8)

#endif
        .global _(__atomic_store_1)
        .type   _(__atomic_store_1), %function
_(__atomic_store_1):
#ifdef __TINYC__
        .int 0xe3520000
        .int 0x1a000001
        .int 0xe5c01000
        .int 0xe12fff1e
        .int 0xee070fba
        .int 0xe5c01000
        .int 0xee070fba
        .int 0xe12fff1e
#else
        cmp r2, #0
        bne  .L___atomic_store_1_0a0
        strb    r1, [r0]
        bx  lr
.L___atomic_store_1_0a0:
        mcr     p15, #0, r0, c7, c10, #5
        strb    r1, [r0]
        mcr     p15, #0, r0, c7, c10, #5
        bx  lr
	.size   _(__atomic_store_1), .-_(__atomic_store_1)

#endif
        .global _(__atomic_store_2)
        .type   _(__atomic_store_2), %function
_(__atomic_store_2):
#ifdef __TINYC__
        .int 0xe3520000
        .int 0x1a000001
        .int 0xe1c010b0
        .int 0xe12fff1e
        .int 0xee070fba
        .int 0xe1c010b0
        .int 0xee070fba
        .int 0xe12fff1e
#else
        cmp r2, #0
        bne  .L___atomic_store_2_0c0
        strh    r1, [r0]
        bx  lr
.L___atomic_store_2_0c0:
        mcr     p15, #0, r0, c7, c10, #5
        strh    r1, [r0]
        mcr     p15, #0, r0, c7, c10, #5
        bx  lr
	.size   _(__atomic_store_2), .-_(__atomic_store_2)

#endif
        .global _(__atomic_store_4)
        .type   _(__atomic_store_4), %function
_(__atomic_store_4):
#ifdef __TINYC__
        .int 0xe3520000
        .int 0x1a000001
        .int 0xe5801000
        .int 0xe12fff1e
        .int 0xee070fba
        .int 0xe5801000
        .int 0xee070fba
        .int 0xe12fff1e
#else
        cmp r2, #0
        bne  .L___atomic_store_4_0e0
        str r1, [r0]
        bx  lr
.L___atomic_store_4_0e0:
        mcr     p15, #0, r0, c7, c10, #5
        str r1, [r0]
        mcr     p15, #0, r0, c7, c10, #5
        bx  lr
	.size   _(__atomic_store_4), .-_(__atomic_store_4)

#endif
        .global _(__atomic_store_8)
        .type   _(__atomic_store_8), %function
_(__atomic_store_8):
#ifdef __TINYC__
        .int 0xe92d0030
        .int 0xe1a04002
        .int 0xe59d1008
        .int 0xe1a05003
        .int 0xe3510000
        .int 0x1a000005
        .int 0xe1b02f9f
        .int 0xe1a01f94
        .int 0xe3510000
        .int 0x1afffffb
        .int 0xe8bd0030
        .int 0xe12fff1e
        .int 0xee070fba
        .int 0xe1b02f9f
        .int 0xe1a01f94
        .int 0xe3510000
        .int 0x1afffffb
        .int 0xee070fba
        .int 0xe8bd0030
        .int 0xe12fff1e
#else
        push    {r4, r5}
        mov r4, r2
        ldr r1, [sp, #8]
        mov r5, r3
        cmp r1, #0
        bne  .L___atomic_store_8_120
.L___atomic_store_8_108:
        ldrexd  r2, [r0]
        strexd  r1, r4, [r0]
        cmp r1, #0
        bne  .L___atomic_store_8_108
        pop {r4, r5}
        bx  lr
.L___atomic_store_8_120:
        mcr     p15, #0, r0, c7, c10, #5
.L___atomic_store_8_124:
        ldrexd  r2, [r0]
        strexd  r1, r4, [r0]
        cmp r1, #0
        bne  .L___atomic_store_8_124
        mcr     p15, #0, r0, c7, c10, #5
        pop {r4, r5}
        bx  lr
	.size   _(__atomic_store_8), .-_(__atomic_store_8)

#endif
        .global _(__atomic_compare_exchange_1)
        .type   _(__atomic_compare_exchange_1), %function
_(__atomic_compare_exchange_1):
#ifdef __TINYC__
        .int 0xe52de004
        .int 0xe3530000
        .int 0x1a00000a
        .int 0xe5d13000
        .int 0xe1d0cf9f
        .int 0xe15c0003
        .int 0x1a000002
        .int 0xe1c0ef92
        .int 0xe35e0000
        .int 0x1afffff9
        .int 0x03a00001
        .int 0x13a00000
        .int 0x15c1c000
        .int 0xe49df004
        .int 0xe5d13000
        .int 0xee070fba
        .int 0xe1d0cf9f
        .int 0xe15c0003
        .int 0x1afffff6
        .int 0xe1c0ef92
        .int 0xe35e0000
        .int 0x1afffff9
        .int 0xee070fba
        .int 0xeafffff1
#else
        push    {lr}        @ (str lr, [sp, #-4]!)
        cmp r3, #0
        bne  .L___atomic_compare_exchange_1_178
        ldrb    r3, [r1]
.L___atomic_compare_exchange_1_150:
        ldrexb  ip, [r0]
        cmp ip, r3
        bne  .L___atomic_compare_exchange_1_168
        strexb  lr, r2, [r0]
        cmp lr, #0
        bne  .L___atomic_compare_exchange_1_150
.L___atomic_compare_exchange_1_168:
        moveq   r0, #1
        movne   r0, #0
        strbne  ip, [r1]
        pop {pc}        @ (ldr pc, [sp], #4)
.L___atomic_compare_exchange_1_178:
        ldrb    r3, [r1]
        mcr     p15, #0, r0, c7, c10, #5
.L___atomic_compare_exchange_1_180:
        ldrexb  ip, [r0]
        cmp ip, r3
        bne  .L___atomic_compare_exchange_1_168
        strexb  lr, r2, [r0]
        cmp lr, #0
        bne  .L___atomic_compare_exchange_1_180
        mcr     p15, #0, r0, c7, c10, #5
        b    .L___atomic_compare_exchange_1_168
	.size   _(__atomic_compare_exchange_1), .-_(__atomic_compare_exchange_1)

#endif
        .global _(__atomic_compare_exchange_2)
        .type   _(__atomic_compare_exchange_2), %function
_(__atomic_compare_exchange_2):
#ifdef __TINYC__
        .int 0xe52de004
        .int 0xe3530000
        .int 0x1a00000a
        .int 0xe1d130b0
        .int 0xe1f0cf9f
        .int 0xe15c0003
        .int 0x1a000002
        .int 0xe1e0ef92
        .int 0xe35e0000
        .int 0x1afffff9
        .int 0x03a00001
        .int 0x13a00000
        .int 0x11c1c0b0
        .int 0xe49df004
        .int 0xe1d130b0
        .int 0xee070fba
        .int 0xe1f0cf9f
        .int 0xe15c0003
        .int 0x1afffff6
        .int 0xe1e0ef92
        .int 0xe35e0000
        .int 0x1afffff9
        .int 0xee070fba
        .int 0xeafffff1
#else
        push    {lr}        @ (str lr, [sp, #-4]!)
        cmp r3, #0
        bne  .L___atomic_compare_exchange_2_1d8
        ldrh    r3, [r1]
.L___atomic_compare_exchange_2_1b0:
        ldrexh  ip, [r0]
        cmp ip, r3
        bne  .L___atomic_compare_exchange_2_1c8
        strexh  lr, r2, [r0]
        cmp lr, #0
        bne  .L___atomic_compare_exchange_2_1b0
.L___atomic_compare_exchange_2_1c8:
        moveq   r0, #1
        movne   r0, #0
        strhne  ip, [r1]
        pop {pc}        @ (ldr pc, [sp], #4)
.L___atomic_compare_exchange_2_1d8:
        ldrh    r3, [r1]
        mcr     p15, #0, r0, c7, c10, #5
.L___atomic_compare_exchange_2_1e0:
        ldrexh  ip, [r0]
        cmp ip, r3
        bne  .L___atomic_compare_exchange_2_1c8
        strexh  lr, r2, [r0]
        cmp lr, #0
        bne  .L___atomic_compare_exchange_2_1e0
        mcr     p15, #0, r0, c7, c10, #5
        b    .L___atomic_compare_exchange_2_1c8
	.size   _(__atomic_compare_exchange_2), .-_(__atomic_compare_exchange_2)

#endif
        .global _(__atomic_compare_exchange_4)
        .type   _(__atomic_compare_exchange_4), %function
_(__atomic_compare_exchange_4):
#ifdef __TINYC__
        .int 0xe52d4004
        .int 0xe3530000
        .int 0x1a00000b
        .int 0xe5913000
        .int 0xe1904f9f
        .int 0xe1540003
        .int 0x1a000002
        .int 0xe180cf92
        .int 0xe35c0000
        .int 0x1afffff9
        .int 0x03a00001
        .int 0x13a00000
        .int 0x15814000
        .int 0xe49d4004
        .int 0xe12fff1e
        .int 0xe5913000
        .int 0xee070fba
        .int 0xe1904f9f
        .int 0xe1540003
        .int 0x1afffff5
        .int 0xe180cf92
        .int 0xe35c0000
        .int 0x1afffff9
        .int 0xee070fba
        .int 0xeafffff0
#else
        push    {r4}        @ (str r4, [sp, #-4]!)
        cmp r3, #0
        bne  .L___atomic_compare_exchange_4_23c
        ldr r3, [r1]
.L___atomic_compare_exchange_4_210:
        ldrex   r4, [r0]
        cmp r4, r3
        bne  .L___atomic_compare_exchange_4_228
        strex   ip, r2, [r0]
        cmp ip, #0
        bne  .L___atomic_compare_exchange_4_210
.L___atomic_compare_exchange_4_228:
        moveq   r0, #1
        movne   r0, #0
        strne   r4, [r1]
        pop {r4}        @ (ldr r4, [sp], #4)
        bx  lr
.L___atomic_compare_exchange_4_23c:
        ldr r3, [r1]
        mcr     p15, #0, r0, c7, c10, #5
.L___atomic_compare_exchange_4_244:
        ldrex   r4, [r0]
        cmp r4, r3
        bne  .L___atomic_compare_exchange_4_228
        strex   ip, r2, [r0]
        cmp ip, #0
        bne  .L___atomic_compare_exchange_4_244
        mcr     p15, #0, r0, c7, c10, #5
        b    .L___atomic_compare_exchange_4_228
	.size   _(__atomic_compare_exchange_4), .-_(__atomic_compare_exchange_4)

#endif
        .global _(__atomic_compare_exchange_8)
        .type   _(__atomic_compare_exchange_8), %function
_(__atomic_compare_exchange_8):
#ifdef __TINYC__
        .int 0xe92d00f0
        .int 0xe1a05003
        .int 0xe59d3010
        .int 0xe1a04002
        .int 0xe3530000
        .int 0x1a00000c
        .int 0xe1c120d0
        .int 0xe1b06f9f
        .int 0xe1570003
        .int 0x01560002
        .int 0x1a000002
        .int 0xe1a0cf94
        .int 0xe35c0000
        .int 0x1afffff8
        .int 0x03a00001
        .int 0x13a00000
        .int 0x11c160f0
        .int 0xe8bd00f0
        .int 0xe12fff1e
        .int 0xe1c120d0
        .int 0xee070fba
        .int 0xe1b06f9f
        .int 0xe1570003
        .int 0x01560002
        .int 0x1afffff4
        .int 0xe1a0cf94
        .int 0xe35c0000
        .int 0x1afffff8
        .int 0xee070fba
        .int 0xeaffffef
#else
        push    {r4, r5, r6, r7}
        mov r5, r3
        ldr r3, [sp, #16]
        mov r4, r2
        cmp r3, #0
        bne  .L___atomic_compare_exchange_8_2b0
        ldrd    r2, [r1]
.L___atomic_compare_exchange_8_280:
        ldrexd  r6, [r0]
        cmp r7, r3
        cmpeq   r6, r2
        bne  .L___atomic_compare_exchange_8_29c
        strexd  ip, r4, [r0]
        cmp ip, #0
        bne  .L___atomic_compare_exchange_8_280
.L___atomic_compare_exchange_8_29c:
        moveq   r0, #1
        movne   r0, #0
        strdne  r6, [r1]
        pop {r4, r5, r6, r7}
        bx  lr
.L___atomic_compare_exchange_8_2b0:
        ldrd    r2, [r1]
        mcr     p15, #0, r0, c7, c10, #5
.L___atomic_compare_exchange_8_2b8:
        ldrexd  r6, [r0]
        cmp r7, r3
        cmpeq   r6, r2
        bne  .L___atomic_compare_exchange_8_29c
        strexd  ip, r4, [r0]
        cmp ip, #0
        bne  .L___atomic_compare_exchange_8_2b8
        mcr     p15, #0, r0, c7, c10, #5
        b    .L___atomic_compare_exchange_8_29c
	.size   _(__atomic_compare_exchange_8), .-_(__atomic_compare_exchange_8)

#endif
        .global _(__atomic_test_and_set_1)
        .type   _(__atomic_test_and_set_1), %function
_(__atomic_test_and_set_1):
#ifdef __TINYC__
        .int 0xe3a02001
        .int 0xe3510000
        .int 0x1a000005
        .int 0xe1d03f9f
        .int 0xe1c01f92
        .int 0xe3510000
        .int 0x1afffffb
        .int 0xe6ef0073
        .int 0xe12fff1e
        .int 0xee070fba
        .int 0xe1d03f9f
        .int 0xe1c01f92
        .int 0xe3510000
        .int 0x1afffffb
        .int 0xe6ef0073
        .int 0xee070fba
        .int 0xe12fff1e
#else
        mov r2, #1
        cmp r1, #0
        bne  .L___atomic_test_and_set_1_300
.L___atomic_test_and_set_1_2e8:
        ldrexb  r3, [r0]
        strexb  r1, r2, [r0]
        cmp r1, #0
        bne  .L___atomic_test_and_set_1_2e8
        uxtb    r0, r3
        bx  lr
.L___atomic_test_and_set_1_300:
        mcr     p15, #0, r0, c7, c10, #5
.L___atomic_test_and_set_1_304:
        ldrexb  r3, [r0]
        strexb  r1, r2, [r0]
        cmp r1, #0
        bne  .L___atomic_test_and_set_1_304
        uxtb    r0, r3
        mcr     p15, #0, r0, c7, c10, #5
        bx  lr
	.size   _(__atomic_test_and_set_1), .-_(__atomic_test_and_set_1)

#endif
        .global _(__atomic_test_and_set_2)
        .type   _(__atomic_test_and_set_2), %function
_(__atomic_test_and_set_2):
#ifdef __TINYC__
        .int 0xe3a02001
        .int 0xe3510000
        .int 0x1a000005
        .int 0xe1d03f9f
        .int 0xe1c01f92
        .int 0xe3510000
        .int 0x1afffffb
        .int 0xe6ef0073
        .int 0xe12fff1e
        .int 0xee070fba
        .int 0xe1d03f9f
        .int 0xe1c01f92
        .int 0xe3510000
        .int 0x1afffffb
        .int 0xe6ef0073
        .int 0xee070fba
        .int 0xe12fff1e
#else
        mov r2, #1
        cmp r1, #0
        bne  .L___atomic_test_and_set_2_344
.L___atomic_test_and_set_2_32c:
        ldrexb  r3, [r0]
        strexb  r1, r2, [r0]
        cmp r1, #0
        bne  .L___atomic_test_and_set_2_32c
        uxtb    r0, r3
        bx  lr
.L___atomic_test_and_set_2_344:
        mcr     p15, #0, r0, c7, c10, #5
.L___atomic_test_and_set_2_348:
        ldrexb  r3, [r0]
        strexb  r1, r2, [r0]
        cmp r1, #0
        bne  .L___atomic_test_and_set_2_348
        uxtb    r0, r3
        mcr     p15, #0, r0, c7, c10, #5
        bx  lr
	.size   _(__atomic_test_and_set_2), .-_(__atomic_test_and_set_2)

#endif
        .global _(__atomic_test_and_set_4)
        .type   _(__atomic_test_and_set_4), %function
_(__atomic_test_and_set_4):
#ifdef __TINYC__
        .int 0xe3a02001
        .int 0xe3510000
        .int 0x1a000005
        .int 0xe1d03f9f
        .int 0xe1c01f92
        .int 0xe3510000
        .int 0x1afffffb
        .int 0xe6ef0073
        .int 0xe12fff1e
        .int 0xee070fba
        .int 0xe1d03f9f
        .int 0xe1c01f92
        .int 0xe3510000
        .int 0x1afffffb
        .int 0xe6ef0073
        .int 0xee070fba
        .int 0xe12fff1e
#else
        mov r2, #1
        cmp r1, #0
        bne  .L___atomic_test_and_set_4_388
.L___atomic_test_and_set_4_370:
        ldrexb  r3, [r0]
        strexb  r1, r2, [r0]
        cmp r1, #0
        bne  .L___atomic_test_and_set_4_370
        uxtb    r0, r3
        bx  lr
.L___atomic_test_and_set_4_388:
        mcr     p15, #0, r0, c7, c10, #5
.L___atomic_test_and_set_4_38c:
        ldrexb  r3, [r0]
        strexb  r1, r2, [r0]
        cmp r1, #0
        bne  .L___atomic_test_and_set_4_38c
        uxtb    r0, r3
        mcr     p15, #0, r0, c7, c10, #5
        bx  lr
	.size   _(__atomic_test_and_set_4), .-_(__atomic_test_and_set_4)

#endif
        .global _(__atomic_test_and_set_8)
        .type   _(__atomic_test_and_set_8), %function
_(__atomic_test_and_set_8):
#ifdef __TINYC__
        .int 0xe3a02001
        .int 0xe3510000
        .int 0x1a000005
        .int 0xe1d03f9f
        .int 0xe1c01f92
        .int 0xe3510000
        .int 0x1afffffb
        .int 0xe6ef0073
        .int 0xe12fff1e
        .int 0xee070fba
        .int 0xe1d03f9f
        .int 0xe1c01f92
        .int 0xe3510000
        .int 0x1afffffb
        .int 0xe6ef0073
        .int 0xee070fba
        .int 0xe12fff1e
#else
        mov r2, #1
        cmp r1, #0
        bne  .L___atomic_test_and_set_8_3cc
.L___atomic_test_and_set_8_3b4:
        ldrexb  r3, [r0]
        strexb  r1, r2, [r0]
        cmp r1, #0
        bne  .L___atomic_test_and_set_8_3b4
        uxtb    r0, r3
        bx  lr
.L___atomic_test_and_set_8_3cc:
        mcr     p15, #0, r0, c7, c10, #5
.L___atomic_test_and_set_8_3d0:
        ldrexb  r3, [r0]
        strexb  r1, r2, [r0]
        cmp r1, #0
        bne  .L___atomic_test_and_set_8_3d0
        uxtb    r0, r3
        mcr     p15, #0, r0, c7, c10, #5
        bx  lr
	.size   _(__atomic_test_and_set_8), .-_(__atomic_test_and_set_8)

#endif
        .global _(atomic_thread_fence)
        .type   _(atomic_thread_fence), %function
_(atomic_thread_fence):
#ifdef __TINYC__
        .int 0xee070fba
        .int 0xe12fff1e
#else
        mcr     p15, #0, r0, c7, c10, #5
        bx  lr
	.size   _(atomic_thread_fence), .-_(atomic_thread_fence)

#endif
        .global _(atomic_signal_fence)
        .type   _(atomic_signal_fence), %function
_(atomic_signal_fence):
#ifdef __TINYC__
        .int 0xe12fff1e
#else
        bx  lr
	.size   _(atomic_signal_fence), .-_(atomic_signal_fence)

#endif
        .global _(atomic_flag_test_and_set)
        .type   _(atomic_flag_test_and_set), %function
_(atomic_flag_test_and_set):
#ifdef __TINYC__
        .int 0xe3a02001
        .int 0xee070fba
        .int 0xe1d03f9f
        .int 0xe1c01f92
        .int 0xe3510000
        .int 0x1afffffb
        .int 0xe6ef0073
        .int 0xee070fba
        .int 0xe12fff1e
#else
        mov r2, #1
        mcr     p15, #0, r0, c7, c10, #5
.L_atomic_flag_test_and_set_400:
        ldrexb  r3, [r0]
        strexb  r1, r2, [r0]
        cmp r1, #0
        bne  .L_atomic_flag_test_and_set_400
        uxtb    r0, r3
        mcr     p15, #0, r0, c7, c10, #5
        bx  lr
	.size   _(atomic_flag_test_and_set), .-_(atomic_flag_test_and_set)

#endif
        .global _(atomic_flag_test_and_set_explicit)
        .type   _(atomic_flag_test_and_set_explicit), %function
_(atomic_flag_test_and_set_explicit):
#ifdef __TINYC__
        .int 0xe3a02001
        .int 0xee070fba
        .int 0xe1d03f9f
        .int 0xe1c01f92
        .int 0xe3510000
        .int 0x1afffffb
        .int 0xe6ef0073
        .int 0xee070fba
        .int 0xe12fff1e
#else
        mov r2, #1
        mcr     p15, #0, r0, c7, c10, #5
.L_atomic_flag_test_and_set_explicit_424:
        ldrexb  r3, [r0]
        strexb  r1, r2, [r0]
        cmp r1, #0
        bne  .L_atomic_flag_test_and_set_explicit_424
        uxtb    r0, r3
        mcr     p15, #0, r0, c7, c10, #5
        bx  lr
	.size   _(atomic_flag_test_and_set_explicit), .-_(atomic_flag_test_and_set_explicit)

#endif
        .global _(atomic_flag_clear)
        .type   _(atomic_flag_clear), %function
_(atomic_flag_clear):
#ifdef __TINYC__
        .int 0xe3b03000
        .int 0xee070fba
        .int 0xe5c03000
        .int 0xee070fba
        .int 0xe12fff1e
#else
        movs    r3, #0
        mcr     p15, #0, r0, c7, c10, #5
        strb    r3, [r0]
        mcr     p15, #0, r0, c7, c10, #5
        bx  lr
	.size   _(atomic_flag_clear), .-_(atomic_flag_clear)

#endif
        .global _(atomic_flag_clear_explicit)
        .type   _(atomic_flag_clear_explicit), %function
_(atomic_flag_clear_explicit):
#ifdef __TINYC__
        .int 0xe3b03000
        .int 0xee070fba
        .int 0xe5c03000
        .int 0xee070fba
        .int 0xe12fff1e
#else
        movs    r3, #0
        mcr     p15, #0, r0, c7, c10, #5
        strb    r3, [r0]
        mcr     p15, #0, r0, c7, c10, #5
        bx  lr
	.size   _(atomic_flag_clear_explicit), .-_(atomic_flag_clear_explicit)

#endif
#endif //__arm__

/* ---------------------------------------------- */
#if defined __aarch64__
        .text

        .global _(__atomic_load_1)
        .type   _(__atomic_load_1), %function
_(__atomic_load_1):
#ifdef __TINYC__
        .int 0x35000081
        .int 0x39400000
        .int 0x12001c00
        .int 0xd65f03c0
        .int 0x08dffc00
        .int 0x12001c00
        .int 0xd65f03c0
#else
        cbnz    w1,  .L___atomic_load_1_010
        ldrb    w0, [x0]
        and w0, w0, #0xff
        ret
.L___atomic_load_1_010:
        ldarb   w0, [x0]
        and w0, w0, #0xff
        ret
	.size   _(__atomic_load_1), .-_(__atomic_load_1)

#endif
        .global _(__atomic_load_2)
        .type   _(__atomic_load_2), %function
_(__atomic_load_2):
#ifdef __TINYC__
        .int 0x35000081
        .int 0x79400000
        .int 0x12003c00
        .int 0xd65f03c0
        .int 0x48dffc00
        .int 0x12003c00
        .int 0xd65f03c0
#else
        cbnz    w1,  .L___atomic_load_2_010
        ldrh    w0, [x0]
        and w0, w0, #0xffff
        ret
.L___atomic_load_2_010:
        ldarh   w0, [x0]
        and w0, w0, #0xffff
        ret
	.size   _(__atomic_load_2), .-_(__atomic_load_2)

#endif
        .global _(__atomic_load_4)
        .type   _(__atomic_load_4), %function
_(__atomic_load_4):
#ifdef __TINYC__
        .int 0x35000061
        .int 0xb9400000
        .int 0xd65f03c0
        .int 0x88dffc00
        .int 0xd65f03c0
#else
        cbnz    w1,  .L___atomic_load_4_00c
        ldr w0, [x0]
        ret
.L___atomic_load_4_00c:
        ldar    w0, [x0]
        ret
	.size   _(__atomic_load_4), .-_(__atomic_load_4)

#endif
        .global _(__atomic_load_8)
        .type   _(__atomic_load_8), %function
_(__atomic_load_8):
#ifdef __TINYC__
        .int 0x35000061
        .int 0xf9400000
        .int 0xd65f03c0
        .int 0xc8dffc00
        .int 0xd65f03c0
#else
        cbnz    w1,  .L___atomic_load_8_00c
        ldr x0, [x0]
        ret
.L___atomic_load_8_00c:
        ldar    x0, [x0]
        ret
	.size   _(__atomic_load_8), .-_(__atomic_load_8)

#endif
        .global _(__atomic_store_1)
        .type   _(__atomic_store_1), %function
_(__atomic_store_1):
#ifdef __TINYC__
        .int 0x12001c21
        .int 0x35000062
        .int 0x39000001
        .int 0xd65f03c0
        .int 0x089ffc01
        .int 0xd65f03c0
#else
        and w1, w1, #0xff
        cbnz    w2,  .L___atomic_store_1_010
        strb    w1, [x0]
        ret
.L___atomic_store_1_010:
        stlrb   w1, [x0]
        ret
	.size   _(__atomic_store_1), .-_(__atomic_store_1)

#endif
        .global _(__atomic_store_2)
        .type   _(__atomic_store_2), %function
_(__atomic_store_2):
#ifdef __TINYC__
        .int 0x12003c21
        .int 0x35000062
        .int 0x79000001
        .int 0xd65f03c0
        .int 0x489ffc01
        .int 0xd65f03c0
#else
        and w1, w1, #0xffff
        cbnz    w2,  .L___atomic_store_2_010
        strh    w1, [x0]
        ret
.L___atomic_store_2_010:
        stlrh   w1, [x0]
        ret
	.size   _(__atomic_store_2), .-_(__atomic_store_2)

#endif
        .global _(__atomic_store_4)
        .type   _(__atomic_store_4), %function
_(__atomic_store_4):
#ifdef __TINYC__
        .int 0x35000062
        .int 0xb9000001
        .int 0xd65f03c0
        .int 0x889ffc01
        .int 0xd65f03c0
#else
        cbnz    w2,  .L___atomic_store_4_00c
        str w1, [x0]
        ret
.L___atomic_store_4_00c:
        stlr    w1, [x0]
        ret
	.size   _(__atomic_store_4), .-_(__atomic_store_4)

#endif
        .global _(__atomic_store_8)
        .type   _(__atomic_store_8), %function
_(__atomic_store_8):
#ifdef __TINYC__
        .int 0x35000062
        .int 0xf9000001
        .int 0xd65f03c0
        .int 0xc89ffc01
        .int 0xd65f03c0
#else
        cbnz    w2,  .L___atomic_store_8_00c
        str x1, [x0]
        ret
.L___atomic_store_8_00c:
        stlr    x1, [x0]
        ret
	.size   _(__atomic_store_8), .-_(__atomic_store_8)

#endif
        .global _(__atomic_compare_exchange_1)
        .type   _(__atomic_compare_exchange_1), %function
_(__atomic_compare_exchange_1):
#ifdef __TINYC__
        .int 0x12001c42
        .int 0x35000143
        .int 0x39400023
        .int 0x085f7c04
        .int 0x6b23009f
        .int 0x54000061
        .int 0x08057c02
        .int 0x35ffff85
        .int 0x1a9f17e0
        .int 0x54000141
        .int 0xd65f03c0
        .int 0x39400023
        .int 0x085ffc04
        .int 0x6b23009f
        .int 0x54000061
        .int 0x0805fc02
        .int 0x35ffff85
        .int 0x1a9f17e0
        .int 0x54ffff00
        .int 0x39000024
        .int 0xd65f03c0
#else
        and w2, w2, #0xff
        cbnz    w3,  .L___atomic_compare_exchange_1_02c
        ldrb    w3, [x1]
.L___atomic_compare_exchange_1_00c:
        ldxrb   w4, [x0]
        cmp w4, w3, uxtb
        b.ne     .L___atomic_compare_exchange_1_020
        stxrb   w5, w2, [x0]
        cbnz    w5,  .L___atomic_compare_exchange_1_00c
.L___atomic_compare_exchange_1_020:
        cset    w0, eq  // eq = none
        b.ne     .L___atomic_compare_exchange_1_04c
.L___atomic_compare_exchange_1_028:
        ret
.L___atomic_compare_exchange_1_02c:
        ldrb    w3, [x1]
.L___atomic_compare_exchange_1_030:
        ldaxrb  w4, [x0]
        cmp w4, w3, uxtb
        b.ne     .L___atomic_compare_exchange_1_044
        stlxrb  w5, w2, [x0]
        cbnz    w5,  .L___atomic_compare_exchange_1_030
.L___atomic_compare_exchange_1_044:
        cset    w0, eq  // eq = none
        b.eq     .L___atomic_compare_exchange_1_028
.L___atomic_compare_exchange_1_04c:
        strb    w4, [x1]
        ret
	.size   _(__atomic_compare_exchange_1), .-_(__atomic_compare_exchange_1)

#endif
        .global _(__atomic_compare_exchange_2)
        .type   _(__atomic_compare_exchange_2), %function
_(__atomic_compare_exchange_2):
#ifdef __TINYC__
        .int 0x12003c42
        .int 0x35000143
        .int 0x79400023
        .int 0x485f7c04
        .int 0x6b23209f
        .int 0x54000061
        .int 0x48057c02
        .int 0x35ffff85
        .int 0x1a9f17e0
        .int 0x54000141
        .int 0xd65f03c0
        .int 0x79400023
        .int 0x485ffc04
        .int 0x6b23209f
        .int 0x54000061
        .int 0x4805fc02
        .int 0x35ffff85
        .int 0x1a9f17e0
        .int 0x54ffff00
        .int 0x79000024
        .int 0xd65f03c0
#else
        and w2, w2, #0xffff
        cbnz    w3,  .L___atomic_compare_exchange_2_02c
        ldrh    w3, [x1]
.L___atomic_compare_exchange_2_00c:
        ldxrh   w4, [x0]
        cmp w4, w3, uxth
        b.ne     .L___atomic_compare_exchange_2_020
        stxrh   w5, w2, [x0]
        cbnz    w5,  .L___atomic_compare_exchange_2_00c
.L___atomic_compare_exchange_2_020:
        cset    w0, eq  // eq = none
        b.ne     .L___atomic_compare_exchange_2_04c
.L___atomic_compare_exchange_2_028:
        ret
.L___atomic_compare_exchange_2_02c:
        ldrh    w3, [x1]
.L___atomic_compare_exchange_2_030:
        ldaxrh  w4, [x0]
        cmp w4, w3, uxth
        b.ne     .L___atomic_compare_exchange_2_044
        stlxrh  w5, w2, [x0]
        cbnz    w5,  .L___atomic_compare_exchange_2_030
.L___atomic_compare_exchange_2_044:
        cset    w0, eq  // eq = none
        b.eq     .L___atomic_compare_exchange_2_028
.L___atomic_compare_exchange_2_04c:
        strh    w4, [x1]
        ret
	.size   _(__atomic_compare_exchange_2), .-_(__atomic_compare_exchange_2)

#endif
        .global _(__atomic_compare_exchange_4)
        .type   _(__atomic_compare_exchange_4), %function
_(__atomic_compare_exchange_4):
#ifdef __TINYC__
        .int 0x35000143
        .int 0xb9400023
        .int 0x885f7c04
        .int 0x6b03009f
        .int 0x54000061
        .int 0x88057c02
        .int 0x35ffff85
        .int 0x1a9f17e0
        .int 0x54000141
        .int 0xd65f03c0
        .int 0xb9400023
        .int 0x885ffc04
        .int 0x6b03009f
        .int 0x54000061
        .int 0x8805fc02
        .int 0x35ffff85
        .int 0x1a9f17e0
        .int 0x54ffff00
        .int 0xb9000024
        .int 0xd65f03c0
#else
        cbnz    w3,  .L___atomic_compare_exchange_4_028
        ldr w3, [x1]
.L___atomic_compare_exchange_4_008:
        ldxr    w4, [x0]
        cmp w4, w3
        b.ne     .L___atomic_compare_exchange_4_01c
        stxr    w5, w2, [x0]
        cbnz    w5,  .L___atomic_compare_exchange_4_008
.L___atomic_compare_exchange_4_01c:
        cset    w0, eq  // eq = none
        b.ne     .L___atomic_compare_exchange_4_048
.L___atomic_compare_exchange_4_024:
        ret
.L___atomic_compare_exchange_4_028:
        ldr w3, [x1]
.L___atomic_compare_exchange_4_02c:
        ldaxr   w4, [x0]
        cmp w4, w3
        b.ne     .L___atomic_compare_exchange_4_040
        stlxr   w5, w2, [x0]
        cbnz    w5,  .L___atomic_compare_exchange_4_02c
.L___atomic_compare_exchange_4_040:
        cset    w0, eq  // eq = none
        b.eq     .L___atomic_compare_exchange_4_024
.L___atomic_compare_exchange_4_048:
        str w4, [x1]
        ret
	.size   _(__atomic_compare_exchange_4), .-_(__atomic_compare_exchange_4)

#endif
        .global _(__atomic_compare_exchange_8)
        .type   _(__atomic_compare_exchange_8), %function
_(__atomic_compare_exchange_8):
#ifdef __TINYC__
        .int 0x35000143
        .int 0xf9400023
        .int 0xc85f7c04
        .int 0xeb03009f
        .int 0x54000061
        .int 0xc8057c02
        .int 0x35ffff85
        .int 0x1a9f17e0
        .int 0x54000141
        .int 0xd65f03c0
        .int 0xf9400023
        .int 0xc85ffc04
        .int 0xeb03009f
        .int 0x54000061
        .int 0xc805fc02
        .int 0x35ffff85
        .int 0x1a9f17e0
        .int 0x54ffff00
        .int 0xf9000024
        .int 0xd65f03c0
#else
        cbnz    w3,  .L___atomic_compare_exchange_8_028
        ldr x3, [x1]
.L___atomic_compare_exchange_8_008:
        ldxr    x4, [x0]
        cmp x4, x3
        b.ne     .L___atomic_compare_exchange_8_01c
        stxr    w5, x2, [x0]
        cbnz    w5,  .L___atomic_compare_exchange_8_008
.L___atomic_compare_exchange_8_01c:
        cset    w0, eq  // eq = none
        b.ne     .L___atomic_compare_exchange_8_048
.L___atomic_compare_exchange_8_024:
        ret
.L___atomic_compare_exchange_8_028:
        ldr x3, [x1]
.L___atomic_compare_exchange_8_02c:
        ldaxr   x4, [x0]
        cmp x4, x3
        b.ne     .L___atomic_compare_exchange_8_040
        stlxr   w5, x2, [x0]
        cbnz    w5,  .L___atomic_compare_exchange_8_02c
.L___atomic_compare_exchange_8_040:
        cset    w0, eq  // eq = none
        b.eq     .L___atomic_compare_exchange_8_024
.L___atomic_compare_exchange_8_048:
        str x4, [x1]
        ret
	.size   _(__atomic_compare_exchange_8), .-_(__atomic_compare_exchange_8)

#endif
        .global _(__atomic_test_and_set_1)
        .type   _(__atomic_test_and_set_1), %function
_(__atomic_test_and_set_1):
#ifdef __TINYC__
        .int 0x52800022
        .int 0x350000c1
        .int 0x085f7c01
        .int 0x08037c02
        .int 0x35ffffc3
        .int 0x12001c20
        .int 0xd65f03c0
        .int 0x085ffc01
        .int 0x0803fc02
        .int 0x35ffffc3
        .int 0x12001c20
        .int 0xd65f03c0
#else
        mov w2, #0x1                    // #1
        cbnz    w1,  .L___atomic_test_and_set_1_01c
.L___atomic_test_and_set_1_008:
        ldxrb   w1, [x0]
        stxrb   w3, w2, [x0]
        cbnz    w3,  .L___atomic_test_and_set_1_008
        and w0, w1, #0xff
        ret
.L___atomic_test_and_set_1_01c:
        ldaxrb  w1, [x0]
        stlxrb  w3, w2, [x0]
        cbnz    w3,  .L___atomic_test_and_set_1_01c
        and w0, w1, #0xff
        ret
	.size   _(__atomic_test_and_set_1), .-_(__atomic_test_and_set_1)

#endif
        .global _(__atomic_test_and_set_2)
        .type   _(__atomic_test_and_set_2), %function
_(__atomic_test_and_set_2):
#ifdef __TINYC__
        .int 0x52800022
        .int 0x350000c1
        .int 0x085f7c01
        .int 0x08037c02
        .int 0x35ffffc3
        .int 0x12001c20
        .int 0xd65f03c0
        .int 0x085ffc01
        .int 0x0803fc02
        .int 0x35ffffc3
        .int 0x12001c20
        .int 0xd65f03c0
#else
        mov w2, #0x1                    // #1
        cbnz    w1,  .L___atomic_test_and_set_2_01c
.L___atomic_test_and_set_2_008:
        ldxrb   w1, [x0]
        stxrb   w3, w2, [x0]
        cbnz    w3,  .L___atomic_test_and_set_2_008
        and w0, w1, #0xff
        ret
.L___atomic_test_and_set_2_01c:
        ldaxrb  w1, [x0]
        stlxrb  w3, w2, [x0]
        cbnz    w3,  .L___atomic_test_and_set_2_01c
        and w0, w1, #0xff
        ret
	.size   _(__atomic_test_and_set_2), .-_(__atomic_test_and_set_2)

#endif
        .global _(__atomic_test_and_set_4)
        .type   _(__atomic_test_and_set_4), %function
_(__atomic_test_and_set_4):
#ifdef __TINYC__
        .int 0x52800022
        .int 0x350000c1
        .int 0x085f7c01
        .int 0x08037c02
        .int 0x35ffffc3
        .int 0x12001c20
        .int 0xd65f03c0
        .int 0x085ffc01
        .int 0x0803fc02
        .int 0x35ffffc3
        .int 0x12001c20
        .int 0xd65f03c0
#else
        mov w2, #0x1                    // #1
        cbnz    w1,  .L___atomic_test_and_set_4_01c
.L___atomic_test_and_set_4_008:
        ldxrb   w1, [x0]
        stxrb   w3, w2, [x0]
        cbnz    w3,  .L___atomic_test_and_set_4_008
        and w0, w1, #0xff
        ret
.L___atomic_test_and_set_4_01c:
        ldaxrb  w1, [x0]
        stlxrb  w3, w2, [x0]
        cbnz    w3,  .L___atomic_test_and_set_4_01c
        and w0, w1, #0xff
        ret
	.size   _(__atomic_test_and_set_4), .-_(__atomic_test_and_set_4)

#endif
        .global _(__atomic_test_and_set_8)
        .type   _(__atomic_test_and_set_8), %function
_(__atomic_test_and_set_8):
#ifdef __TINYC__
        .int 0x52800022
        .int 0x350000c1
        .int 0x085f7c01
        .int 0x08037c02
        .int 0x35ffffc3
        .int 0x12001c20
        .int 0xd65f03c0
        .int 0x085ffc01
        .int 0x0803fc02
        .int 0x35ffffc3
        .int 0x12001c20
        .int 0xd65f03c0
#else
        mov w2, #0x1                    // #1
        cbnz    w1,  .L___atomic_test_and_set_8_01c
.L___atomic_test_and_set_8_008:
        ldxrb   w1, [x0]
        stxrb   w3, w2, [x0]
        cbnz    w3,  .L___atomic_test_and_set_8_008
        and w0, w1, #0xff
        ret
.L___atomic_test_and_set_8_01c:
        ldaxrb  w1, [x0]
        stlxrb  w3, w2, [x0]
        cbnz    w3,  .L___atomic_test_and_set_8_01c
        and w0, w1, #0xff
        ret
	.size   _(__atomic_test_and_set_8), .-_(__atomic_test_and_set_8)

#endif
        .global _(atomic_thread_fence)
        .type   _(atomic_thread_fence), %function
_(atomic_thread_fence):
#ifdef __TINYC__
        .int 0xd5033bbf
        .int 0xd65f03c0
#else
        dmb ish
        ret
	.size   _(atomic_thread_fence), .-_(atomic_thread_fence)

#endif
        .global _(atomic_signal_fence)
        .type   _(atomic_signal_fence), %function
_(atomic_signal_fence):
#ifdef __TINYC__
        .int 0xd65f03c0
#else
        ret
	.size   _(atomic_signal_fence), .-_(atomic_signal_fence)

#endif
        .global _(atomic_flag_test_and_set)
        .type   _(atomic_flag_test_and_set), %function
_(atomic_flag_test_and_set):
#ifdef __TINYC__
        .int 0xaa0003e1
        .int 0x52800022
        .int 0x085ffc20
        .int 0x0803fc22
        .int 0x35ffffc3
        .int 0xd65f03c0
#else
        mov x1, x0
        mov w2, #0x1                    // #1
.L_atomic_flag_test_and_set_008:
        ldaxrb  w0, [x1]
        stlxrb  w3, w2, [x1]
        cbnz    w3,  .L_atomic_flag_test_and_set_008
        ret
	.size   _(atomic_flag_test_and_set), .-_(atomic_flag_test_and_set)

#endif
        .global _(atomic_flag_test_and_set_explicit)
        .type   _(atomic_flag_test_and_set_explicit), %function
_(atomic_flag_test_and_set_explicit):
#ifdef __TINYC__
        .int 0xaa0003e1
        .int 0x52800022
        .int 0x085ffc20
        .int 0x0803fc22
        .int 0x35ffffc3
        .int 0xd65f03c0
#else
        mov x1, x0
        mov w2, #0x1                    // #1
.L_atomic_flag_test_and_set_explicit_020:
        ldaxrb  w0, [x1]
        stlxrb  w3, w2, [x1]
        cbnz    w3,  .L_atomic_flag_test_and_set_explicit_020
        ret
	.size   _(atomic_flag_test_and_set_explicit), .-_(atomic_flag_test_and_set_explicit)

#endif
        .global _(atomic_flag_clear)
        .type   _(atomic_flag_clear), %function
_(atomic_flag_clear):
#ifdef __TINYC__
        .int 0x089ffc1f
        .int 0xd65f03c0
#else
        stlrb   wzr, [x0]
        ret
	.size   _(atomic_flag_clear), .-_(atomic_flag_clear)

#endif
        .global _(atomic_flag_clear_explicit)
        .type   _(atomic_flag_clear_explicit), %function
_(atomic_flag_clear_explicit):
#ifdef __TINYC__
        .int 0x089ffc1f
        .int 0xd65f03c0
#else
        stlrb   wzr, [x0]
        ret
	.size   _(atomic_flag_clear_explicit), .-_(atomic_flag_clear_explicit)

#endif
#endif //__aarch64__

/* ---------------------------------------------- */
#if defined __riscv
        .text

        .global _(__atomic_load_1)
        .type   _(__atomic_load_1), %function
_(__atomic_load_1):
#ifdef __TINYC__
        .int 0x0330000f
        .int 0x00054503
        .int 0x0330000f
        .short 0x8082
#else
        fence   rw,rw
        lbu a0,0(a0)
        fence   rw,rw
        ret
	.size   _(__atomic_load_1), .-_(__atomic_load_1)

#endif
        .global _(__atomic_load_2)
        .type   _(__atomic_load_2), %function
_(__atomic_load_2):
#ifdef __TINYC__
        .int 0x0330000f
        .int 0x00055503
        .int 0x0330000f
        .short 0x8082
#else
        fence   rw,rw
        lhu a0,0(a0)
        fence   rw,rw
        ret
	.size   _(__atomic_load_2), .-_(__atomic_load_2)

#endif
        .global _(__atomic_load_4)
        .type   _(__atomic_load_4), %function
_(__atomic_load_4):
#ifdef __TINYC__
        .int 0x0330000f
        .short 0x4108
        .int 0x0230000f
        .short 0x2501
        .short 0x8082
#else
        fence   rw,rw
        lw  a0,0(a0)
        fence   r,rw
        sext.w  a0,a0
        ret
	.size   _(__atomic_load_4), .-_(__atomic_load_4)

#endif
        .global _(__atomic_load_8)
        .type   _(__atomic_load_8), %function
_(__atomic_load_8):
#ifdef __TINYC__
        .int 0x0330000f
        .short 0x6108
        .int 0x0230000f
        .short 0x8082
#else
        fence   rw,rw
        ld  a0,0(a0)
        fence   r,rw
        ret
	.size   _(__atomic_load_8), .-_(__atomic_load_8)

#endif
        .global _(__atomic_store_1)
        .type   _(__atomic_store_1), %function
_(__atomic_store_1):
#ifdef __TINYC__
        .int 0x0330000f
        .int 0x00b50023
        .int 0x0330000f
        .short 0x8082
#else
        fence   rw,rw
        sb  a1,0(a0)
        fence   rw,rw
        ret
	.size   _(__atomic_store_1), .-_(__atomic_store_1)

#endif
        .global _(__atomic_store_2)
        .type   _(__atomic_store_2), %function
_(__atomic_store_2):
#ifdef __TINYC__
        .int 0x0330000f
        .int 0x00b51023
        .int 0x0330000f
        .short 0x8082
#else
        fence   rw,rw
        sh  a1,0(a0)
        fence   rw,rw
        ret
	.size   _(__atomic_store_2), .-_(__atomic_store_2)

#endif
        .global _(__atomic_store_4)
        .type   _(__atomic_store_4), %function
_(__atomic_store_4):
#ifdef __TINYC__
        .int 0x0310000f
        .short 0xc10c
        .int 0x0330000f
        .short 0x8082
#else
        fence   rw,w
        sw  a1,0(a0)
        fence   rw,rw
        ret
	.size   _(__atomic_store_4), .-_(__atomic_store_4)

#endif
        .global _(__atomic_store_8)
        .type   _(__atomic_store_8), %function
_(__atomic_store_8):
#ifdef __TINYC__
        .int 0x0310000f
        .short 0xe10c
        .int 0x0330000f
        .short 0x8082
#else
        fence   rw,w
        sd  a1,0(a0)
        fence   rw,rw
        ret
	.size   _(__atomic_store_8), .-_(__atomic_store_8)

#endif
        .global _(__atomic_compare_exchange_1)
        .type   _(__atomic_compare_exchange_1), %function
_(__atomic_compare_exchange_1):
#ifdef __TINYC__
        .int 0x0005c683
        .int 0x00357793
        .int 0x0037979b
        .int 0x0ff00713
        .int 0x00f7173b
        .int 0x00f698bb
        .int 0x00f6163b
        .short 0x9971
        .int 0xfff74313
        .int 0x00e8f8b3
        .short 0x8e79
        .int 0x1605282f
        .int 0x00e87e33
        .int 0x011e1a63
        .int 0x00687e33
        .int 0x00ce6e33
        .int 0x1bc52e2f
        .int 0xfe0e14e3
        .int 0x40f8583b
        .int 0x0188179b
        .int 0x0186969b
        .int 0x4187d79b
        .int 0x4186d69b
        .short 0x9f95
        .int 0x0017b513
        .short 0xc399
        .int 0x01058023
        .short 0x8905
        .short 0x8082
#else
        lbu a3,0(a1)
        andi    a5,a0,3
        slliw   a5,a5,0x3
        li  a4,255
        sllw    a4,a4,a5
        sllw    a7,a3,a5
        sllw    a2,a2,a5
        andi    a0,a0,-4
        not t1,a4
        and a7,a7,a4
        and a2,a2,a4
.L___atomic_compare_exchange_1_028:
        lr.w.aqrl   a6,(a0)
        and t3,a6,a4
        bne t3,a7, .L___atomic_compare_exchange_1_044
        and t3,a6,t1
        or  t3,t3,a2
        sc.w.rl t3,t3,(a0)
        bnez    t3, .L___atomic_compare_exchange_1_028
.L___atomic_compare_exchange_1_044:
        sraw    a6,a6,a5
        slliw   a5,a6,0x18
        slliw   a3,a3,0x18
        sraiw   a5,a5,0x18
        sraiw   a3,a3,0x18
        subw    a5,a5,a3
        seqz    a0,a5
        beqz    a5, .L___atomic_compare_exchange_1_064
        sb  a6,0(a1)
.L___atomic_compare_exchange_1_064:
        andi    a0,a0,1
        ret
	.size   _(__atomic_compare_exchange_1), .-_(__atomic_compare_exchange_1)

#endif
        .global _(__atomic_compare_exchange_2)
        .type   _(__atomic_compare_exchange_2), %function
_(__atomic_compare_exchange_2):
#ifdef __TINYC__
        .int 0x0005d683
        .int 0x00357713
        .short 0x67c1
        .int 0x0037171b
        .short 0x37fd
        .int 0x00e797bb
        .int 0x00e698bb
        .int 0x00e6163b
        .short 0x9971
        .int 0xfff7c313
        .int 0x00f8f8b3
        .short 0x8e7d
        .int 0x1605282f
        .int 0x00f87e33
        .int 0x011e1a63
        .int 0x00687e33
        .int 0x00ce6e33
        .int 0x1bc52e2f
        .int 0xfe0e14e3
        .int 0x40e8583b
        .int 0x0108179b
        .int 0x0106969b
        .int 0x4107d79b
        .int 0x4106d69b
        .short 0x9f95
        .int 0x0017b513
        .short 0xc399
        .int 0x01059023
        .short 0x8905
        .short 0x8082
#else
        lhu a3,0(a1)
        andi    a4,a0,3
        lui a5,0x10
        slliw   a4,a4,0x3
        addiw   a5,a5,-1 # ffff <.LASF16+0xfec8>
        sllw    a5,a5,a4
        sllw    a7,a3,a4
        sllw    a2,a2,a4
        andi    a0,a0,-4
        not t1,a5
        and a7,a7,a5
        and a2,a2,a5
.L___atomic_compare_exchange_2_028:
        lr.w.aqrl   a6,(a0)
        and t3,a6,a5
        bne t3,a7, .L___atomic_compare_exchange_2_044
        and t3,a6,t1
        or  t3,t3,a2
        sc.w.rl t3,t3,(a0)
        bnez    t3, .L___atomic_compare_exchange_2_028
.L___atomic_compare_exchange_2_044:
        sraw    a6,a6,a4
        slliw   a5,a6,0x10
        slliw   a3,a3,0x10
        sraiw   a5,a5,0x10
        sraiw   a3,a3,0x10
        subw    a5,a5,a3
        seqz    a0,a5
        beqz    a5, .L___atomic_compare_exchange_2_064
        sh  a6,0(a1)
.L___atomic_compare_exchange_2_064:
        andi    a0,a0,1
        ret
	.size   _(__atomic_compare_exchange_2), .-_(__atomic_compare_exchange_2)

#endif
        .global _(__atomic_compare_exchange_4)
        .type   _(__atomic_compare_exchange_4), %function
_(__atomic_compare_exchange_4):
#ifdef __TINYC__
        .short 0x419c
        .int 0x1605272f
        .int 0x00f71563
        .int 0x1ac526af
        .short 0xfaf5
        .int 0x40f707bb
        .int 0x0017b513
        .short 0xc391
        .short 0xc198
        .short 0x8905
        .short 0x8082
#else
        lw  a5,0(a1)
.L___atomic_compare_exchange_4_002:
        lr.w.aqrl   a4,(a0)
        bne a4,a5, .L___atomic_compare_exchange_4_010
        sc.w.rl a3,a2,(a0)
        bnez    a3, .L___atomic_compare_exchange_4_002
.L___atomic_compare_exchange_4_010:
        subw    a5,a4,a5
        seqz    a0,a5
        beqz    a5, .L___atomic_compare_exchange_4_01c
        sw  a4,0(a1)
.L___atomic_compare_exchange_4_01c:
        andi    a0,a0,1
        ret
	.size   _(__atomic_compare_exchange_4), .-_(__atomic_compare_exchange_4)

#endif
        .global _(__atomic_compare_exchange_8)
        .type   _(__atomic_compare_exchange_8), %function
_(__atomic_compare_exchange_8):
#ifdef __TINYC__
        .short 0x619c
        .int 0x1605372f
        .int 0x00f71563
        .int 0x1ac536af
        .short 0xfaf5
        .int 0x40f707b3
        .int 0x0017b513
        .short 0xc391
        .short 0xe198
        .short 0x8905
        .short 0x8082
#else
        ld  a5,0(a1)
.L___atomic_compare_exchange_8_002:
        lr.d.aqrl   a4,(a0)
        bne a4,a5, .L___atomic_compare_exchange_8_010
        sc.d.rl a3,a2,(a0)
        bnez    a3, .L___atomic_compare_exchange_8_002
.L___atomic_compare_exchange_8_010:
        sub a5,a4,a5
        seqz    a0,a5
        beqz    a5, .L___atomic_compare_exchange_8_01c
        sd  a4,0(a1)
.L___atomic_compare_exchange_8_01c:
        andi    a0,a0,1
        ret
	.size   _(__atomic_compare_exchange_8), .-_(__atomic_compare_exchange_8)

#endif
        .global _(__atomic_test_and_set_1)
        .type   _(__atomic_test_and_set_1), %function
_(__atomic_test_and_set_1):
#ifdef __TINYC__
        .int 0x00357793
        .int 0x0037979b
        .short 0x4685
        .short 0x9971
        .int 0x00f696bb
        .int 0x46d5272f
        .int 0x00f7553b
        .int 0x0ff57513
        .short 0x8082
#else
        andi    a5,a0,3
        slliw   a5,a5,0x3
        li  a3,1
        andi    a0,a0,-4
        sllw    a3,a3,a5
        amoor.w.aqrl    a4,a3,(a0)
        srlw    a0,a4,a5
        zext.b  a0,a0
        ret
	.size   _(__atomic_test_and_set_1), .-_(__atomic_test_and_set_1)

#endif
        .global _(__atomic_test_and_set_2)
        .type   _(__atomic_test_and_set_2), %function
_(__atomic_test_and_set_2):
#ifdef __TINYC__
        .int 0x00357793
        .int 0x0037979b
        .short 0x4685
        .short 0x9971
        .int 0x00f696bb
        .int 0x46d5272f
        .int 0x00f7553b
        .int 0x0ff57513
        .short 0x8082
#else
        andi    a5,a0,3
        slliw   a5,a5,0x3
        li  a3,1
        andi    a0,a0,-4
        sllw    a3,a3,a5
        amoor.w.aqrl    a4,a3,(a0)
        srlw    a0,a4,a5
        zext.b  a0,a0
        ret
	.size   _(__atomic_test_and_set_2), .-_(__atomic_test_and_set_2)

#endif
        .global _(__atomic_test_and_set_4)
        .type   _(__atomic_test_and_set_4), %function
_(__atomic_test_and_set_4):
#ifdef __TINYC__
        .int 0x00357793
        .int 0x0037979b
        .short 0x4685
        .short 0x9971
        .int 0x00f696bb
        .int 0x46d5272f
        .int 0x00f7553b
        .int 0x0ff57513
        .short 0x8082
#else
        andi    a5,a0,3
        slliw   a5,a5,0x3
        li  a3,1
        andi    a0,a0,-4
        sllw    a3,a3,a5
        amoor.w.aqrl    a4,a3,(a0)
        srlw    a0,a4,a5
        zext.b  a0,a0
        ret
	.size   _(__atomic_test_and_set_4), .-_(__atomic_test_and_set_4)

#endif
        .global _(__atomic_test_and_set_8)
        .type   _(__atomic_test_and_set_8), %function
_(__atomic_test_and_set_8):
#ifdef __TINYC__
        .int 0x00357793
        .int 0x0037979b
        .short 0x4685
        .short 0x9971
        .int 0x00f696bb
        .int 0x46d5272f
        .int 0x00f7553b
        .int 0x0ff57513
        .short 0x8082
#else
        andi    a5,a0,3
        slliw   a5,a5,0x3
        li  a3,1
        andi    a0,a0,-4
        sllw    a3,a3,a5
        amoor.w.aqrl    a4,a3,(a0)
        srlw    a0,a4,a5
        zext.b  a0,a0
        ret
	.size   _(__atomic_test_and_set_8), .-_(__atomic_test_and_set_8)

#endif
        .global _(atomic_thread_fence)
        .type   _(atomic_thread_fence), %function
_(atomic_thread_fence):
#ifdef __TINYC__
        .int 0x0330000f
        .short 0x8082
#else
        fence   rw,rw
        ret
	.size   _(atomic_thread_fence), .-_(atomic_thread_fence)

#endif
        .global _(atomic_signal_fence)
        .type   _(atomic_signal_fence), %function
_(atomic_signal_fence):
#ifdef __TINYC__
        .short 0x8082
#else
        ret
	.size   _(atomic_signal_fence), .-_(atomic_signal_fence)

#endif
        .global _(atomic_flag_test_and_set)
        .type   _(atomic_flag_test_and_set), %function
_(atomic_flag_test_and_set):
#ifdef __TINYC__
        .int 0x00357793
        .int 0x0037979b
        .short 0x4685
        .short 0x9971
        .int 0x00f696bb
        .int 0x46d5272f
        .int 0x00f7553b
        .int 0x0ff57513
        .short 0x8082
#else
        andi    a5,a0,3
        slliw   a5,a5,0x3
        li  a3,1
        andi    a0,a0,-4
        sllw    a3,a3,a5
        amoor.w.aqrl    a4,a3,(a0)
        srlw    a0,a4,a5
        zext.b  a0,a0
        ret
	.size   _(atomic_flag_test_and_set), .-_(atomic_flag_test_and_set)

#endif
        .global _(atomic_flag_test_and_set_explicit)
        .type   _(atomic_flag_test_and_set_explicit), %function
_(atomic_flag_test_and_set_explicit):
#ifdef __TINYC__
        .int 0x00357793
        .int 0x0037979b
        .short 0x4685
        .short 0x9971
        .int 0x00f696bb
        .int 0x46d5272f
        .int 0x00f7553b
        .int 0x0ff57513
        .short 0x8082
#else
        andi    a5,a0,3
        slliw   a5,a5,0x3
        li  a3,1
        andi    a0,a0,-4
        sllw    a3,a3,a5
        amoor.w.aqrl    a4,a3,(a0)
        srlw    a0,a4,a5
        zext.b  a0,a0
        ret
	.size   _(atomic_flag_test_and_set_explicit), .-_(atomic_flag_test_and_set_explicit)

#endif
        .global _(atomic_flag_clear)
        .type   _(atomic_flag_clear), %function
_(atomic_flag_clear):
#ifdef __TINYC__
        .int 0x0330000f
        .int 0x00050023
        .int 0x0330000f
        .short 0x8082
#else
        fence   rw,rw
        sb  zero,0(a0)
        fence   rw,rw
        ret
	.size   _(atomic_flag_clear), .-_(atomic_flag_clear)

#endif
        .global _(atomic_flag_clear_explicit)
        .type   _(atomic_flag_clear_explicit), %function
_(atomic_flag_clear_explicit):
#ifdef __TINYC__
        .int 0x0330000f
        .int 0x00050023
        .int 0x0330000f
        .short 0x8082
#else
        fence   rw,rw
        sb  zero,0(a0)
        fence   rw,rw
        ret
	.size   _(atomic_flag_clear_explicit), .-_(atomic_flag_clear_explicit)

#endif
#endif //__riscv
/*
 *  Tiny C Memory and bounds checker
 * 
 *  Copyright (c) 2002 Fabrice Bellard
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <setjmp.h>
#include <stdatomic.h>

#if !defined(__FreeBSD__) \
 && !defined(__FreeBSD_kernel__) \
 && !defined(__DragonFly__) \
 && !defined(__OpenBSD__) \
 && !defined(__APPLE__) \
 && !defined(__NetBSD__)
#include <malloc.h>
#endif

#if !defined(_WIN32)
#include <unistd.h>
#include <sys/syscall.h>
#endif

#include "config.h"

#define BOUND_DEBUG             (1)
#define BOUND_STATISTIC         (1)

#if BOUND_DEBUG
 #define dprintf(a...)         if (print_calls) { bounds_loc(a); }
#else
 #define dprintf(a...)
#endif

#ifdef __attribute__
  /* an __attribute__ macro is defined in the system headers */
  #undef __attribute__ 
#endif
#define FASTCALL __attribute__((regparm(3)))

#ifdef _WIN32
# define DLL_EXPORT __declspec(dllexport)
#else
# define DLL_EXPORT
#endif

#if defined(__FreeBSD__) \
 || defined(__FreeBSD_kernel__) \
 || defined(__DragonFly__) \
 || defined(__OpenBSD__) \
 || defined(__NetBSD__) \
 || defined(__dietlibc__)

#include <sys/mman.h>
#define INIT_SEM()
#define EXIT_SEM()
#define WAIT_SEM()
#define POST_SEM()
#define TRY_SEM()
#define HAVE_MEMALIGN          (0)
#define MALLOC_REDIR           (0)
#define HAVE_PTHREAD_CREATE    (0)
#define HAVE_CTYPE             (0)
#define HAVE_ERRNO             (0)
#define HAVE_SIGNAL            (0)
#define HAVE_SIGACTION         (0)
#define HAVE_FORK              (0)
#define HAVE_TLS_FUNC          (0)
#define HAVE_TLS_VAR           (0)

#elif defined(_WIN32)

#include <windows.h>
#include <signal.h>
static CRITICAL_SECTION bounds_sem;
#define INIT_SEM()             InitializeCriticalSection(&bounds_sem)
#define EXIT_SEM()             DeleteCriticalSection(&bounds_sem)
#define WAIT_SEM()             EnterCriticalSection(&bounds_sem)
#define POST_SEM()             LeaveCriticalSection(&bounds_sem)
#define TRY_SEM()              TryEnterCriticalSection(&bounds_sem)
#define HAVE_MEMALIGN          (0)
#define MALLOC_REDIR           (0)
#define HAVE_PTHREAD_CREATE    (0)
#define HAVE_CTYPE             (0)
#define HAVE_ERRNO             (0)
#define HAVE_SIGNAL            (1)
#define HAVE_SIGACTION         (0)
#define HAVE_FORK              (0)
#define HAVE_TLS_FUNC          (1)
#define HAVE_TLS_VAR           (0)

#else

#define __USE_GNU              /* get RTLD_NEXT */
#include <sys/mman.h>
#include <ctype.h>
#include <pthread.h>
#include <dlfcn.h>
#include <errno.h>
#include <signal.h>
#ifdef __APPLE__
#include <dispatch/dispatch.h>
static dispatch_semaphore_t bounds_sem;
#define INIT_SEM()             bounds_sem = dispatch_semaphore_create(1)
#define EXIT_SEM()             dispatch_release(*(dispatch_object_t*)&bounds_sem)
#define WAIT_SEM()             if (use_sem) dispatch_semaphore_wait(bounds_sem, DISPATCH_TIME_FOREVER)
#define POST_SEM()             if (use_sem) dispatch_semaphore_signal(bounds_sem)
#define TRY_SEM()              if (use_sem) dispatch_semaphore_wait(bounds_sem, DISPATCH_TIME_NOW)
#elif 0
#include <semaphore.h>
static sem_t bounds_sem;
#define INIT_SEM()             sem_init (&bounds_sem, 0, 1)
#define EXIT_SEM()             sem_destroy (&bounds_sem)
#define WAIT_SEM()             if (use_sem) while (sem_wait (&bounds_sem) < 0 \
                                                   && errno == EINTR)
#define POST_SEM()             if (use_sem) sem_post (&bounds_sem)
#define TRY_SEM()              if (use_sem) while (sem_trywait (&bounds_sem) < 0 \
                                                   && errno == EINTR)
#elif 0
static pthread_mutex_t bounds_mtx;
#define INIT_SEM()             pthread_mutex_init (&bounds_mtx, NULL)
#define EXIT_SEM()             pthread_mutex_destroy (&bounds_mtx)
#define WAIT_SEM()             if (use_sem) pthread_mutex_lock (&bounds_mtx)
#define POST_SEM()             if (use_sem) pthread_mutex_unlock (&bounds_mtx)
#define TRY_SEM()              if (use_sem) pthread_mutex_trylock (&bounds_mtx)
#else
static pthread_spinlock_t bounds_spin;
/* about 25% faster then semaphore. */
#define INIT_SEM()             pthread_spin_init (&bounds_spin, 0)
#define EXIT_SEM()             pthread_spin_destroy (&bounds_spin)
#define WAIT_SEM()             if (use_sem) pthread_spin_lock (&bounds_spin)
#define POST_SEM()             if (use_sem) pthread_spin_unlock (&bounds_spin)
#define TRY_SEM()              if (use_sem) pthread_spin_trylock (&bounds_spin)
#endif
#define HAVE_MEMALIGN          (1)
#define MALLOC_REDIR           (1)
#define HAVE_PTHREAD_CREATE    (1)
#define HAVE_CTYPE             (1)
#define HAVE_ERRNO             (1)
#define HAVE_SIGNAL            (1)
#define HAVE_SIGACTION         (1)
#define HAVE_FORK              (1)
#if !defined(__APPLE__) && defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
#define HAVE_TLS_FUNC          (0)
#define HAVE_TLS_VAR           (1)
#else
#define HAVE_TLS_FUNC          (1)
#define HAVE_TLS_VAR           (0)
#endif
#if defined CONFIG_TCC_MUSL || defined __ANDROID__
# undef HAVE_CTYPE
#endif
#endif

#if MALLOC_REDIR
static void *(*malloc_redir) (size_t);
static void *(*calloc_redir) (size_t, size_t);
static void (*free_redir) (void *);
static void *(*realloc_redir) (void *, size_t);
static unsigned int pool_index;
static unsigned char __attribute__((aligned(16))) initial_pool[256];
#endif
#if HAVE_MEMALIGN
static void *(*memalign_redir) (size_t, size_t);
#endif
#if HAVE_PTHREAD_CREATE
static int (*pthread_create_redir) (pthread_t *thread,
                                    const pthread_attr_t *attr,
                                    void *(*start_routine)(void *), void *arg);
#endif
#if HAVE_SIGNAL
typedef void (*bound_sig)(int);
static bound_sig (*signal_redir) (int signum, bound_sig handler);
#endif
#if HAVE_SIGACTION
static int (*sigaction_redir) (int signum, const struct sigaction *act,
                               struct sigaction *oldact);
#endif
#if HAVE_FORK
static int (*fork_redir) (void);
#endif

#define TCC_TYPE_NONE           (0)
#define TCC_TYPE_MALLOC         (1)
#define TCC_TYPE_CALLOC         (2)
#define TCC_TYPE_REALLOC        (3)
#define TCC_TYPE_MEMALIGN       (4)
#define TCC_TYPE_STRDUP         (5)

/* this pointer is generated when bound check is incorrect */
#define INVALID_POINTER ((void *)(-2))

typedef struct tree_node Tree;
struct tree_node {
    Tree * left, * right;
    size_t start;
    size_t size;
    unsigned char type;
    unsigned char is_invalid; /* true if pointers outside region are invalid */
};

typedef struct alloca_list_struct {
    size_t fp;
    void *p;
    size_t size;
    struct alloca_list_struct *next;
} alloca_list_type;

#if defined(_WIN32)
#define BOUND_TID_TYPE		DWORD
#define BOUND_GET_TID(id)	id = GetCurrentThreadId()
#elif defined(__OpenBSD__)
#define BOUND_TID_TYPE		pid_t
#define BOUND_GET_TID(id)	id = getthrid()
#elif defined(__FreeBSD__)
#define BOUND_TID_TYPE		pid_t
#define BOUND_GET_TID(id)	syscall (SYS_thr_self, &id)
#elif  defined(__NetBSD__)
#define BOUND_TID_TYPE		pid_t
#define BOUND_GET_TID(id)	id = syscall (SYS__lwp_self)
#elif defined(__linux__)
#define BOUND_TID_TYPE		pid_t
#define BOUND_GET_TID(id)	id = syscall (SYS_gettid)
#else
#define BOUND_TID_TYPE		int
#define BOUND_GET_TID(id)	id = 0
#endif

typedef struct jmp_list_struct {
    void *penv;
    size_t fp;
    size_t end_fp;
    BOUND_TID_TYPE tid;
    struct jmp_list_struct *next;
} jmp_list_type;

#define BOUND_STATISTIC_SPLAY   (0)
static Tree * splay (size_t addr, Tree *t);
static Tree * splay_end (size_t addr, Tree *t);
static Tree * splay_insert(size_t addr, size_t size, Tree * t);
static Tree * splay_delete(size_t addr, Tree *t);
void splay_printtree(Tree * t, int d);

/* external interface */
void __bounds_checking (int no_check);
void __bound_checking_lock (void);
void __bound_checking_unlock (void);
void __bound_never_fatal (int no_check);
DLL_EXPORT void * __bound_ptr_add(void *p, size_t offset);
DLL_EXPORT void * __bound_ptr_indir1(void *p, size_t offset);
DLL_EXPORT void * __bound_ptr_indir2(void *p, size_t offset);
DLL_EXPORT void * __bound_ptr_indir4(void *p, size_t offset);
DLL_EXPORT void * __bound_ptr_indir8(void *p, size_t offset);
DLL_EXPORT void * __bound_ptr_indir12(void *p, size_t offset);
DLL_EXPORT void * __bound_ptr_indir16(void *p, size_t offset);
DLL_EXPORT void FASTCALL __bound_local_new(void *p1);
DLL_EXPORT void FASTCALL __bound_local_delete(void *p1);
void __bound_init(size_t *, int);
void __bound_main_arg(int argc, char **argv, char **envp);
void __bound_exit(void);
void __bound_exit_dll(size_t *);
#if !defined(_WIN32)
void *__bound_mmap (void *start, size_t size, int prot, int flags, int fd,
                    off_t offset);
int __bound_munmap (void *start, size_t size);
DLL_EXPORT void __bound_siglongjmp(jmp_buf env, int val);
#endif
DLL_EXPORT void __bound_new_region(void *p, size_t size);
DLL_EXPORT void __bound_setjmp(jmp_buf env);
DLL_EXPORT void __bound_longjmp(jmp_buf env, int val);
DLL_EXPORT void *__bound_memcpy(void *dst, const void *src, size_t size);
DLL_EXPORT int __bound_memcmp(const void *s1, const void *s2, size_t size);
DLL_EXPORT void *__bound_memmove(void *dst, const void *src, size_t size);
DLL_EXPORT void *__bound_memset(void *dst, int c, size_t size);
DLL_EXPORT int __bound_strlen(const char *s);
DLL_EXPORT char *__bound_strcpy(char *dst, const char *src);
DLL_EXPORT char *__bound_strncpy(char *dst, const char *src, size_t n);
DLL_EXPORT int __bound_strcmp(const char *s1, const char *s2);
DLL_EXPORT int __bound_strncmp(const char *s1, const char *s2, size_t n);
DLL_EXPORT char *__bound_strcat(char *dest, const char *src);
DLL_EXPORT char *__bound_strncat(char *dest, const char *src, size_t n);
DLL_EXPORT char *__bound_strchr(const char *string, int ch);
DLL_EXPORT char *__bound_strrchr(const char *string, int ch);
DLL_EXPORT char *__bound_strdup(const char *s);

#if defined(__arm__) && defined(__ARM_EABI__)
DLL_EXPORT void *__bound___aeabi_memcpy(void *dst, const void *src, size_t size);
DLL_EXPORT void *__bound___aeabi_memmove(void *dst, const void *src, size_t size);
DLL_EXPORT void *__bound___aeabi_memmove4(void *dst, const void *src, size_t size);
DLL_EXPORT void *__bound___aeabi_memmove8(void *dst, const void *src, size_t size);
DLL_EXPORT void *__bound___aeabi_memset(void *dst, int c, size_t size);
DLL_EXPORT void *__aeabi_memcpy(void *dst, const void *src, size_t size);
DLL_EXPORT void *__aeabi_memmove(void *dst, const void *src, size_t size);
DLL_EXPORT void *__aeabi_memmove4(void *dst, const void *src, size_t size);
DLL_EXPORT void *__aeabi_memmove8(void *dst, const void *src, size_t size);
DLL_EXPORT void *__aeabi_memset(void *dst, int c, size_t size);
#endif

#if MALLOC_REDIR
#define BOUND_MALLOC(a)          malloc_redir(a)
#define BOUND_MEMALIGN(a,b)      memalign_redir(a,b)
#define BOUND_FREE(a)            free_redir(a)
#define BOUND_REALLOC(a,b)       realloc_redir(a,b)
#define BOUND_CALLOC(a,b)        calloc_redir(a,b)
#else
#define BOUND_MALLOC(a)          malloc(a)
#define BOUND_MEMALIGN(a,b)      memalign(a,b)
#define BOUND_FREE(a)            free(a)
#define BOUND_REALLOC(a,b)       realloc(a,b)
#define BOUND_CALLOC(a,b)        calloc(a,b)
DLL_EXPORT void *__bound_malloc(size_t size, const void *caller);
DLL_EXPORT void *__bound_memalign(size_t align, size_t size, const void *caller);
DLL_EXPORT void __bound_free(void *ptr, const void *caller);
DLL_EXPORT void *__bound_realloc(void *ptr, size_t size, const void *caller);
DLL_EXPORT void *__bound_calloc(size_t nmemb, size_t size);
#endif

#define FREE_REUSE_SIZE (100)
static unsigned int free_reuse_index;
static void *free_reuse_list[FREE_REUSE_SIZE];

static Tree *tree = NULL;
#define TREE_REUSE      (1)
#if TREE_REUSE
static Tree *tree_free_list;
#endif
static alloca_list_type *alloca_list;
static jmp_list_type *jmp_list;

static unsigned char inited;
static unsigned char print_warn_ptr_add;
static unsigned char print_calls;
static unsigned char print_heap;
static unsigned char print_statistic;
static unsigned char no_strdup;
static unsigned char use_sem;
static int never_fatal;
#if HAVE_TLS_FUNC
#if defined(_WIN32)
static int no_checking = 0;
static DWORD no_checking_key;
#define NO_CHECKING_CHECK() if (!p) {                                         \
                                  p = (int *) LocalAlloc(LPTR, sizeof(int));  \
                                  if (!p) bound_alloc_error("tls malloc");    \
                                  *p = 0;                                     \
                                  TlsSetValue(no_checking_key, p);            \
                            }
#define NO_CHECKING_GET()   ({ int *p = TlsGetValue(no_checking_key);         \
                               NO_CHECKING_CHECK();                           \
                               *p;                                            \
                            })
#define NO_CHECKING_SET(v)  { int *p = TlsGetValue(no_checking_key);          \
                              NO_CHECKING_CHECK();                            \
                              *p = v;                                         \
                            }
#else
static int no_checking = 0;
static pthread_key_t no_checking_key;
#define NO_CHECKING_CHECK() if (!p) {                                         \
                                  p = (int *) BOUND_MALLOC(sizeof(int));      \
                                  if (!p) bound_alloc_error("tls malloc");    \
                                  *p = 0;                                     \
                                  pthread_setspecific(no_checking_key, p);    \
                            }
#define NO_CHECKING_GET()   ({ int *p = pthread_getspecific(no_checking_key); \
                               NO_CHECKING_CHECK();                           \
                               *p;                                            \
                            })
#define NO_CHECKING_SET(v)  { int *p = pthread_getspecific(no_checking_key);  \
                              NO_CHECKING_CHECK();                            \
                              *p = v;                                         \
                            }
#endif
#elif HAVE_TLS_VAR
static __thread int no_checking = 0;
#define NO_CHECKING_GET()  no_checking
#define NO_CHECKING_SET(v) no_checking = v 
#else
static int no_checking = 0;
#define NO_CHECKING_GET()  no_checking
#define NO_CHECKING_SET(v) no_checking = v 
#endif
static char exec[100];

#if BOUND_STATISTIC
static unsigned long long bound_ptr_add_count;
static unsigned long long bound_ptr_indir1_count;
static unsigned long long bound_ptr_indir2_count;
static unsigned long long bound_ptr_indir4_count;
static unsigned long long bound_ptr_indir8_count;
static unsigned long long bound_ptr_indir12_count;
static unsigned long long bound_ptr_indir16_count;
static unsigned long long bound_local_new_count;
static unsigned long long bound_local_delete_count;
static unsigned long long bound_malloc_count;
static unsigned long long bound_calloc_count;
static unsigned long long bound_realloc_count;
static unsigned long long bound_free_count;
static unsigned long long bound_memalign_count;
static unsigned long long bound_mmap_count;
static unsigned long long bound_munmap_count;
static unsigned long long bound_alloca_count;
static unsigned long long bound_setjmp_count;
static unsigned long long bound_longjmp_count;
static unsigned long long bound_mempcy_count;
static unsigned long long bound_memcmp_count;
static unsigned long long bound_memmove_count;
static unsigned long long bound_memset_count;
static unsigned long long bound_strlen_count;
static unsigned long long bound_strcpy_count;
static unsigned long long bound_strncpy_count;
static unsigned long long bound_strcmp_count;
static unsigned long long bound_strncmp_count;
static unsigned long long bound_strcat_count;
static unsigned long long bound_strncat_count;
static unsigned long long bound_strchr_count;
static unsigned long long bound_strrchr_count;
static unsigned long long bound_strdup_count;
static unsigned long long bound_not_found;
#define INCR_COUNT(x)          ++x
#else
#define INCR_COUNT(x)
#endif
#if BOUND_STATISTIC_SPLAY
static unsigned long long bound_splay;
static unsigned long long bound_splay_end;
static unsigned long long bound_splay_insert;
static unsigned long long bound_splay_delete;
#define INCR_COUNT_SPLAY(x)    ++x
#else
#define INCR_COUNT_SPLAY(x)
#endif

int tcc_backtrace(const char *fmt, ...);

/* print a bound error message */
#define bound_warning(...) \
    do {                                                 \
        WAIT_SEM ();                                     \
        tcc_backtrace("^bcheck.c^BCHECK: " __VA_ARGS__); \
        POST_SEM ();                                     \
    } while (0)

#define bound_error(...)            \
    do {                            \
        bound_warning(__VA_ARGS__); \
        if (never_fatal == 0)       \
            exit(255);              \
    } while (0)

#define bounds_loc(fp, ...) \
    do {                            \
        WAIT_SEM (); \
        tcc_backtrace("^bcheck.c^\001" __VA_ARGS__); \
        POST_SEM (); \
    } while (0)

static void bound_alloc_error(const char *s)
{
    fprintf(stderr,"FATAL: %s\n",s);
    exit (1);
}

static void bound_not_found_warning(const char *file, const char *function,
                                    void *ptr)
{
    dprintf(stderr, "%s%s, %s(): Not found %p\n", exec, file, function, ptr);
}

/* enable/disable checking. This can be used in signal handlers. */
void __bounds_checking (int no_check)
{
#if HAVE_TLS_FUNC || HAVE_TLS_VAR
    NO_CHECKING_SET(NO_CHECKING_GET() + no_check);
#else
    atomic_fetch_add (&no_checking, no_check);
#endif
}

void __bound_checking_lock(void)
{
    WAIT_SEM ();
}

void __bound_checking_unlock(void)
{
    POST_SEM ();
}

/* enable/disable checking. This can be used in signal handlers. */
void __bound_never_fatal (int neverfatal)
{
    atomic_fetch_add (&never_fatal, neverfatal);
}

/* return '(p + offset)' for pointer arithmetic (a pointer can reach
   the end of a region in this case */
void * __bound_ptr_add(void *p, size_t offset)
{
    size_t addr = (size_t)p;

    if (NO_CHECKING_GET())
        return p + offset;

    dprintf(stderr, "%s, %s(): %p 0x%lx\n",
            __FILE__, __FUNCTION__, p, (unsigned long)offset);

    WAIT_SEM ();
    INCR_COUNT(bound_ptr_add_count);
    if (tree) {
        addr -= tree->start;
        if (addr >= tree->size) {
            addr = (size_t)p;
            tree = splay (addr, tree);
            addr -= tree->start;
        }
        if (addr >= tree->size) {
            addr = (size_t)p;
            tree = splay_end (addr, tree);
            addr -= tree->start;
        }
        if (addr <= tree->size) {
            if (tree->is_invalid || addr + offset > tree->size) {
                POST_SEM ();
                if (print_warn_ptr_add)
                    bound_warning("%p is outside of the region (0x%lx..0x%lx)",
                                  p + offset, (long)tree->start,
                                  (long)(tree->start + tree->size - 1));
                if (never_fatal <= 0)
                    return INVALID_POINTER; /* return an invalid pointer */
                return p + offset;
            }
        }
        else if (p) { /* Allow NULL + offset. offsetoff is using it. */
            INCR_COUNT(bound_not_found);
            POST_SEM ();
            bound_not_found_warning (__FILE__, __FUNCTION__, p);
            return p + offset;
        }
    }
    POST_SEM ();
    return p + offset;
}

/* return '(p + offset)' for pointer indirection (the resulting must
   be strictly inside the region */
#define BOUND_PTR_INDIR(dsize)                                                 \
void * __bound_ptr_indir ## dsize (void *p, size_t offset)                     \
{                                                                              \
    size_t addr = (size_t)p;                                                   \
                                                                               \
    if (NO_CHECKING_GET())                                                     \
        return p + offset;                                                     \
                                                                               \
    dprintf(stderr, "%s, %s(): %p 0x%lx\n",                                    \
            __FILE__, __FUNCTION__, p, (unsigned long)offset);                 \
    WAIT_SEM ();                                                               \
    INCR_COUNT(bound_ptr_indir ## dsize ## _count);                            \
    if (tree) {                                                                \
        addr -= tree->start;                                                   \
        if (addr >= tree->size) {                                              \
            addr = (size_t)p;                                                  \
            tree = splay (addr, tree);                                         \
            addr -= tree->start;                                               \
        }                                                                      \
        if (addr >= tree->size) {                                              \
            addr = (size_t)p;                                                  \
            tree = splay_end (addr, tree);                                     \
            addr -= tree->start;                                               \
        }                                                                      \
        if (addr <= tree->size) {                                              \
            if (tree->is_invalid || addr + offset + dsize > tree->size) {      \
                POST_SEM ();                                                   \
                bound_warning("%p is outside of the region (0x%lx..0x%lx)",    \
                              p + offset, (long)tree->start,                   \
                              (long)(tree->start + tree->size - 1));           \
                if (never_fatal <= 0)                                          \
                    return INVALID_POINTER; /* return an invalid pointer */    \
                return p + offset;                                             \
            }                                                                  \
        }                                                                      \
        else {                                                                 \
            INCR_COUNT(bound_not_found);                                       \
            POST_SEM ();                                                       \
            bound_not_found_warning (__FILE__, __FUNCTION__, p);               \
            return p + offset;                                                 \
        }                                                                      \
    }                                                                          \
    POST_SEM ();                                                               \
    return p + offset;                                                         \
}

BOUND_PTR_INDIR(1)
BOUND_PTR_INDIR(2)
BOUND_PTR_INDIR(4)
BOUND_PTR_INDIR(8)
BOUND_PTR_INDIR(12)
BOUND_PTR_INDIR(16)

/* Needed when using ...libtcc1-usegcc=yes in lib/Makefile */
#if (defined(__GNUC__) && (__GNUC__ >= 6)) || defined(__clang__)
/*
 * At least gcc 6.2 complains when __builtin_frame_address is used with
 * nonzero argument.
 */
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wframe-address"
#endif

/* return the frame pointer of the caller */
#define GET_CALLER_FP(fp)\
{\
    fp = (size_t)__builtin_frame_address(1);\
}

/* called when entering a function to add all the local regions */
void FASTCALL __bound_local_new(void *p1) 
{
    size_t addr, fp, *p = p1;

    if (NO_CHECKING_GET())
         return;
    GET_CALLER_FP(fp);
    dprintf(stderr, "%s, %s(): p1=%p fp=%p\n",
            __FILE__, __FUNCTION__, p, (void *)fp);
    WAIT_SEM ();
    while ((addr = p[0])) {
        INCR_COUNT(bound_local_new_count);
        tree = splay_insert(addr + fp, p[1], tree);
        p += 2;
    }
    POST_SEM ();
#if BOUND_DEBUG
    if (print_calls) {
        p = p1;
        while ((addr = p[0])) {
            dprintf(stderr, "%s, %s(): %p 0x%lx\n",
                    __FILE__, __FUNCTION__,
                    (void *) (addr + fp), (unsigned long) p[1]);
            p += 2;
        }
    }
#endif
}

/* called when leaving a function to delete all the local regions */
void FASTCALL __bound_local_delete(void *p1) 
{
    size_t addr, fp, *p = p1;

    if (NO_CHECKING_GET())
         return;
    GET_CALLER_FP(fp);
    dprintf(stderr, "%s, %s(): p1=%p fp=%p\n",
            __FILE__, __FUNCTION__, p, (void *)fp);
    WAIT_SEM ();
    while ((addr = p[0])) {
        INCR_COUNT(bound_local_delete_count);
        tree = splay_delete(addr + fp, tree);
        p += 2;
    }
    if (alloca_list) {
        alloca_list_type *last = NULL;
        alloca_list_type *cur = alloca_list;

        do {
            if (cur->fp == fp) {
                if (last)
                    last->next = cur->next;
                else
                    alloca_list = cur->next;
                tree = splay_delete ((size_t) cur->p, tree);
                dprintf(stderr, "%s, %s(): remove alloca/vla %p\n",
                        __FILE__, __FUNCTION__, cur->p);
                BOUND_FREE (cur);
                cur = last ? last->next : alloca_list;
             }
             else {
                 last = cur;
                 cur = cur->next;
             }
        } while (cur);
    }
    if (jmp_list) {
        jmp_list_type *last = NULL;
        jmp_list_type *cur = jmp_list;

        do {
            if (cur->fp == fp) {
                if (last)
                    last->next = cur->next;
                else
                    jmp_list = cur->next;
                dprintf(stderr, "%s, %s(): remove setjmp %p\n",
                       __FILE__, __FUNCTION__, cur->penv);
                BOUND_FREE (cur);
                cur = last ? last->next : jmp_list;
            }
            else {
                last = cur;
                cur = cur->next;
            }
        } while (cur);
    }

    POST_SEM ();
#if BOUND_DEBUG
    if (print_calls) {
        p = p1;
        while ((addr = p[0])) {
            if (addr != 1) {
                dprintf(stderr, "%s, %s(): %p 0x%lx\n",
                        __FILE__, __FUNCTION__,
                        (void *) (addr + fp), (unsigned long) p[1]);
            }
            p+= 2;
        }
    }
#endif
}

/* used by alloca */
void __bound_new_region(void *p, size_t size)
{
    size_t fp;
    alloca_list_type *last;
    alloca_list_type *cur;
    alloca_list_type *new;

    if (NO_CHECKING_GET())
        return;

    dprintf(stderr, "%s, %s(): %p, 0x%lx\n",
            __FILE__, __FUNCTION__, p, (unsigned long)size);
    GET_CALLER_FP (fp);
    new = BOUND_MALLOC (sizeof (alloca_list_type));
    WAIT_SEM ();
    INCR_COUNT(bound_alloca_count);
    last = NULL;
    cur = alloca_list;
    while (cur) {
#if defined(__i386__) || (defined(__arm__) && !defined(__ARM_EABI__))
        int align = 4;
#elif defined(__arm__)
        int align = 8;
#else
        int align = 16;
#endif
        void *cure = (void *)((char *)cur->p + ((cur->size + align) & -align));
        void *pe = (void *)((char *)p + ((size + align) & -align));
        if (cur->fp == fp && ((cur->p <= p && cure > p) ||
                              (p <= cur->p && pe > cur->p))) {
            if (last)
                last->next = cur->next;
            else
                alloca_list = cur->next;
            tree = splay_delete((size_t)cur->p, tree);
            break;
        }
        last = cur;
        cur = cur->next;
    }
    tree = splay_insert((size_t)p, size, tree);
    if (new) {
        new->fp = fp;
        new->p = p;
        new->size = size;
        new->next = alloca_list;
        alloca_list = new;
    }
    POST_SEM ();
    if (cur) {
        dprintf(stderr, "%s, %s(): remove alloca/vla %p\n",
                __FILE__, __FUNCTION__, cur->p);
        BOUND_FREE (cur);
    }
}

void __bound_setjmp(jmp_buf env)
{
    jmp_list_type *jl;
    void *e = (void *) env;

    if (NO_CHECKING_GET() == 0) {
        dprintf(stderr, "%s, %s(): %p\n", __FILE__, __FUNCTION__, e);
        WAIT_SEM ();
        INCR_COUNT(bound_setjmp_count);
        jl = jmp_list;
        while (jl) {
            if (jl->penv == e)
                break;
            jl = jl->next;
        }
        if (jl == NULL) {
            jl = BOUND_MALLOC (sizeof (jmp_list_type));
            if (jl) {
                jl->penv = e;
                jl->next = jmp_list;
                jmp_list = jl;
            }
        }
        if (jl) {
            size_t fp;

            GET_CALLER_FP (fp);
            jl->fp = fp;
            jl->end_fp = (size_t)__builtin_frame_address(0);
            BOUND_GET_TID(jl->tid);
        }
        POST_SEM ();
    }
}

static void __bound_long_jump(jmp_buf env, int val, int sig, const char *func)
{
    jmp_list_type *jl;
    void *e;
    BOUND_TID_TYPE tid;

    if (NO_CHECKING_GET() == 0) {
        e = (void *)env;
        BOUND_GET_TID(tid);
        dprintf(stderr, "%s, %s(): %p\n", __FILE__, func, e);
        WAIT_SEM();
        INCR_COUNT(bound_longjmp_count);
        jl = jmp_list;
        while (jl) {
            if (jl->penv == e && jl->tid == tid) {
                size_t start_fp = (size_t)__builtin_frame_address(0);
                size_t end_fp = jl->end_fp;
                jmp_list_type *cur = jmp_list;
                jmp_list_type *last = NULL;

                while (cur->penv != e || cur->tid != tid) {
                    if (cur->tid == tid) {
                        dprintf(stderr, "%s, %s(): remove setjmp %p\n",
                                __FILE__, func, cur->penv);
                        if (last)
                            last->next = cur->next;
                        else
                            jmp_list = cur->next;
                        BOUND_FREE (cur);
                        cur = last ? last->next : jmp_list;
                    }
                    else {
                        last = cur;
                        cur = cur->next;
                    }
                }
                for (;;) {
                    Tree *t = tree;
                    alloca_list_type *last;
                    alloca_list_type *cur;

                    while (t && (t->start < start_fp || t->start > end_fp))
                        if (t->start < start_fp)
                            t = t->right;
                        else
                            t = t->left;
                    if (t == NULL)
                        break;
                    last = NULL;
                    cur = alloca_list;
                    while (cur) {
                         if ((size_t) cur->p == t->start) {
                             dprintf(stderr, "%s, %s(): remove alloca/vla %p\n",
                                     __FILE__, func, cur->p);
                             if (last)
                                 last->next = cur->next;
                             else
                                 alloca_list = cur->next;
                             BOUND_FREE (cur);
                             break;
                         }
                         last = cur;
                         cur = cur->next;
                    }
                    dprintf(stderr, "%s, %s(): delete %p\n",
                            __FILE__, func, (void *) t->start);
                    tree = splay_delete(t->start, tree);
                }
                break;
            }
            jl = jl->next;
        }
        POST_SEM();
    }
#if !defined(_WIN32)
    sig ? siglongjmp(env, val) :
#endif
    longjmp (env, val);
}

void __bound_longjmp(jmp_buf env, int val)
{
    __bound_long_jump(env,val, 0, __FUNCTION__);
}

#if !defined(_WIN32)
void __bound_siglongjmp(jmp_buf env, int val)
{
    __bound_long_jump(env,val, 1, __FUNCTION__);
}
#endif

#if (defined(__GNUC__) && (__GNUC__ >= 6)) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

void __bound_init(size_t *p, int mode)
{
    dprintf(stderr, "%s, %s(): start %s\n", __FILE__, __FUNCTION__,
            mode < 0 ? "lazy" : mode == 0 ? "normal use" : "for -run");

    if (inited) {
        WAIT_SEM();
        goto add_bounds;
    }
    inited = 1;

#if HAVE_TLS_FUNC
#if defined(_WIN32)
    no_checking_key = TlsAlloc();
    TlsSetValue(no_checking_key, &no_checking);
#else
    pthread_key_create(&no_checking_key, NULL);
    pthread_setspecific(no_checking_key, &no_checking);
#endif
#endif
    NO_CHECKING_SET(1);

    print_warn_ptr_add = getenv ("TCC_BOUNDS_WARN_POINTER_ADD") != NULL;
    print_calls = getenv ("TCC_BOUNDS_PRINT_CALLS") != NULL;
    print_heap = getenv ("TCC_BOUNDS_PRINT_HEAP") != NULL;
    print_statistic = getenv ("TCC_BOUNDS_PRINT_STATISTIC") != NULL;
    never_fatal = getenv ("TCC_BOUNDS_NEVER_FATAL") != NULL;

    INIT_SEM ();

#if MALLOC_REDIR
    {
        void *addr = mode > 0 ? RTLD_DEFAULT : RTLD_NEXT;

        /* tcc -run required RTLD_DEFAULT. Normal usage requires RTLD_NEXT,
           but using RTLD_NEXT with -run segfaults on MacOS in dyld as the
           generated code segment isn't registered with dyld and hence the
           caller image of dlsym isn't known to it */
        *(void **) (&malloc_redir) = dlsym (addr, "malloc");
        if (malloc_redir == NULL) {
            dprintf(stderr, "%s, %s(): use RTLD_DEFAULT\n",
                    __FILE__, __FUNCTION__);
            addr = RTLD_DEFAULT;
            *(void **) (&malloc_redir) = dlsym (addr, "malloc");
        }
        *(void **) (&calloc_redir) = dlsym (addr, "calloc");
        *(void **) (&free_redir) = dlsym (addr, "free");
        *(void **) (&realloc_redir) = dlsym (addr, "realloc");
        *(void **) (&memalign_redir) = dlsym (addr, "memalign");
        dprintf(stderr, "%s, %s(): malloc_redir %p\n",
                __FILE__, __FUNCTION__, malloc_redir);
        dprintf(stderr, "%s, %s(): free_redir %p\n",
                __FILE__, __FUNCTION__, free_redir);
        dprintf(stderr, "%s, %s(): realloc_redir %p\n",
                __FILE__, __FUNCTION__, realloc_redir);
        dprintf(stderr, "%s, %s(): memalign_redir %p\n",
                __FILE__, __FUNCTION__, memalign_redir);
        if (malloc_redir == NULL || free_redir == NULL)
            bound_alloc_error ("Cannot redirect malloc/free");
#if HAVE_PTHREAD_CREATE
        *(void **) (&pthread_create_redir) = dlsym (addr, "pthread_create");
        dprintf(stderr, "%s, %s(): pthread_create_redir %p\n",
                __FILE__, __FUNCTION__, pthread_create_redir);
        if (pthread_create_redir == NULL)
            bound_alloc_error ("Cannot redirect pthread_create");
#endif
#if HAVE_SIGNAL
        *(void **) (&signal_redir) = dlsym (addr, "signal");
        dprintf(stderr, "%s, %s(): signal_redir %p\n",
                __FILE__, __FUNCTION__, signal_redir);
        if (signal_redir == NULL)
            bound_alloc_error ("Cannot redirect signal");
#endif
#if HAVE_SIGACTION
        *(void **) (&sigaction_redir) = dlsym (addr, "sigaction");
        dprintf(stderr, "%s, %s(): sigaction_redir %p\n",
                __FILE__, __FUNCTION__, sigaction_redir);
        if (sigaction_redir == NULL)
            bound_alloc_error ("Cannot redirect sigaction");
#endif
#if HAVE_FORK
        *(void **) (&fork_redir) = dlsym (addr, "fork");
        dprintf(stderr, "%s, %s(): fork_redir %p\n",
                __FILE__, __FUNCTION__, fork_redir);
        if (fork_redir == NULL)
            bound_alloc_error ("Cannot redirect fork");
#endif
    }
#endif

#ifdef __linux__
    {
        FILE *fp;
        unsigned char found;
        unsigned long start;
        unsigned long end;
        unsigned long ad =
            (unsigned long) __builtin_return_address(0);
        char line[1000];

        /* Display exec name. Usefull when a lot of code is compiled with tcc */
        fp = fopen ("/proc/self/comm", "r");
        if (fp) {
            memset (exec, 0, sizeof(exec));
            fread (exec, 1, sizeof(exec) - 2, fp);
            if (strchr(exec,'\n'))
                *strchr(exec,'\n') = '\0';
            strcat (exec, ":");
            fclose (fp);
        }
        /* check if dlopen is used (is threre a better way?) */ 
        found = 0;
        fp = fopen ("/proc/self/maps", "r");
        if (fp) {
            while (fgets (line, sizeof(line), fp)) {
                if (sscanf (line, "%lx-%lx", &start, &end) == 2 &&
                            ad >= start && ad < end) {
                    found = 1;
                    break;
                }
                if (strstr (line,"[heap]"))
                    break;
            }
            fclose (fp);
        }
        if (found == 0) {
            use_sem = 1;
            no_strdup = 1;
        }
    }
#endif

    WAIT_SEM ();

#if HAVE_CTYPE
#ifdef __APPLE__
    tree = splay_insert((size_t) &_DefaultRuneLocale,
                        sizeof (_DefaultRuneLocale), tree);
#else
    /* XXX: Does not work if locale is changed */
    tree = splay_insert((size_t) __ctype_b_loc(),
                        sizeof (unsigned short *), tree);
    tree = splay_insert((size_t) (*__ctype_b_loc() - 128),
                        384 * sizeof (unsigned short), tree);
    tree = splay_insert((size_t) __ctype_tolower_loc(),
                        sizeof (__int32_t *), tree);
    tree = splay_insert((size_t) (*__ctype_tolower_loc() - 128),
                        384 * sizeof (__int32_t), tree);
    tree = splay_insert((size_t) __ctype_toupper_loc(),
                        sizeof (__int32_t *), tree);
    tree = splay_insert((size_t) (*__ctype_toupper_loc() - 128),
                        384 * sizeof (__int32_t), tree);
#endif
#endif
#if HAVE_ERRNO
    tree = splay_insert((size_t) (&errno), sizeof (int), tree);
#endif

add_bounds:
    if (!p)
        goto no_bounds;

    /* add all static bound check values */
    while (p[0] != 0) {
        tree = splay_insert(p[0], p[1], tree);
#if BOUND_DEBUG
        dprintf(stderr, "%s, %s(): static var %p 0x%lx\n",
                __FILE__, __FUNCTION__,
                (void *) p[0], (unsigned long) p[1]);
#endif
        p += 2;
    }
no_bounds:

    POST_SEM ();
    NO_CHECKING_SET(0);
    dprintf(stderr, "%s, %s(): end\n\n", __FILE__, __FUNCTION__);
}

void
#if (defined(__GLIBC__) && (__GLIBC_MINOR__ >= 4)) || defined(_WIN32)
__attribute__((constructor))
#endif
__bound_main_arg(int argc, char **argv, char **envp)
{
    __bound_init (0, -1);
    if (argc && argv) {
        int i;

        WAIT_SEM ();
        for (i = 0; i < argc; i++)
            tree = splay_insert((size_t) argv[i], strlen (argv[i]) + 1, tree);
        tree = splay_insert((size_t) argv, (argc + 1) * sizeof(char *), tree);
        POST_SEM ();
#if BOUND_DEBUG
        if (print_calls) {
            for (i = 0; i < argc; i++)
                dprintf(stderr, "%s, %s(): arg %p 0x%lx\n",
                        __FILE__, __FUNCTION__,
                        argv[i], (unsigned long)(strlen (argv[i]) + 1));
            dprintf(stderr, "%s, %s(): argv %p %d\n",
                    __FILE__, __FUNCTION__, argv,
                    (int)((argc + 1) * sizeof(char *)));
        }
#endif
    }

    if (envp && *envp) {
        char **p = envp;

        WAIT_SEM ();
        while (*p) {
            tree = splay_insert((size_t) *p, strlen (*p) + 1, tree);
            ++p;
        }
        tree = splay_insert((size_t) envp, (++p - envp) * sizeof(char *), tree);
        POST_SEM ();
#if BOUND_DEBUG
        if (print_calls) {
            p = envp;
            while (*p) {
                dprintf(stderr, "%s, %s(): env %p 0x%lx\n",
                        __FILE__, __FUNCTION__,
                        *p, (unsigned long)(strlen (*p) + 1));
                ++p;
            }
            dprintf(stderr, "%s, %s(): environ %p %d\n",
                    __FILE__, __FUNCTION__, envp,
                    (int)((++p - envp) * sizeof(char *)));
        }
#endif
    }
}

void __attribute__((destructor)) __bound_exit(void)
{
    int i;
    static const char * const alloc_type[] = {
        "", "malloc", "calloc", "realloc", "memalign", "strdup"
    };

    dprintf(stderr, "%s, %s():\n", __FILE__, __FUNCTION__);

    if (inited) {
#if !defined(_WIN32) && !defined(__APPLE__) && !defined CONFIG_TCC_MUSL && \
    !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(__NetBSD__) && \
    !defined(__ANDROID__)
        if (print_heap) {
            extern void __libc_freeres (void);
            __libc_freeres ();
        }
#endif

        NO_CHECKING_SET(1);

        TRY_SEM ();
        while (alloca_list) {
            alloca_list_type *next = alloca_list->next;

            tree = splay_delete ((size_t) alloca_list->p, tree);
            BOUND_FREE (alloca_list);
            alloca_list = next;
        }
        while (jmp_list) {
           jmp_list_type *next  = jmp_list->next;

           BOUND_FREE (jmp_list);
           jmp_list = next;
        }
        for (i = 0; i < FREE_REUSE_SIZE; i++) {
            if (free_reuse_list[i]) {
                tree = splay_delete ((size_t) free_reuse_list[i], tree);
                BOUND_FREE (free_reuse_list[i]);
             }
        }
        while (tree) {
            if (print_heap && tree->type != 0)
                fprintf (stderr, "%s, %s(): %s found size %lu\n",
                         __FILE__, __FUNCTION__, alloc_type[tree->type],
                         (unsigned long) tree->size);
            tree = splay_delete (tree->start, tree);
        }
#if TREE_REUSE
        while (tree_free_list) {
            Tree *next = tree_free_list->left;
            BOUND_FREE (tree_free_list);
            tree_free_list = next;
        }
#endif
        POST_SEM ();
        EXIT_SEM ();
#if HAVE_TLS_FUNC
#if defined(_WIN32)
        TlsFree(no_checking_key);
#else
        pthread_key_delete(no_checking_key);
#endif
#endif
        inited = 0;
        if (print_statistic) {
#if BOUND_STATISTIC
            fprintf (stderr, "bound_ptr_add_count      %llu\n", bound_ptr_add_count);
            fprintf (stderr, "bound_ptr_indir1_count   %llu\n", bound_ptr_indir1_count);
            fprintf (stderr, "bound_ptr_indir2_count   %llu\n", bound_ptr_indir2_count);
            fprintf (stderr, "bound_ptr_indir4_count   %llu\n", bound_ptr_indir4_count);
            fprintf (stderr, "bound_ptr_indir8_count   %llu\n", bound_ptr_indir8_count);
            fprintf (stderr, "bound_ptr_indir12_count  %llu\n", bound_ptr_indir12_count);
            fprintf (stderr, "bound_ptr_indir16_count  %llu\n", bound_ptr_indir16_count);
            fprintf (stderr, "bound_local_new_count    %llu\n", bound_local_new_count);
            fprintf (stderr, "bound_local_delete_count %llu\n", bound_local_delete_count);
            fprintf (stderr, "bound_malloc_count       %llu\n", bound_malloc_count);
            fprintf (stderr, "bound_calloc_count       %llu\n", bound_calloc_count);
            fprintf (stderr, "bound_realloc_count      %llu\n", bound_realloc_count);
            fprintf (stderr, "bound_free_count         %llu\n", bound_free_count);
            fprintf (stderr, "bound_memalign_count     %llu\n", bound_memalign_count);
            fprintf (stderr, "bound_mmap_count         %llu\n", bound_mmap_count);
            fprintf (stderr, "bound_munmap_count       %llu\n", bound_munmap_count);
            fprintf (stderr, "bound_alloca_count       %llu\n", bound_alloca_count);
            fprintf (stderr, "bound_setjmp_count       %llu\n", bound_setjmp_count);
            fprintf (stderr, "bound_longjmp_count      %llu\n", bound_longjmp_count);
            fprintf (stderr, "bound_mempcy_count       %llu\n", bound_mempcy_count);
            fprintf (stderr, "bound_memcmp_count       %llu\n", bound_memcmp_count);
            fprintf (stderr, "bound_memmove_count      %llu\n", bound_memmove_count);
            fprintf (stderr, "bound_memset_count       %llu\n", bound_memset_count);
            fprintf (stderr, "bound_strlen_count       %llu\n", bound_strlen_count);
            fprintf (stderr, "bound_strcpy_count       %llu\n", bound_strcpy_count);
            fprintf (stderr, "bound_strncpy_count      %llu\n", bound_strncpy_count);
            fprintf (stderr, "bound_strcmp_count       %llu\n", bound_strcmp_count);
            fprintf (stderr, "bound_strncmp_count      %llu\n", bound_strncmp_count);
            fprintf (stderr, "bound_strcat_count       %llu\n", bound_strcat_count);
            fprintf (stderr, "bound_strncat_count      %llu\n", bound_strncat_count);
            fprintf (stderr, "bound_strchr_count       %llu\n", bound_strchr_count);
            fprintf (stderr, "bound_strrchr_count      %llu\n", bound_strrchr_count);
            fprintf (stderr, "bound_strdup_count       %llu\n", bound_strdup_count);
            fprintf (stderr, "bound_not_found          %llu\n", bound_not_found);
#endif
#if BOUND_STATISTIC_SPLAY
            fprintf (stderr, "bound_splay              %llu\n", bound_splay);
            fprintf (stderr, "bound_splay_end          %llu\n", bound_splay_end);
            fprintf (stderr, "bound_splay_insert       %llu\n", bound_splay_insert);
            fprintf (stderr, "bound_splay_delete       %llu\n", bound_splay_delete);
#endif
        }
    }
}

void __bound_exit_dll(size_t *p)
{
    dprintf(stderr, "%s, %s()\n", __FILE__, __FUNCTION__);

    if (p) {
        WAIT_SEM ();
	while (p[0] != 0) {
	    tree = splay_delete(p[0], tree);
#if BOUND_DEBUG
            if (print_calls) {
                dprintf(stderr, "%s, %s(): remove static var %p 0x%lx\n",
                        __FILE__, __FUNCTION__,
                        (void *) p[0], (unsigned long) p[1]);
            }
#endif
	    p += 2;
	}
        POST_SEM ();
    }
}

#if HAVE_PTHREAD_CREATE
typedef struct {
    void *(*start_routine) (void *);
    void *arg;
    sigset_t old_mask;
} bound_thread_create_type;

static void *bound_thread_create(void *bdata)
{
    bound_thread_create_type *data = (bound_thread_create_type *) bdata;
    void *retval;
#if HAVE_TLS_FUNC
    int *p = (int *) BOUND_MALLOC(sizeof(int));
  
    if (!p) bound_alloc_error("bound_thread_create malloc");
    *p = 0;
    pthread_setspecific(no_checking_key, p);
#endif
    pthread_sigmask(SIG_SETMASK, &data->old_mask, NULL);
    retval = data->start_routine(data->arg);
#if HAVE_TLS_FUNC
    pthread_setspecific(no_checking_key, NULL);
    BOUND_FREE (p);
#endif
    BOUND_FREE (data);
    return retval;
}

int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                   void *(*start_routine) (void *), void *arg)
{
    int retval;
    bound_thread_create_type *data;
    sigset_t mask;
    sigset_t old_mask;
  
    use_sem = 1;
    dprintf (stderr, "%s, %s()\n", __FILE__, __FUNCTION__);
    sigfillset(&mask);
    pthread_sigmask(SIG_SETMASK, &mask, &old_mask);
    data = (bound_thread_create_type *) BOUND_MALLOC(sizeof(bound_thread_create_type));
    if (!data) bound_alloc_error("bound_thread_create malloc");
    data->start_routine = start_routine;
    data->arg = arg;
    data->old_mask = old_mask;
    retval = pthread_create_redir(thread, attr, bound_thread_create, data);
    pthread_sigmask(SIG_SETMASK, &old_mask, NULL);
    return retval;
}
#endif

#if HAVE_SIGNAL || HAVE_SIGACTION
typedef union {
#if HAVE_SIGNAL
    bound_sig signal_handler;
#endif
#if HAVE_SIGACTION
    void (*sig_handler)(int);
    void (*sig_sigaction)(int, siginfo_t *, void *);
#endif
} bound_sig_type;

static unsigned char bound_sig_used[NSIG];
static bound_sig_type bound_sig_data[NSIG];
#endif

#if HAVE_SIGNAL
static void signal_handler(int sig)
{
   __bounds_checking(1);
   bound_sig_data[sig].signal_handler(sig);
   __bounds_checking(-1);
}

bound_sig signal(int signum, bound_sig handler)
{
    bound_sig retval;

    dprintf (stderr, "%s, %s() %d %p\n", __FILE__, __FUNCTION__,
             signum, handler);
    retval = signal_redir(signum, handler ? signal_handler : handler);
    if (retval != SIG_ERR) {
        if (bound_sig_used[signum])
            retval = bound_sig_data[signum].signal_handler;
        if (handler) {
            bound_sig_used[signum] = 1;
            bound_sig_data[signum].signal_handler = handler;
        }
    }
    return retval;
}
#endif

#if HAVE_SIGACTION
static void sig_handler(int sig)
{
   __bounds_checking(1);
   bound_sig_data[sig].sig_handler(sig);
   __bounds_checking(-1);
}

static void sig_sigaction(int sig, siginfo_t *info, void *ucontext)
{
   __bounds_checking(1);
   bound_sig_data[sig].sig_sigaction(sig, info, ucontext);
   __bounds_checking(-1);
}

int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact)
{
    int retval;
    struct sigaction nact, oact;

    dprintf (stderr, "%s, %s() %d %p %p\n", __FILE__, __FUNCTION__,
             signum, act, oldact);

    if (sigaction_redir == NULL)
        __bound_init(0,-1);

    if (act) {
        nact = *act;
        if (nact.sa_flags & SA_SIGINFO)
            nact.sa_sigaction = sig_sigaction;
        else
            nact.sa_handler = sig_handler;
        retval = sigaction_redir(signum, &nact, &oact);
    }
    else
        retval = sigaction_redir(signum, act, &oact);
    if (retval >= 0) {
        if (bound_sig_used[signum]) {
            if (oact.sa_flags & SA_SIGINFO)
                oact.sa_sigaction = bound_sig_data[signum].sig_sigaction;
            else
                oact.sa_handler = bound_sig_data[signum].sig_handler;
        }
        if (oldact) {
            *oldact = oact;
        }
        if (act) {
            bound_sig_used[signum] = 1;
            if (act->sa_flags & SA_SIGINFO)
                bound_sig_data[signum].sig_sigaction = act->sa_sigaction;
            else
                bound_sig_data[signum].sig_handler = act->sa_handler;
        }
    }
    return retval;
}
#endif

#if HAVE_FORK
pid_t fork(void)
{
    pid_t retval;

    WAIT_SEM();
    retval = (*fork_redir)();
    if (retval == 0)
        INIT_SEM();
    else
        POST_SEM();
    return retval;
}
#endif

#if MALLOC_REDIR
void *malloc(size_t size)
#else
void *__bound_malloc(size_t size, const void *caller)
#endif
{
    void *ptr;
    
#if MALLOC_REDIR
    /* This will catch the first dlsym call from __bound_init */
    if (malloc_redir == NULL) {
        __bound_init (0, -1);
        if (malloc_redir == NULL) {
            ptr = &initial_pool[pool_index];
            pool_index = (pool_index + size + 15) & ~15;
            if (pool_index >= sizeof (initial_pool))
                bound_alloc_error ("initial memory pool too small");
            dprintf (stderr, "%s, %s(): initial %p, 0x%lx\n",
                     __FILE__, __FUNCTION__, ptr, (unsigned long)size);
            return ptr;
        }
    }
#endif
    /* we allocate one more byte to ensure the regions will be
       separated by at least one byte. With the glibc malloc, it may
       be in fact not necessary */
    ptr = BOUND_MALLOC (size + 1);
    dprintf(stderr, "%s, %s(): %p, 0x%lx\n",
            __FILE__, __FUNCTION__, ptr, (unsigned long)size);
    
    if (inited && NO_CHECKING_GET() == 0) {
        WAIT_SEM ();
        INCR_COUNT(bound_malloc_count);

        if (ptr) {
            tree = splay_insert ((size_t) ptr, size ? size : size + 1, tree);
            if (tree && tree->start == (size_t) ptr)
                tree->type = TCC_TYPE_MALLOC;
        }
        POST_SEM ();
    }
    return ptr;
}

#if MALLOC_REDIR
void *memalign(size_t align, size_t size)
#else
void *__bound_memalign(size_t align, size_t size, const void *caller)
#endif
{
    void *ptr;

#if HAVE_MEMALIGN
    /* we allocate one more byte to ensure the regions will be
       separated by at least one byte. With the glibc malloc, it may
       be in fact not necessary */
    ptr = BOUND_MEMALIGN(align, size + 1);
#else
    if (align > 4) {
        /* XXX: handle it ? */
        ptr = NULL;
    } else {
        /* we suppose that malloc aligns to at least four bytes */
        ptr = BOUND_MALLOC(size + 1);
    }
#endif
    dprintf(stderr, "%s, %s(): %p, 0x%lx\n",
            __FILE__, __FUNCTION__, ptr, (unsigned long)size);

    if (NO_CHECKING_GET() == 0) {
        WAIT_SEM ();
        INCR_COUNT(bound_memalign_count);

        if (ptr) {
            tree = splay_insert((size_t) ptr, size ? size : size + 1, tree);
            if (tree && tree->start == (size_t) ptr)
                tree->type = TCC_TYPE_MEMALIGN;
        }
        POST_SEM ();
    }
    return ptr;
}

#if MALLOC_REDIR
void free(void *ptr)
#else
void __bound_free(void *ptr, const void *caller)
#endif
{
    size_t addr = (size_t) ptr;
    void *p;

    if (ptr == NULL || tree == NULL
#if MALLOC_REDIR
        || ((unsigned char *) ptr >= &initial_pool[0] &&
            (unsigned char *) ptr < &initial_pool[sizeof(initial_pool)])
#endif
        )
        return;

    dprintf(stderr, "%s, %s(): %p\n", __FILE__, __FUNCTION__, ptr);

    if (inited && NO_CHECKING_GET() == 0) {
        WAIT_SEM ();
        INCR_COUNT(bound_free_count);
        tree = splay (addr, tree);
        if (tree->start == addr) {
            if (tree->is_invalid) {
                POST_SEM ();
                bound_error("freeing invalid region");
                return;
            }
            tree->is_invalid = 1;
            memset (ptr, 0x5a, tree->size);
            p = free_reuse_list[free_reuse_index];
            free_reuse_list[free_reuse_index] = ptr;
            free_reuse_index = (free_reuse_index + 1) % FREE_REUSE_SIZE;
            if (p)
                tree = splay_delete((size_t)p, tree);
            ptr = p;
        }
        POST_SEM ();
    }
    BOUND_FREE (ptr);
}

#if MALLOC_REDIR
void *realloc(void *ptr, size_t size)
#else
void *__bound_realloc(void *ptr, size_t size, const void *caller)
#endif
{
    void *new_ptr;

    if (size == 0) {
#if MALLOC_REDIR
        free(ptr);
#else
        __bound_free(ptr, caller);
#endif
        return NULL;
    }

    new_ptr = BOUND_REALLOC (ptr, size + 1);
    dprintf(stderr, "%s, %s(): %p, 0x%lx\n",
            __FILE__, __FUNCTION__, new_ptr, (unsigned long)size);

    if (NO_CHECKING_GET() == 0) {
        WAIT_SEM ();
        INCR_COUNT(bound_realloc_count);

        if (ptr)
            tree = splay_delete ((size_t) ptr, tree);
        if (new_ptr) {
            tree = splay_insert ((size_t) new_ptr, size ? size : size + 1, tree);
            if (tree && tree->start == (size_t) new_ptr)
                tree->type = TCC_TYPE_REALLOC;
        }
        POST_SEM ();
    }
    return new_ptr;
}

#if MALLOC_REDIR
void *calloc(size_t nmemb, size_t size)
#else
void *__bound_calloc(size_t nmemb, size_t size)
#endif
{
    void *ptr;

    size *= nmemb;
#if MALLOC_REDIR
    /* This will catch the first dlsym call from __bound_init */
    if (malloc_redir == NULL) {
        __bound_init (0, -1);
        if (malloc_redir == NULL) {
            ptr = &initial_pool[pool_index];
            pool_index = (pool_index + size + 15) & ~15;
            if (pool_index >= sizeof (initial_pool))
                bound_alloc_error ("initial memory pool too small");
            dprintf (stderr, "%s, %s(): initial %p, 0x%lx\n",
                     __FILE__, __FUNCTION__, ptr, (unsigned long)size);
            memset (ptr, 0, size);
            return ptr;
        }
    }
#endif
    ptr = BOUND_MALLOC(size + 1);
    dprintf (stderr, "%s, %s(): %p, 0x%lx\n",
             __FILE__, __FUNCTION__, ptr, (unsigned long)size);

    if (ptr) {
        memset (ptr, 0, size);
        if (NO_CHECKING_GET() == 0) {
            WAIT_SEM ();
            INCR_COUNT(bound_calloc_count);
            tree = splay_insert ((size_t) ptr, size ? size : size + 1, tree);
            if (tree && tree->start == (size_t) ptr)
                tree->type = TCC_TYPE_CALLOC;
            POST_SEM ();
        }
    }
    return ptr;
}

#if !defined(_WIN32)
void *__bound_mmap (void *start, size_t size, int prot,
                    int flags, int fd, off_t offset)
{
    void *result;

    dprintf(stderr, "%s, %s(): %p, 0x%lx\n",
            __FILE__, __FUNCTION__, start, (unsigned long)size);
    result = mmap (start, size, prot, flags, fd, offset);
    if (result && NO_CHECKING_GET() == 0) {
        WAIT_SEM ();
        INCR_COUNT(bound_mmap_count);
        tree = splay_insert((size_t)result, size, tree);
        POST_SEM ();
    }
    return result;
}

int __bound_munmap (void *start, size_t size)
{
    int result;

    dprintf(stderr, "%s, %s(): %p, 0x%lx\n",
            __FILE__, __FUNCTION__, start, (unsigned long)size);
    if (start && NO_CHECKING_GET() == 0) {
        WAIT_SEM ();
        INCR_COUNT(bound_munmap_count);
        tree = splay_delete ((size_t) start, tree);
        POST_SEM ();
    }
    result = munmap (start, size);
    return result;
}
#endif

/* some useful checked functions */

/* check that (p ... p + size - 1) lies inside 'p' region, if any */
static void __bound_check(const void *p, size_t size, const char *function)
{
    if (size != 0 && __bound_ptr_add((void *)p, size) == INVALID_POINTER) {
        bound_error("invalid pointer %p, size 0x%lx in %s",
                p, (unsigned long)size, function);
    }
}

static int check_overlap (const void *p1, size_t n1,
                          const void *p2, size_t n2,
                          const char *function)
{
    const void *p1e = (const void *) ((const char *) p1 + n1);
    const void *p2e = (const void *) ((const char *) p2 + n2);

    if (NO_CHECKING_GET() == 0 && n1 != 0 && n2 !=0 &&
        ((p1 <= p2 && p1e > p2) ||     /* p1----p2====p1e----p2e */
         (p2 <= p1 && p2e > p1))) {    /* p2----p1====p2e----p1e */
        bound_error("overlapping regions %p(0x%lx), %p(0x%lx) in %s",
                p1, (unsigned long)n1, p2, (unsigned long)n2, function);
        return never_fatal < 0;
    }
    return 0;
}

void *__bound_memcpy(void *dest, const void *src, size_t n)
{
    dprintf(stderr, "%s, %s(): %p, %p, 0x%lx\n",
            __FILE__, __FUNCTION__, dest, src, (unsigned long)n);
    INCR_COUNT(bound_mempcy_count);
    __bound_check(dest, n, "memcpy dest");
    __bound_check(src, n, "memcpy src");
    if (check_overlap(dest, n, src, n, "memcpy"))
        return dest;
    return memcpy(dest, src, n);
}

int __bound_memcmp(const void *s1, const void *s2, size_t n)
{
    const unsigned char *u1 = (const unsigned char *) s1;
    const unsigned char *u2 = (const unsigned char *) s2;
    int retval = 0;

    dprintf(stderr, "%s, %s(): %p, %p, 0x%lx\n",
            __FILE__, __FUNCTION__, s1, s2, (unsigned long)n);
    INCR_COUNT(bound_memcmp_count);
    for (;;) {
        if ((ssize_t) --n == -1)
            break;
        else if (*u1 != *u2) {
            retval = *u1++ - *u2++;
            break;
        }
        ++u1;
        ++u2;
    }
    __bound_check(s1, (const void *)u1 - s1, "memcmp s1");
    __bound_check(s2, (const void *)u2 - s2, "memcmp s2");
    return retval;
}

void *__bound_memmove(void *dest, const void *src, size_t n)
{
    dprintf(stderr, "%s, %s(): %p, %p, 0x%lx\n",
            __FILE__, __FUNCTION__, dest, src, (unsigned long)n);
    INCR_COUNT(bound_memmove_count);
    __bound_check(dest, n, "memmove dest");
    __bound_check(src, n, "memmove src");
    return memmove(dest, src, n);
}

void *__bound_memset(void *s, int c, size_t n)
{
    dprintf(stderr, "%s, %s(): %p, %d, 0x%lx\n",
            __FILE__, __FUNCTION__, s, c, (unsigned long)n);
    INCR_COUNT(bound_memset_count);
    __bound_check(s, n, "memset");
    return memset(s, c, n);
}

#if defined(__arm__) && defined(__ARM_EABI__)
void *__bound___aeabi_memcpy(void *dest, const void *src, size_t n)
{
    dprintf(stderr, "%s, %s(): %p, %p, 0x%lx\n",
            __FILE__, __FUNCTION__, dest, src, (unsigned long)n);
    INCR_COUNT(bound_mempcy_count);
    __bound_check(dest, n, "memcpy dest");
    __bound_check(src, n, "memcpy src");
    if (check_overlap(dest, n, src, n, "memcpy"))
        return dest;
    return __aeabi_memcpy(dest, src, n);
}

void *__bound___aeabi_memmove(void *dest, const void *src, size_t n)
{
    dprintf(stderr, "%s, %s(): %p, %p, 0x%lx\n",
            __FILE__, __FUNCTION__, dest, src, (unsigned long)n);
    INCR_COUNT(bound_memmove_count);
    __bound_check(dest, n, "memmove dest");
    __bound_check(src, n, "memmove src");
    return __aeabi_memmove(dest, src, n);
}

void *__bound___aeabi_memmove4(void *dest, const void *src, size_t n)
{
    dprintf(stderr, "%s, %s(): %p, %p, 0x%lx\n",
            __FILE__, __FUNCTION__, dest, src, (unsigned long)n);
    INCR_COUNT(bound_memmove_count);
    __bound_check(dest, n, "memmove dest");
    __bound_check(src, n, "memmove src");
    return __aeabi_memmove4(dest, src, n);
}

void *__bound___aeabi_memmove8(void *dest, const void *src, size_t n)
{
    dprintf(stderr, "%s, %s(): %p, %p, 0x%lx\n",
            __FILE__, __FUNCTION__, dest, src, (unsigned long)n);
    INCR_COUNT(bound_memmove_count);
    __bound_check(dest, n, "memmove dest");
    __bound_check(src, n, "memmove src");
    return __aeabi_memmove8(dest, src, n);
}

void *__bound___aeabi_memset(void *s, int c, size_t n)
{
    dprintf(stderr, "%s, %s(): %p, %d, 0x%lx\n",
            __FILE__, __FUNCTION__, s, c, (unsigned long)n);
    INCR_COUNT(bound_memset_count);
    __bound_check(s, n, "memset");
    return __aeabi_memset(s, c, n);
}
#endif

int __bound_strlen(const char *s)
{
    const char *p = s;

    dprintf(stderr, "%s, %s(): %p\n",
            __FILE__, __FUNCTION__, s);
    INCR_COUNT(bound_strlen_count);
    while (*p++);
    __bound_check(s, p - s, "strlen");
    return (p - s) - 1;
}

char *__bound_strcpy(char *dest, const char *src)
{
    size_t len;
    const char *p = src;

    dprintf(stderr, "%s, %s(): %p, %p\n",
            __FILE__, __FUNCTION__, dest, src);
    INCR_COUNT(bound_strcpy_count);
    while (*p++);
    len = p - src;
    __bound_check(dest, len, "strcpy dest");
    __bound_check(src, len, "strcpy src");
    if (check_overlap(dest, len, src, len, "strcpy"))
        return dest;
    return strcpy (dest, src);
}

char *__bound_strncpy(char *dest, const char *src, size_t n)
{
    size_t len = n;
    const char *p = src;

    dprintf(stderr, "%s, %s(): %p, %p, 0x%lx\n",
            __FILE__, __FUNCTION__, dest, src, (unsigned long)n);
    INCR_COUNT(bound_strncpy_count);
    while (len-- && *p++);
    len = p - src;
    __bound_check(dest, len, "strncpy dest");
    __bound_check(src, len, "strncpy src");
    if (check_overlap(dest, len, src, len, "strncpy"))
        return dest;
    return strncpy(dest, src, n);
}

int __bound_strcmp(const char *s1, const char *s2)
{
    const unsigned char *u1 = (const unsigned char *) s1;
    const unsigned char *u2 = (const unsigned char *) s2;

    dprintf(stderr, "%s, %s(): %p, %p\n",
            __FILE__, __FUNCTION__, s1, s2);
    INCR_COUNT(bound_strcmp_count);
    while (*u1 && *u1 == *u2) {
        ++u1;
        ++u2;
    }
    __bound_check(s1, ((const char *)u1 - s1) + 1, "strcmp s1");
    __bound_check(s2, ((const char *)u2 - s2) + 1, "strcmp s2");
    return *u1 - *u2;
}

int __bound_strncmp(const char *s1, const char *s2, size_t n)
{
    const unsigned char *u1 = (const unsigned char *) s1;
    const unsigned char *u2 = (const unsigned char *) s2;
    int retval = 0;

    dprintf(stderr, "%s, %s(): %p, %p, 0x%lx\n",
            __FILE__, __FUNCTION__, s1, s2, (unsigned long)n);
    INCR_COUNT(bound_strncmp_count);
    do {
        if ((ssize_t) --n == -1)
            break;
        else if (*u1 != *u2) {
            retval = *u1++ - *u2++;
            break;
        }
        ++u2;
    } while (*u1++);
    __bound_check(s1, (const char *)u1 - s1, "strncmp s1");
    __bound_check(s2, (const char *)u2 - s2, "strncmp s2");
    return retval;
}

char *__bound_strcat(char *dest, const char *src)
{
    char *r = dest;
    const char *s = src;

    dprintf(stderr, "%s, %s(): %p, %p\n",
            __FILE__, __FUNCTION__, dest, src);
    INCR_COUNT(bound_strcat_count);
    while (*dest++);
    while (*src++);
    __bound_check(r, (dest - r) + (src - s) - 1, "strcat dest");
    __bound_check(s, src - s, "strcat src");
    if (check_overlap(r, (dest - r) + (src - s) - 1, s, src - s, "strcat"))
        return dest;
    return strcat(r, s);
}

char *__bound_strncat(char *dest, const char *src, size_t n)
{
    char *r = dest;
    const char *s = src;
    size_t len = n;

    dprintf(stderr, "%s, %s(): %p, %p, 0x%lx\n",
            __FILE__, __FUNCTION__, dest, src, (unsigned long)n);
    INCR_COUNT(bound_strncat_count);
    while (*dest++);
    while (len-- && *src++);
    __bound_check(r, (dest - r) + (src - s) - 1, "strncat dest");
    __bound_check(s, src - s, "strncat src");
    if (check_overlap(r, (dest - r) + (src - s) - 1, s, src - s, "strncat"))
        return dest;
    return strncat(r, s, n);
}

char *__bound_strchr(const char *s, int c)
{
    const unsigned char *str = (const unsigned char *) s;
    unsigned char ch = c;

    dprintf(stderr, "%s, %s(): %p, %d\n",
            __FILE__, __FUNCTION__, s, ch);
    INCR_COUNT(bound_strchr_count);
    while (*str) {
        if (*str == ch)
            break;
        ++str;
    }
    __bound_check(s, ((const char *)str - s) + 1, "strchr");
    return *str == ch ? (char *) str : NULL;
}

char *__bound_strrchr(const char *s, int c)
{
    const unsigned char *str = (const unsigned char *) s;
    unsigned char ch = c;

    dprintf(stderr, "%s, %s(): %p, %d\n",
            __FILE__, __FUNCTION__, s, ch);
    INCR_COUNT(bound_strrchr_count);
    while (*str++);
    __bound_check(s, (const char *)str - s, "strrchr");
    while (str != (const unsigned char *)s) {
        if (*--str == ch)
            break;
    }
    __bound_check(s, (const char *)str - s, "strrchr");
    return *str == ch ? (char *) str : NULL;
}

char *__bound_strdup(const char *s)
{
    const char *p = s;
    char *new;

    INCR_COUNT(bound_strdup_count);
    while (*p++);
    __bound_check(s, p - s, "strdup");
    new = BOUND_MALLOC ((p - s) + 1);
    dprintf(stderr, "%s, %s(): %p, 0x%lx\n",
            __FILE__, __FUNCTION__, new, (unsigned long)(p -s));
    if (new) {
        if (NO_CHECKING_GET() == 0 && no_strdup == 0) {
            WAIT_SEM ();
            tree = splay_insert((size_t)new, p - s, tree);
            if (tree && tree->start == (size_t) new)
                tree->type = TCC_TYPE_STRDUP;
            POST_SEM ();
        }
        memcpy (new, s, p - s);
    }
    return new;
}

/*
           An implementation of top-down splaying with sizes
             D. Sleator <sleator@cs.cmu.edu>, January 1994.

  This extends top-down-splay.c to maintain a size field in each node.
  This is the number of nodes in the subtree rooted there.  This makes
  it possible to efficiently compute the rank of a key.  (The rank is
  the number of nodes to the left of the given key.)  It it also
  possible to quickly find the node of a given rank.  Both of these
  operations are illustrated in the code below.  The remainder of this
  introduction is taken from top-down-splay.c.

  "Splay trees", or "self-adjusting search trees" are a simple and
  efficient data structure for storing an ordered set.  The data
  structure consists of a binary tree, with no additional fields.  It
  allows searching, insertion, deletion, deletemin, deletemax,
  splitting, joining, and many other operations, all with amortized
  logarithmic performance.  Since the trees adapt to the sequence of
  requests, their performance on real access patterns is typically even
  better.  Splay trees are described in a number of texts and papers
  [1,2,3,4].

  The code here is adapted from simple top-down splay, at the bottom of
  page 669 of [2].  It can be obtained via anonymous ftp from
  spade.pc.cs.cmu.edu in directory /usr/sleator/public.

  The chief modification here is that the splay operation works even if the
  item being splayed is not in the tree, and even if the tree root of the
  tree is NULL.  So the line:

                              t = splay(i, t);

  causes it to search for item with key i in the tree rooted at t.  If it's
  there, it is splayed to the root.  If it isn't there, then the node put
  at the root is the last one before NULL that would have been reached in a
  normal binary search for i.  (It's a neighbor of i in the tree.)  This
  allows many other operations to be easily implemented, as shown below.

  [1] "Data Structures and Their Algorithms", Lewis and Denenberg,
       Harper Collins, 1991, pp 243-251.
  [2] "Self-adjusting Binary Search Trees" Sleator and Tarjan,
       JACM Volume 32, No 3, July 1985, pp 652-686.
  [3] "Data Structure and Algorithm Analysis", Mark Weiss,
       Benjamin Cummins, 1992, pp 119-130.
  [4] "Data Structures, Algorithms, and Performance", Derick Wood,
       Addison-Wesley, 1993, pp 367-375
*/

/* Code adapted for tcc */

#define compare(start,tstart,tsize) (start < tstart ? -1 : \
                                     start >= tstart+tsize  ? 1 : 0)

static Tree * splay (size_t addr, Tree *t)
/* Splay using the key start (which may or may not be in the tree.) */
/* The starting root is t, and the tree used is defined by rat      */
{
    Tree N, *l, *r, *y;
    int comp;
    
    INCR_COUNT_SPLAY(bound_splay);
    if (t == NULL) return t;
    N.left = N.right = NULL;
    l = r = &N;
 
    for (;;) {
        comp = compare(addr, t->start, t->size);
        if (comp < 0) {
            y = t->left;
            if (y == NULL) break;
            if (compare(addr, y->start, y->size) < 0) {
                t->left = y->right;                    /* rotate right */
                y->right = t;
                t = y;
                if (t->left == NULL) break;
            }
            r->left = t;                               /* link right */
            r = t;
            t = t->left;
        } else if (comp > 0) {
            y = t->right;
            if (y == NULL) break;
            if (compare(addr, y->start, y->size) > 0) {
                t->right = y->left;                    /* rotate left */
                y->left = t;
                t = y;
                if (t->right == NULL) break;
            }
            l->right = t;                              /* link left */
            l = t;
            t = t->right;
        } else {
            break;
        }
    }
    l->right = t->left;                                /* assemble */
    r->left = t->right;
    t->left = N.right;
    t->right = N.left;

    return t;
}

#define compare_end(start,tend) (start < tend ? -1 : \
                                 start > tend  ? 1 : 0)

static Tree * splay_end (size_t addr, Tree *t)
/* Splay using the key start (which may or may not be in the tree.) */
/* The starting root is t, and the tree used is defined by rat  */
{
    Tree N, *l, *r, *y;
    int comp;
    
    INCR_COUNT_SPLAY(bound_splay_end);
    if (t == NULL) return t;
    N.left = N.right = NULL;
    l = r = &N;
 
    for (;;) {
        comp = compare_end(addr, t->start + t->size);
        if (comp < 0) {
            y = t->left;
            if (y == NULL) break;
            if (compare_end(addr, y->start + y->size) < 0) {
                t->left = y->right;                    /* rotate right */
                y->right = t;
                t = y;
                if (t->left == NULL) break;
            }
            r->left = t;                               /* link right */
            r = t;
            t = t->left;
        } else if (comp > 0) {
            y = t->right;
            if (y == NULL) break;
            if (compare_end(addr, y->start + y->size) > 0) {
                t->right = y->left;                    /* rotate left */
                y->left = t;
                t = y;
                if (t->right == NULL) break;
            }
            l->right = t;                              /* link left */
            l = t;
            t = t->right;
        } else {
            break;
        }
    }
    l->right = t->left;                                /* assemble */
    r->left = t->right;
    t->left = N.right;
    t->right = N.left;

    return t;
}

static Tree * splay_insert(size_t addr, size_t size, Tree * t)
/* Insert key start into the tree t, if it is not already there. */
/* Return a pointer to the resulting tree.                       */
{
    Tree * new;

    INCR_COUNT_SPLAY(bound_splay_insert);
    if (t != NULL) {
        t = splay(addr,t);
        if (compare(addr, t->start, t->size)==0) {
            return t;  /* it's already there */
        }
    }
#if TREE_REUSE
    if (tree_free_list) {
          new = tree_free_list;
          tree_free_list = new->left;
    }
    else
#endif
    {
        new = (Tree *) BOUND_MALLOC (sizeof (Tree));
    }
    if (new == NULL) {
        bound_alloc_error("not enough memory for bound checking code");
    }
    else {
        if (t == NULL) {
            new->left = new->right = NULL;
        } else if (compare(addr, t->start, t->size) < 0) {
            new->left = t->left;
            new->right = t;
            t->left = NULL;
        } else {
            new->right = t->right;
            new->left = t;
            t->right = NULL;
        }
        new->start = addr;
        new->size = size;
        new->type = TCC_TYPE_NONE;
        new->is_invalid = 0;
    }
    return new;
}

#define compare_destroy(start,tstart) (start < tstart ? -1 : \
                                       start > tstart  ? 1 : 0)

static Tree * splay_delete(size_t addr, Tree *t)
/* Deletes addr from the tree if it's there.               */
/* Return a pointer to the resulting tree.                 */
{
    Tree * x;

    INCR_COUNT_SPLAY(bound_splay_delete);
    if (t==NULL) return NULL;
    t = splay(addr,t);
    if (compare_destroy(addr, t->start) == 0) {        /* found it */
        if (t->left == NULL) {
            x = t->right;
        } else {
            x = splay(addr, t->left);
            x->right = t->right;
        }
#if TREE_REUSE
        t->left = tree_free_list;
        tree_free_list = t;
#else
        BOUND_FREE(t);
#endif
        return x;
    } else {
        return t;                                      /* It wasn't there */
    }
}

void splay_printtree(Tree * t, int d)
{
    int i;
    if (t == NULL) return;
    splay_printtree(t->right, d+1);
    for (i=0; i<d; i++) fprintf(stderr," ");
    fprintf(stderr,"%p(0x%lx:%u:%u)\n",
            (void *) t->start, (unsigned long) t->size,
            (unsigned)t->type, (unsigned)t->is_invalid);
    splay_printtree(t->left, d+1);
}
/* ------------------------------------------------------------- */
/* stubs for calling bcheck functions from a dll. */

#include <windows.h>
#include <stdio.h>

#define REDIR_ALL \
  REDIR(__bt_init) \
  REDIR(__bt_exit) \
  REDIR(tcc_backtrace) \
  \
  REDIR(__bound_ptr_add) \
  REDIR(__bound_ptr_indir1) \
  REDIR(__bound_ptr_indir2) \
  REDIR(__bound_ptr_indir4) \
  REDIR(__bound_ptr_indir8) \
  REDIR(__bound_ptr_indir12) \
  REDIR(__bound_ptr_indir16) \
  REDIR(__bound_local_new) \
  REDIR(__bound_local_delete) \
  REDIR(__bound_new_region) \
  \
  REDIR(__bound_free) \
  REDIR(__bound_malloc) \
  REDIR(__bound_realloc) \
  REDIR(__bound_memcpy) \
  REDIR(__bound_memcmp) \
  REDIR(__bound_memmove) \
  REDIR(__bound_memset) \
  REDIR(__bound_strlen) \
  REDIR(__bound_strcpy) \
  REDIR(__bound_strncpy) \
  REDIR(__bound_strcmp) \
  REDIR(__bound_strncmp) \
  REDIR(__bound_strcat) \
  REDIR(__bound_strchr) \
  REDIR(__bound_strdup)

#ifdef __leading_underscore
#define _(s) "_"#s
#else
#define _(s) #s
#endif

#define REDIR(s) void *s;
static struct { REDIR_ALL } all_ptrs;
#undef REDIR
#define REDIR(s) #s"\0"
static const char all_names[] = REDIR_ALL;
#undef REDIR
#define REDIR(s) __asm__(".global " _(s) ";" _(s) ": jmp *%0" : : "m" (all_ptrs.s) );
static void all_jmps() { REDIR_ALL }
#undef REDIR

void __bt_init_dll(int bcheck)
{
    const char *s = all_names;
    void **p = (void**)&all_ptrs;
    do {
        *p = (void*)GetProcAddress(GetModuleHandle(NULL), (char*)s);
        if (NULL == *p) {
            char buf[100];
            sprintf(buf,
                "Error: function '%s()' not found in executable. "
                "(Need -bt or -b for linking the exe.)", s);
            if (GetStdHandle(STD_ERROR_HANDLE))
                fprintf(stderr, "TCC/BCHECK: %s\n", buf), fflush(stderr);
            else
                MessageBox(NULL, buf, "TCC/BCHECK", MB_ICONERROR);
            ExitProcess(1);
        }
        s = strchr(s,'\0') + 1, ++p;
    } while (*s && (bcheck || p < &all_ptrs.__bound_ptr_add));
}
/* ------------------------------------------------------------- */
/* for linking rt_printline and the signal/exception handler
   from tccrun.c into executables. */

#define CONFIG_TCC_BACKTRACE_ONLY
#define ONE_SOURCE 1
#define pstrcpy tcc_pstrcpy
#include "../tccrun.c"

#ifndef _WIN32
# define __declspec(n)
#endif

__declspec(dllexport)
void __bt_init(rt_context *p, int is_exe)
{
    __attribute__((weak)) int main();
    __attribute__((weak)) void __bound_init(void*, int);

    //fprintf(stderr, "__bt_init %d %p %p %p\n", is_exe, p, p->stab_sym, p->bounds_start), fflush(stderr);

    /* call __bound_init here due to redirection of sigaction */
    /* needed to add global symbols */
    if (p->bounds_start)
	__bound_init(p->bounds_start, -1);

    /* add to chain */
    rt_wait_sem();
    p->next = g_rc, g_rc = p;
    rt_post_sem();
    if (is_exe) {
        /* we are the executable (not a dll) */
        p->top_func = main;
        set_exception_handler();
    }
}

__declspec(dllexport)
void __bt_exit(rt_context *p)
{
    struct rt_context *rc, **pp;
    __attribute__((weak)) void __bound_exit_dll(void*);

    //fprintf(stderr, "__bt_exit %d %p\n", !!p->top_func, p);

    if (p->bounds_start)
	__bound_exit_dll(p->bounds_start);

    /* remove from chain */
    rt_wait_sem();
    for (pp = &g_rc; rc = *pp, rc; pp = &rc->next)
        if (rc == p) {
            *pp = rc->next;
            break;
        }
    rt_post_sem();
}

/* copy a string and truncate it. */
ST_FUNC char *pstrcpy(char *buf, size_t buf_size, const char *s)
{
    int l = strlen(s);
    if (l >= buf_size)
        l = buf_size - 1;
    memcpy(buf, s, l);
    buf[l] = 0;
    return buf;
}
/* ------------------------------------------------------------- */
/* function to get a stack backtrace on demand with a message */

#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#undef __attribute__

#ifdef _WIN32
# define DLL_EXPORT __declspec(dllexport)
#else
# define DLL_EXPORT
#endif

/* Needed when using ...libtcc1-usegcc=yes in lib/Makefile */
#if (defined(__GNUC__) && (__GNUC__ >= 6)) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wframe-address"
#endif

typedef struct rt_frame {
    void *ip, *fp, *sp;
} rt_frame;

__attribute__((weak))
int _tcc_backtrace(rt_frame *f, const char *fmt, va_list ap);

DLL_EXPORT int tcc_backtrace(const char *fmt, ...)
{
    va_list ap;
    int ret;

    if (_tcc_backtrace) {
        rt_frame f;
        f.fp = __builtin_frame_address(1);
        f.ip = __builtin_return_address(0);
        va_start(ap, fmt);
        ret = _tcc_backtrace(&f, fmt, ap);
        va_end(ap);
    } else {
        const char *p, *nl = "\n";
        if (fmt[0] == '^' && (p = strchr(fmt + 1, fmt[0])))
            fmt = p + 1;
        if (fmt[0] == '\001')
            ++fmt, nl = "";
        va_start(ap, fmt);
        ret = vfprintf(stderr, fmt, ap);
        va_end(ap);
        fprintf(stderr, "%s", nl), fflush(stderr);
    }
    return ret;
}

#if (defined(__GNUC__) && (__GNUC__ >= 6)) || defined(__clang__)
#pragma GCC diagnostic pop
#endif
/* uses alias to allow building with gcc/clang */
#ifdef __TINYC__
#define	BUILTIN(x)	__builtin_##x
#define	BUILTINN(x)	"__builtin_" # x
#else
#define	BUILTIN(x)	__tcc_builtin_##x
#define	BUILTINN(x)	"__tcc_builtin_" # x
#endif

/* ---------------------------------------------- */
/* This file implements:
 * __builtin_ffs
 * __builtin_clz
 * __builtin_ctz
 * __builtin_clrsb
 * __builtin_popcount
 * __builtin_parity
 * for int, long and long long
 */

static const unsigned char table_1_32[] = {
     0,  1, 28,  2, 29, 14, 24,  3, 30, 22, 20, 15, 25, 17,  4,  8, 
    31, 27, 13, 23, 21, 19, 16,  7, 26, 12, 18,  6, 11,  5, 10,  9
};
static const unsigned char table_2_32[32] = {
    31, 22, 30, 21, 18, 10, 29,  2, 20, 17, 15, 13,  9,  6, 28,  1,
    23, 19, 11,  3, 16, 14,  7, 24, 12,  4,  8, 25,  5, 26, 27,  0
};
static const unsigned char table_1_64[] = {
     0,  1,  2, 53,  3,  7, 54, 27,  4, 38, 41,  8, 34, 55, 48, 28,
    62,  5, 39, 46, 44, 42, 22,  9, 24, 35, 59, 56, 49, 18, 29, 11,
    63, 52,  6, 26, 37, 40, 33, 47, 61, 45, 43, 21, 23, 58, 17, 10,
    51, 25, 36, 32, 60, 20, 57, 16, 50, 31, 19, 15, 30, 14, 13, 12
};
static const unsigned char table_2_64[] = {
    63, 16, 62,  7, 15, 36, 61,  3,  6, 14, 22, 26, 35, 47, 60,  2,
     9,  5, 28, 11, 13, 21, 42, 19, 25, 31, 34, 40, 46, 52, 59,  1,
    17,  8, 37,  4, 23, 27, 48, 10, 29, 12, 43, 20, 32, 41, 53, 18,
    38, 24, 49, 30, 44, 33, 54, 39, 50, 45, 55, 51, 56, 57, 58,  0
};

#define FFSI(x) \
    return table_1_32[((x & -x) * 0x077cb531u) >> 27] + (x != 0);
#define FFSL(x) \
    return table_1_64[((x & -x) * 0x022fdd63cc95386dull) >> 58] + (x != 0);
#define CTZI(x) \
    return table_1_32[((x & -x) * 0x077cb531u) >> 27];
#define CTZL(x) \
    return table_1_64[((x & -x) * 0x022fdd63cc95386dull) >> 58];
#define CLZI(x)   \
    x |= x >> 1;  \
    x |= x >> 2;  \
    x |= x >> 4;  \
    x |= x >> 8;  \
    x |= x >> 16; \
    return table_2_32[(x * 0x07c4acddu) >> 27];
#define CLZL(x)   \
    x |= x >> 1;  \
    x |= x >> 2;  \
    x |= x >> 4;  \
    x |= x >> 8;  \
    x |= x >> 16; \
    x |= x >> 32; \
    return table_2_64[x * 0x03f79d71b4cb0a89ull >> 58];
#define POPCOUNTI(x, m)                                                   \
    x = x - ((x >> 1) & 0x55555555);                                      \
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);                       \
    x = (x + (x >> 4)) & 0xf0f0f0f;                                       \
    return ((x * 0x01010101) >> 24) & m; 
#define POPCOUNTL(x, m)                                                   \
    x = x - ((x >> 1) & 0x5555555555555555ull);                           \
    x = (x & 0x3333333333333333ull) + ((x >> 2) & 0x3333333333333333ull); \
    x = (x + (x >> 4)) & 0xf0f0f0f0f0f0f0full;                            \
    return ((x * 0x0101010101010101ull) >> 56) & m;

/* Returns one plus the index of the least significant 1-bit of x,
   or if x is zero, returns zero. */
int BUILTIN(ffs) (int x) { FFSI(x) }
int BUILTIN(ffsll) (long long x) { FFSL(x) }
#if __SIZEOF_LONG__ == 4
int BUILTIN(ffsl) (long x) __attribute__((alias(BUILTINN(ffs))));
#else
int BUILTIN(ffsl) (long x) __attribute__((alias(BUILTINN(ffsll))));
#endif

/* Returns the number of leading 0-bits in x, starting at the most significant
   bit position. If x is 0, the result is undefined.  */
int BUILTIN(clz) (unsigned int x) { CLZI(x) }
int BUILTIN(clzll) (unsigned long long x) { CLZL(x) }
#if __SIZEOF_LONG__ == 4
int BUILTIN(clzl) (unsigned long x) __attribute__((alias(BUILTINN(clz))));
#else
int BUILTIN(clzl) (unsigned long x) __attribute__((alias(BUILTINN(clzll))));
#endif

/* Returns the number of trailing 0-bits in x, starting at the least
   significant bit position. If x is 0, the result is undefined. */
int BUILTIN(ctz) (unsigned int x) { CTZI(x) }
int BUILTIN(ctzll) (unsigned long long x) { CTZL(x) }
#if __SIZEOF_LONG__ == 4
int BUILTIN(ctzl) (unsigned long x) __attribute__((alias(BUILTINN(ctz))));
#else
int BUILTIN(ctzl) (unsigned long x) __attribute__((alias(BUILTINN(ctzll))));
#endif

/* Returns the number of leading redundant sign bits in x, i.e. the number
   of bits following the most significant bit that are identical to it.
   There are no special cases for 0 or other values. */
int BUILTIN(clrsb) (int x) { if (x < 0) x = ~x; x <<= 1; CLZI(x) }
int BUILTIN(clrsbll) (long long x) { if (x < 0) x = ~x; x <<= 1; CLZL(x) }
#if __SIZEOF_LONG__ == 4
int BUILTIN(clrsbl) (long x) __attribute__((alias(BUILTINN(clrsb))));
#else
int BUILTIN(clrsbl) (long x) __attribute__((alias(BUILTINN(clrsbll))));
#endif

/* Returns the number of 1-bits in x.*/
int BUILTIN(popcount) (unsigned int x) { POPCOUNTI(x, 0x3f) }
int BUILTIN(popcountll) (unsigned long long x) { POPCOUNTL(x, 0x7f) }
#if __SIZEOF_LONG__ == 4
int BUILTIN(popcountl) (unsigned long x) __attribute__((alias(BUILTINN(popcount))));
#else
int BUILTIN(popcountl ) (unsigned long x) __attribute__((alias(BUILTINN(popcountll))));
#endif

/* Returns the parity of x, i.e. the number of 1-bits in x modulo 2. */
int BUILTIN(parity) (unsigned int x) { POPCOUNTI(x, 0x01) }
int BUILTIN(parityll) (unsigned long long x) { POPCOUNTL(x, 0x01) }
#if __SIZEOF_LONG__ == 4
int BUILTIN(parityl) (unsigned long x) __attribute__((alias(BUILTINN(parity))));
#else
int BUILTIN(parityl) (unsigned long x) __attribute__((alias(BUILTINN(parityll))));
#endif

#ifndef __TINYC__
#if defined(__GNUC__) && (__GNUC__ >= 6)
/* gcc overrides alias from __builtin_ffs... to ffs.. so use assembly code */
__asm__(".globl  __builtin_ffs");
__asm__(".set __builtin_ffs,__tcc_builtin_ffs");
__asm__(".globl  __builtin_ffsl");
__asm__(".set __builtin_ffsl,__tcc_builtin_ffsl");
__asm__(".globl  __builtin_ffsll");
__asm__(".set __builtin_ffsll,__tcc_builtin_ffsll");
#else
int __builtin_ffs(int x) __attribute__((alias("__tcc_builtin_ffs")));
int __builtin_ffsl(long x) __attribute__((alias("__tcc_builtin_ffsl")));
int __builtin_ffsll(long long x) __attribute__((alias("__tcc_builtin_ffsll")));
#endif
int __builtin_clz(unsigned int x) __attribute__((alias("__tcc_builtin_clz")));
int __builtin_clzl(unsigned long x) __attribute__((alias("__tcc_builtin_clzl")));
int __builtin_clzll(unsigned long long x) __attribute__((alias("__tcc_builtin_clzll")));
int __builtin_ctz(unsigned int x) __attribute__((alias("__tcc_builtin_ctz")));
int __builtin_ctzl(unsigned long x) __attribute__((alias("__tcc_builtin_ctzl")));
int __builtin_ctzll(unsigned long long x) __attribute__((alias("__tcc_builtin_ctzll")));
int __builtin_clrsb(int x) __attribute__((alias("__tcc_builtin_clrsb")));
int __builtin_clrsbl(long x) __attribute__((alias("__tcc_builtin_clrsbl")));
int __builtin_clrsbll(long long x) __attribute__((alias("__tcc_builtin_clrsbll")));
int __builtin_popcount(unsigned int x) __attribute__((alias("__tcc_builtin_popcount")));
int __builtin_popcountl(unsigned long x) __attribute__((alias("__tcc_builtin_popcountl")));
int __builtin_popcountll(unsigned long long x) __attribute__((alias("__tcc_builtin_popcountll")));
int __builtin_parity(unsigned int x) __attribute__((alias("__tcc_builtin_parity")));
int __builtin_parityl(unsigned long x) __attribute__((alias("__tcc_builtin_parityl")));
int __builtin_parityll(unsigned long long x) __attribute__((alias("__tcc_builtin_parityll")));
#endif

ELF          >            @             @ 8       
ELF          >            @             @ 8       
ELF          >            @             @ 8       void * __dso_handle __attribute((visibility("hidden"))) = &__dso_handle;
/*
 *  TCC runtime library for arm64.
 *
 *  Copyright (c) 2015 Edmund Grimley Evans
 *
 * Copying and distribution of this file, with or without modification,
 * are permitted in any medium without royalty provided the copyright
 * notice and this notice are preserved.  This file is offered as-is,
 * without any warranty.
 */

#ifdef __TINYC__
typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef short int16_t;
typedef unsigned short uint16_t;
typedef int int32_t;
typedef unsigned uint32_t;
typedef long long int64_t;
typedef unsigned long long uint64_t;
void *memcpy(void*,void*,__SIZE_TYPE__);
#else
#include <stdint.h>
#include <string.h>
#endif

#if !defined __riscv && !defined __APPLE__
void __clear_cache(void *beg, void *end)
{
    __arm64_clear_cache(beg, end);
}
#endif

typedef struct {
    uint64_t x0, x1;
} u128_t;

static long double f3_zero(int sgn)
{
    long double f;
    u128_t x = { 0, (uint64_t)sgn << 63 };
    memcpy(&f, &x, 16);
    return f;
}

static long double f3_infinity(int sgn)
{
    long double f;
    u128_t x = { 0, (uint64_t)sgn << 63 | 0x7fff000000000000 };
    memcpy(&f, &x, 16);
    return f;
}

static long double f3_NaN(void)
{
    long double f;
#if 0
    // ARM's default NaN usually has just the top fraction bit set:
    u128_t x = {  0, 0x7fff800000000000 };
#else
    // GCC's library sets all fraction bits:
    u128_t x = { -1, 0x7fffffffffffffff };
#endif
    memcpy(&f, &x, 16);
    return f;
}

static int fp3_convert_NaN(long double *f, int sgn, u128_t mnt)
{
    u128_t x = { mnt.x0,
                 mnt.x1 | 0x7fff800000000000 | (uint64_t)sgn << 63 };
    memcpy(f, &x, 16);
    return 1;
}

static int fp3_detect_NaNs(long double *f,
                           int a_sgn, int a_exp, u128_t a,
                           int b_sgn, int b_exp, u128_t b)
{
    // Detect signalling NaNs:
    if (a_exp == 32767 && (a.x0 | a.x1 << 16) && !(a.x1 >> 47 & 1))
        return fp3_convert_NaN(f, a_sgn, a);
    if (b_exp == 32767 && (b.x0 | b.x1 << 16) && !(b.x1 >> 47 & 1))
        return fp3_convert_NaN(f, b_sgn, b);

    // Detect quiet NaNs:
    if (a_exp == 32767 && (a.x0 | a.x1 << 16))
        return fp3_convert_NaN(f, a_sgn, a);
    if (b_exp == 32767 && (b.x0 | b.x1 << 16))
        return fp3_convert_NaN(f, b_sgn, b);

    return 0;
}

static void f3_unpack(int *sgn, int32_t *exp, u128_t *mnt, long double f)
{
    u128_t x;
    memcpy(&x, &f, 16);
    *sgn = x.x1 >> 63;
    *exp = x.x1 >> 48 & 32767;
    x.x1 = x.x1 << 16 >> 16;
    if (*exp)
        x.x1 |= (uint64_t)1 << 48;
    else
        *exp = 1;
    *mnt = x;
}

static u128_t f3_normalise(int32_t *exp, u128_t mnt)
{
    int sh;
    if (!(mnt.x0 | mnt.x1))
        return mnt;
    if (!mnt.x1) {
        mnt.x1 = mnt.x0;
        mnt.x0 = 0;
        *exp -= 64;
    }
    for (sh = 32; sh; sh >>= 1) {
        if (!(mnt.x1 >> (64 - sh))) {
            mnt.x1 = mnt.x1 << sh | mnt.x0 >> (64 - sh);
            mnt.x0 = mnt.x0 << sh;
            *exp -= sh;
        }
    }
    return mnt;
}

static u128_t f3_sticky_shift(int32_t sh, u128_t x)
{
  if (sh >= 128) {
      x.x0 = !!(x.x0 | x.x1);
      x.x1 = 0;
      return x;
  }
  if (sh >= 64) {
      x.x0 = x.x1 | !!x.x0;
      x.x1 = 0;
      sh -= 64;
  }
  if (sh > 0) {
      x.x0 = x.x0 >> sh | x.x1 << (64 - sh) | !!(x.x0 << (64 - sh));
      x.x1 = x.x1 >> sh;
  }
  return x;
}

static long double f3_round(int sgn, int32_t exp, u128_t x)
{
    long double f;
    int error;

    if (exp > 0) {
        x = f3_sticky_shift(13, x);
    }
    else {
        x = f3_sticky_shift(14 - exp, x);
        exp = 0;
    }

    error = x.x0 & 3;
    x.x0 = x.x0 >> 2 | x.x1 << 62;
    x.x1 = x.x1 >> 2;

    if (error == 3 || ((error == 2) & (x.x0 & 1))) {
        if (!++x.x0) {
            ++x.x1;
            if (x.x1 == (uint64_t)1 << 48)
                exp = 1;
            else if (x.x1 == (uint64_t)1 << 49) {
                ++exp;
                x.x0 = x.x0 >> 1 | x.x1 << 63;
                x.x1 = x.x1 >> 1;
            }
        }
    }

    if (exp >= 32767)
        return f3_infinity(sgn);

    x.x1 = x.x1 << 16 >> 16 | (uint64_t)exp << 48 | (uint64_t)sgn << 63;
    memcpy(&f, &x, 16);
    return f;
}

static long double f3_add(long double fa, long double fb, int neg)
{
    u128_t a, b, x;
    int32_t a_exp, b_exp, x_exp;
    int a_sgn, b_sgn, x_sgn;
    long double fx;

    f3_unpack(&a_sgn, &a_exp, &a, fa);
    f3_unpack(&b_sgn, &b_exp, &b, fb);

    if (fp3_detect_NaNs(&fx, a_sgn, a_exp, a, b_sgn, b_exp, b))
        return fx;

    b_sgn ^= neg;

    // Handle infinities and zeroes:
    if (a_exp == 32767 && b_exp == 32767 && a_sgn != b_sgn)
        return f3_NaN();
    if (a_exp == 32767)
        return f3_infinity(a_sgn);
    if (b_exp == 32767)
        return f3_infinity(b_sgn);
    if (!(a.x0 | a.x1 | b.x0 | b.x1))
        return f3_zero(a_sgn & b_sgn);

    a.x1 = a.x1 << 3 | a.x0 >> 61;
    a.x0 = a.x0 << 3;
    b.x1 = b.x1 << 3 | b.x0 >> 61;
    b.x0 = b.x0 << 3;

    if (a_exp <= b_exp) {
        a = f3_sticky_shift(b_exp - a_exp, a);
        a_exp = b_exp;
    }
    else {
        b = f3_sticky_shift(a_exp - b_exp, b);
        b_exp = a_exp;
    }

    x_sgn = a_sgn;
    x_exp = a_exp;
    if (a_sgn == b_sgn) {
        x.x0 = a.x0 + b.x0;
        x.x1 = a.x1 + b.x1 + (x.x0 < a.x0);
    }
    else {
        x.x0 = a.x0 - b.x0;
        x.x1 = a.x1 - b.x1 - (x.x0 > a.x0);
        if (x.x1 >> 63) {
            x_sgn ^= 1;
            x.x0 = -x.x0;
            x.x1 = -x.x1 - !!x.x0;
        }
    }

    if (!(x.x0 | x.x1))
        return f3_zero(0);

    x = f3_normalise(&x_exp, x);

    return f3_round(x_sgn, x_exp + 12, x);
}

long double __addtf3(long double a, long double b)
{
    return f3_add(a, b, 0);
}

long double __subtf3(long double a, long double b)
{
    return f3_add(a, b, 1);
}

long double __multf3(long double fa, long double fb)
{
    u128_t a, b, x;
    int32_t a_exp, b_exp, x_exp;
    int a_sgn, b_sgn, x_sgn;
    long double fx;

    f3_unpack(&a_sgn, &a_exp, &a, fa);
    f3_unpack(&b_sgn, &b_exp, &b, fb);

    if (fp3_detect_NaNs(&fx, a_sgn, a_exp, a, b_sgn, b_exp, b))
        return fx;

    // Handle infinities and zeroes:
    if ((a_exp == 32767 && !(b.x0 | b.x1)) ||
        (b_exp == 32767 && !(a.x0 | a.x1)))
        return f3_NaN();
    if (a_exp == 32767 || b_exp == 32767)
        return f3_infinity(a_sgn ^ b_sgn);
    if (!(a.x0 | a.x1) || !(b.x0 | b.x1))
        return f3_zero(a_sgn ^ b_sgn);

    a = f3_normalise(&a_exp, a);
    b = f3_normalise(&b_exp, b);

    x_sgn = a_sgn ^ b_sgn;
    x_exp = a_exp + b_exp - 16352;

    {
        // Convert to base (1 << 30), discarding bottom 6 bits, which are zero,
        // so there are (32, 30, 30, 30) bits in (a3, a2, a1, a0):
        uint64_t a0 = a.x0 << 28 >> 34;
        uint64_t b0 = b.x0 << 28 >> 34;
        uint64_t a1 = a.x0 >> 36 | a.x1 << 62 >> 34;
        uint64_t b1 = b.x0 >> 36 | b.x1 << 62 >> 34;
        uint64_t a2 = a.x1 << 32 >> 34;
        uint64_t b2 = b.x1 << 32 >> 34;
        uint64_t a3 = a.x1 >> 32;
        uint64_t b3 = b.x1 >> 32;
        // Use 16 small multiplications and additions that do not overflow:
        uint64_t x0 = a0 * b0;
        uint64_t x1 = (x0 >> 30) + a0 * b1 + a1 * b0;
        uint64_t x2 = (x1 >> 30) + a0 * b2 + a1 * b1 + a2 * b0;
        uint64_t x3 = (x2 >> 30) + a0 * b3 + a1 * b2 + a2 * b1 + a3 * b0;
        uint64_t x4 = (x3 >> 30) + a1 * b3 + a2 * b2 + a3 * b1;
        uint64_t x5 = (x4 >> 30) + a2 * b3 + a3 * b2;
        uint64_t x6 = (x5 >> 30) + a3 * b3;
        // We now have (64, 30, 30, ...) bits in (x6, x5, x4, ...).
        // Take the top 128 bits, setting bottom bit if any lower bits were set:
        uint64_t y0 = (x5 << 34 | x4 << 34 >> 30 | x3 << 34 >> 60 |
                       !!(x3 << 38 | (x2 | x1 | x0) << 34));
        uint64_t y1 = x6;
        // Top bit may be zero. Renormalise:
        if (!(y1 >> 63)) {
            y1 = y1 << 1 | y0 >> 63;
            y0 = y0 << 1;
            --x_exp;
        }
        x.x0 = y0;
        x.x1 = y1;
    }

    return f3_round(x_sgn, x_exp, x);
}

long double __divtf3(long double fa, long double fb)
{
    u128_t a, b, x;
    int32_t a_exp, b_exp, x_exp;
    int a_sgn, b_sgn, x_sgn, i;
    long double fx;

    f3_unpack(&a_sgn, &a_exp, &a, fa);
    f3_unpack(&b_sgn, &b_exp, &b, fb);

    if (fp3_detect_NaNs(&fx, a_sgn, a_exp, a, b_sgn, b_exp, b))
        return fx;

    // Handle infinities and zeroes:
    if ((a_exp == 32767 && b_exp == 32767) ||
        (!(a.x0 | a.x1) && !(b.x0 | b.x1)))
        return f3_NaN();
    if (a_exp == 32767 || !(b.x0 | b.x1))
        return f3_infinity(a_sgn ^ b_sgn);
    if (!(a.x0 | a.x1) || b_exp == 32767)
        return f3_zero(a_sgn ^ b_sgn);

    a = f3_normalise(&a_exp, a);
    b = f3_normalise(&b_exp, b);

    x_sgn = a_sgn ^ b_sgn;
    x_exp = a_exp - b_exp + 16395;

    a.x0 = a.x0 >> 1 | a.x1 << 63;
    a.x1 = a.x1 >> 1;
    b.x0 = b.x0 >> 1 | b.x1 << 63;
    b.x1 = b.x1 >> 1;
    x.x0 = 0;
    x.x1 = 0;
    for (i = 0; i < 116; i++) {
        x.x1 = x.x1 << 1 | x.x0 >> 63;
        x.x0 = x.x0 << 1;
        if (a.x1 > b.x1 || (a.x1 == b.x1 && a.x0 >= b.x0)) {
            a.x1 = a.x1 - b.x1 - (a.x0 < b.x0);
            a.x0 = a.x0 - b.x0;
            x.x0 |= 1;
        }
        a.x1 = a.x1 << 1 | a.x0 >> 63;
        a.x0 = a.x0 << 1;
    }
    x.x0 |= !!(a.x0 | a.x1);

    x = f3_normalise(&x_exp, x);

    return f3_round(x_sgn, x_exp, x);
}

long double __extendsftf2(float f)
{
    long double fx;
    u128_t x;
    uint32_t a;
    uint64_t aa;
    memcpy(&a, &f, 4);
    aa = a;
    x.x0 = 0;
    if (!(a << 1))
        x.x1 = aa << 32;
    else if (a << 1 >> 24 == 255)
        x.x1 = (0x7fff000000000000 | aa >> 31 << 63 | aa << 41 >> 16 |
                (uint64_t)!!(a << 9) << 47);
    else if (a << 1 >> 24 == 0) {
        uint64_t adj = 0;
        while (!(a << 1 >> 1 >> (23 - adj)))
          adj++;
        x.x1 = aa >> 31 << 63 | (16256 - adj + 1) << 48 | aa << adj << 41 >> 16;
    } else
        x.x1 = (aa >> 31 << 63 | ((aa >> 23 & 255) + 16256) << 48 |
                aa << 41 >> 16);
    memcpy(&fx, &x, 16);
    return fx;
}

long double __extenddftf2(double f)
{
    long double fx;
    u128_t x;
    uint64_t a;
    memcpy(&a, &f, 8);
    x.x0 = a << 60;
    if (!(a << 1))
        x.x1 = a;
    else if (a << 1 >> 53 == 2047)
        x.x1 = (0x7fff000000000000 | a >> 63 << 63 | a << 12 >> 16 |
                (uint64_t)!!(a << 12) << 47);
    else if (a << 1 >> 53 == 0) {
        uint64_t adj = 0;
        while (!(a << 1 >> 1 >> (52 - adj)))
          adj++;
        x.x0 <<= adj;
        x.x1 = a >> 63 << 63 | (15360 - adj + 1) << 48 | a << adj << 12 >> 16;
    } else
        x.x1 = a >> 63 << 63 | ((a >> 52 & 2047) + 15360) << 48 | a << 12 >> 16;
    memcpy(&fx, &x, 16);
    return fx;
}

float __trunctfsf2(long double f)
{
    u128_t mnt;
    int32_t exp;
    int sgn;
    uint32_t x;
    float fx;

    f3_unpack(&sgn, &exp, &mnt, f);

    if (exp == 32767 && (mnt.x0 | mnt.x1 << 16))
        x = 0x7fc00000 | (uint32_t)sgn << 31 | (mnt.x1 >> 25 & 0x007fffff);
    else if (exp > 16510)
        x = 0x7f800000 | (uint32_t)sgn << 31;
    else if (exp < 16233)
        x = (uint32_t)sgn << 31;
    else {
        exp -= 16257;
        x = mnt.x1 >> 23 | !!(mnt.x0 | mnt.x1 << 41);
        if (exp < 0) {
            x = x >> -exp | !!(x << (32 + exp));
            exp = 0;
        }
        if ((x & 3) == 3 || (x & 7) == 6)
            x += 4;
        x = ((x >> 2) + (exp << 23)) | (uint32_t)sgn << 31;
    }
    memcpy(&fx, &x, 4);
    return fx;
}

double __trunctfdf2(long double f)
{
    u128_t mnt;
    int32_t exp;
    int sgn;
    uint64_t x;
    double fx;

    f3_unpack(&sgn, &exp, &mnt, f);

    if (exp == 32767 && (mnt.x0 | mnt.x1 << 16))
        x = (0x7ff8000000000000 | (uint64_t)sgn << 63 |
             mnt.x1 << 16 >> 12 | mnt.x0 >> 60);
    else if (exp > 17406)
        x = 0x7ff0000000000000 | (uint64_t)sgn << 63;
    else if (exp < 15308)
        x = (uint64_t)sgn << 63;
    else {
        exp -= 15361;
        x = mnt.x1 << 6 | mnt.x0 >> 58 | !!(mnt.x0 << 6);
        if (exp < 0) {
            x = x >> -exp | !!(x << (64 + exp));
            exp = 0;
        }
        if ((x & 3) == 3 || (x & 7) == 6)
            x += 4;
        x = ((x >> 2) + ((uint64_t)exp << 52)) | (uint64_t)sgn << 63;
    }
    memcpy(&fx, &x, 8);
    return fx;
}

int32_t __fixtfsi(long double fa)
{
    u128_t a;
    int32_t a_exp;
    int a_sgn;
    int32_t x;
    f3_unpack(&a_sgn, &a_exp, &a, fa);
    if (a_exp < 16369)
        return 0;
    if (a_exp > 16413)
        return a_sgn ? -0x80000000 : 0x7fffffff;
    x = a.x1 >> (16431 - a_exp);
    return a_sgn ? -x : x;
}

int64_t __fixtfdi(long double fa)
{
    u128_t a;
    int32_t a_exp;
    int a_sgn;
    int64_t x;
    f3_unpack(&a_sgn, &a_exp, &a, fa);
    if (a_exp < 16383)
        return 0;
    if (a_exp > 16445)
        return a_sgn ? -0x8000000000000000 : 0x7fffffffffffffff;
    x = (a.x1 << 15 | a.x0 >> 49) >> (16446 - a_exp);
    return a_sgn ? -x : x;
}

uint32_t __fixunstfsi(long double fa)
{
    u128_t a;
    int32_t a_exp;
    int a_sgn;
    f3_unpack(&a_sgn, &a_exp, &a, fa);
    if (a_sgn || a_exp < 16369)
        return 0;
    if (a_exp > 16414)
        return -1;
    return a.x1 >> (16431 - a_exp);
}

uint64_t __fixunstfdi(long double fa)
{
    u128_t a;
    int32_t a_exp;
    int a_sgn;
    f3_unpack(&a_sgn, &a_exp, &a, fa);
    if (a_sgn || a_exp < 16383)
        return 0;
    if (a_exp > 16446)
        return -1;
    return (a.x1 << 15 | a.x0 >> 49) >> (16446 - a_exp);
}

long double __floatsitf(int32_t a)
{
    int sgn = 0;
    int exp = 16414;
    uint32_t mnt = a;
    u128_t x = { 0, 0 };
    long double f;
    int i;
    if (a) {
        if (a < 0) {
            sgn = 1;
            mnt = -mnt;
        }
        for (i = 16; i; i >>= 1)
            if (!(mnt >> (32 - i))) {
                mnt <<= i;
                exp -= i;
            }
        x.x1 = ((uint64_t)sgn << 63 | (uint64_t)exp << 48 |
                (uint64_t)(mnt << 1) << 16);
    }
    memcpy(&f, &x, 16);
    return f;
}

long double __floatditf(int64_t a)
{
    int sgn = 0;
    int exp = 16446;
    uint64_t mnt = a;
    u128_t x = { 0, 0 };
    long double f;
    int i;
    if (a) {
        if (a < 0) {
            sgn = 1;
            mnt = -mnt;
        }
        for (i = 32; i; i >>= 1)
            if (!(mnt >> (64 - i))) {
                mnt <<= i;
                exp -= i;
            }
        x.x0 = mnt << 49;
        x.x1 = (uint64_t)sgn << 63 | (uint64_t)exp << 48 | mnt << 1 >> 16;
    }
    memcpy(&f, &x, 16);
    return f;
}

long double __floatunsitf(uint32_t a)
{
    int exp = 16414;
    uint32_t mnt = a;
    u128_t x = { 0, 0 };
    long double f;
    int i;
    if (a) {
        for (i = 16; i; i >>= 1)
            if (!(mnt >> (32 - i))) {
                mnt <<= i;
                exp -= i;
            }
        x.x1 = (uint64_t)exp << 48 | (uint64_t)(mnt << 1) << 16;
    }
    memcpy(&f, &x, 16);
    return f;
}

long double __floatunditf(uint64_t a)
{
    int exp = 16446;
    uint64_t mnt = a;
    u128_t x = { 0, 0 };
    long double f;
    int i;
    if (a) {
        for (i = 32; i; i >>= 1)
            if (!(mnt >> (64 - i))) {
                mnt <<= i;
                exp -= i;
            }
        x.x0 = mnt << 49;
        x.x1 = (uint64_t)exp << 48 | mnt << 1 >> 16;
    }
    memcpy(&f, &x, 16);
    return f;
}

static int f3_cmp(long double fa, long double fb)
{
    u128_t a, b;
    memcpy(&a, &fa, 16);
    memcpy(&b, &fb, 16);
    return (!(a.x0 | a.x1 << 1 | b.x0 | b.x1 << 1) ? 0 :
            ((a.x1 << 1 >> 49 == 0x7fff && (a.x0 | a.x1 << 16)) ||
             (b.x1 << 1 >> 49 == 0x7fff && (b.x0 | b.x1 << 16))) ? 2 :
            a.x1 >> 63 != b.x1 >> 63 ? (int)(b.x1 >> 63) - (int)(a.x1 >> 63) :
            a.x1 < b.x1 ? (int)(a.x1 >> 63 << 1) - 1 :
            a.x1 > b.x1 ? 1 - (int)(a.x1 >> 63 << 1) :
            a.x0 < b.x0 ? (int)(a.x1 >> 63 << 1) - 1 :
            b.x0 < a.x0 ? 1 - (int)(a.x1 >> 63 << 1) : 0);
}

int __eqtf2(long double a, long double b)
{
    return !!f3_cmp(a, b);
}

int __netf2(long double a, long double b)
{
    return !!f3_cmp(a, b);
}

int __lttf2(long double a, long double b)
{
    return f3_cmp(a, b);
}

int __letf2(long double a, long double b)
{
    return f3_cmp(a, b);
}

int __gttf2(long double a, long double b)
{
    return -f3_cmp(b, a);
}

int __getf2(long double a, long double b)
{
    return -f3_cmp(b, a);
}
!<arch>
/* TCC runtime library. 
   Parts of this code are (c) 2002 Fabrice Bellard 

   Copyright (C) 1987, 1988, 1992, 1994, 1995 Free Software Foundation, Inc.

This file is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

In addition to the permissions in the GNU General Public License, the
Free Software Foundation gives you unlimited permission to link the
compiled version of this file into combinations with other programs,
and to distribute those combinations without any restriction coming
from the use of this file.  (The General Public License restrictions
do apply in other respects; for example, they cover modification of
the file, and distribution when not linked into a combine
executable.)

This file is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to
the Free Software Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  
*/

#define W_TYPE_SIZE   32
#define BITS_PER_UNIT 8

typedef int Wtype;
typedef unsigned int UWtype;
typedef unsigned int USItype;
typedef long long DWtype;
typedef unsigned long long UDWtype;

struct DWstruct {
    Wtype low, high;
};

typedef union
{
  struct DWstruct s;
  DWtype ll;
} DWunion;

typedef long double XFtype;
#define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)
#define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)

/* the following deal with IEEE single-precision numbers */
#define EXCESS		126
#define SIGNBIT		0x80000000
#define HIDDEN		(1 << 23)
#define SIGN(fp)	((fp) & SIGNBIT)
#define EXP(fp)		(((fp) >> 23) & 0xFF)
#define MANT(fp)	(((fp) & 0x7FFFFF) | HIDDEN)
#define PACK(s,e,m)	((s) | ((e) << 23) | (m))

/* the following deal with IEEE double-precision numbers */
#define EXCESSD		1022
#define HIDDEND		(1 << 20)
#define EXPD(fp)	(((fp.l.upper) >> 20) & 0x7FF)
#define SIGND(fp)	((fp.l.upper) & SIGNBIT)
#define MANTD(fp)	(((((fp.l.upper) & 0xFFFFF) | HIDDEND) << 10) | \
				(fp.l.lower >> 22))
#define HIDDEND_LL	((long long)1 << 52)
#define MANTD_LL(fp)	((fp.ll & (HIDDEND_LL-1)) | HIDDEND_LL)
#define PACKD_LL(s,e,m)	(((long long)((s)+((e)<<20))<<32)|(m))

/* the following deal with x86 long double-precision numbers */
#define EXCESSLD	16382
#define EXPLD(fp)	(fp.l.upper & 0x7fff)
#define SIGNLD(fp)	((fp.l.upper) & 0x8000)

/* only for x86 */
union ldouble_long {
    long double ld;
    struct {
        unsigned long long lower;
        unsigned short upper;
    } l;
};

union double_long {
    double d;
#if 1
    struct {
        unsigned int lower;
        int upper;
    } l;
#else
    struct {
        int upper;
        unsigned int lower;
    } l;
#endif
    long long ll;
};

union float_long {
    float f;
    long l;
};

/* XXX: we don't support several builtin supports for now */
#ifndef __x86_64__

/* XXX: use gcc/tcc intrinsic ? */
#if defined(__i386__)
#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
  __asm__ ("subl %5,%1\n\tsbbl %3,%0"					\
	   : "=r" ((USItype) (sh)),					\
	     "=&r" ((USItype) (sl))					\
	   : "0" ((USItype) (ah)),					\
	     "g" ((USItype) (bh)),					\
	     "1" ((USItype) (al)),					\
	     "g" ((USItype) (bl)))
#define umul_ppmm(w1, w0, u, v) \
  __asm__ ("mull %3"							\
	   : "=a" ((USItype) (w0)),					\
	     "=d" ((USItype) (w1))					\
	   : "%0" ((USItype) (u)),					\
	     "rm" ((USItype) (v)))
#define udiv_qrnnd(q, r, n1, n0, dv) \
  __asm__ ("divl %4"							\
	   : "=a" ((USItype) (q)),					\
	     "=d" ((USItype) (r))					\
	   : "0" ((USItype) (n0)),					\
	     "1" ((USItype) (n1)),					\
	     "rm" ((USItype) (dv)))
#define count_leading_zeros(count, x) \
  do {									\
    USItype __cbtmp;							\
    __asm__ ("bsrl %1,%0"						\
	     : "=r" (__cbtmp) : "rm" ((USItype) (x)));			\
    (count) = __cbtmp ^ 31;						\
  } while (0)
#else
#error unsupported CPU type
#endif

/* most of this code is taken from libgcc2.c from gcc */

static UDWtype __udivmoddi4 (UDWtype n, UDWtype d, UDWtype *rp)
{
  DWunion ww;
  DWunion nn, dd;
  DWunion rr;
  UWtype d0, d1, n0, n1, n2;
  UWtype q0, q1;
  UWtype b, bm;

  nn.ll = n;
  dd.ll = d;

  d0 = dd.s.low;
  d1 = dd.s.high;
  n0 = nn.s.low;
  n1 = nn.s.high;

#if !defined(UDIV_NEEDS_NORMALIZATION)
  if (d1 == 0)
    {
      if (d0 > n1)
	{
	  /* 0q = nn / 0D */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
	  q1 = 0;

	  /* Remainder in n0.  */
	}
      else
	{
	  /* qq = NN / 0d */

	  if (d0 == 0)
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */

	  udiv_qrnnd (q1, n1, 0, n1, d0);
	  udiv_qrnnd (q0, n0, n1, n0, d0);

	  /* Remainder in n0.  */
	}

      if (rp != 0)
	{
	  rr.s.low = n0;
	  rr.s.high = 0;
	  *rp = rr.ll;
	}
    }

#else /* UDIV_NEEDS_NORMALIZATION */

  if (d1 == 0)
    {
      if (d0 > n1)
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);

	  if (bm != 0)
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
	      n0 = n0 << bm;
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
	  q1 = 0;

	  /* Remainder in n0 >> bm.  */
	}
      else
	{
	  /* qq = NN / 0d */

	  if (d0 == 0)
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */

	  count_leading_zeros (bm, d0);

	  if (bm == 0)
	    {
	      /* From (n1 >= d0) /\ (the most significant bit of d0 is set),
		 conclude (the most significant bit of n1 is set) /\ (the
		 leading quotient digit q1 = 1).

		 This special case is necessary, not an optimization.
		 (Shifts counts of W_TYPE_SIZE are undefined.)  */

	      n1 -= d0;
	      q1 = 1;
	    }
	  else
	    {
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);

	  /* Remainder in n0 >> bm.  */
	}

      if (rp != 0)
	{
	  rr.s.low = n0 >> bm;
	  rr.s.high = 0;
	  *rp = rr.ll;
	}
    }
#endif /* UDIV_NEEDS_NORMALIZATION */

  else
    {
      if (d1 > n1)
	{
	  /* 00 = nn / DD */

	  q0 = 0;
	  q1 = 0;

	  /* Remainder in n1n0.  */
	  if (rp != 0)
	    {
	      rr.s.low = n0;
	      rr.s.high = n1;
	      *rp = rr.ll;
	    }
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
	  if (bm == 0)
	    {
	      /* From (n1 >= d1) /\ (the most significant bit of d1 is set),
		 conclude (the most significant bit of n1 is set) /\ (the
		 quotient digit q0 = 0 or 1).

		 This special case is necessary, not an optimization.  */

	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
		{
		  q0 = 1;
		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
		}
	      else
		q0 = 0;

	      q1 = 0;

	      if (rp != 0)
		{
		  rr.s.low = n0;
		  rr.s.high = n1;
		  *rp = rr.ll;
		}
	    }
	  else
	    {
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
		{
		  q0--;
		  sub_ddmmss (m1, m0, m1, m0, d1, d0);
		}

	      q1 = 0;

	      /* Remainder in (n1n0 - m1m0) >> bm.  */
	      if (rp != 0)
		{
		  sub_ddmmss (n1, n0, n1, n0, m1, m0);
		  rr.s.low = (n1 << b) | (n0 >> bm);
		  rr.s.high = n1 >> bm;
		  *rp = rr.ll;
		}
	    }
	}
    }

  ww.s.low = q0;
  ww.s.high = q1;
  return ww.ll;
}

#define __negdi2(a) (-(a))

long long __divdi3(long long u, long long v)
{
    int c = 0;
    DWunion uu, vv;
    DWtype w;
    
    uu.ll = u;
    vv.ll = v;
    
    if (uu.s.high < 0) {
        c = ~c;
        uu.ll = __negdi2 (uu.ll);
    }
    if (vv.s.high < 0) {
        c = ~c;
        vv.ll = __negdi2 (vv.ll);
    }
    w = __udivmoddi4 (uu.ll, vv.ll, (UDWtype *) 0);
    if (c)
        w = __negdi2 (w);
    return w;
}

long long __moddi3(long long u, long long v)
{
    int c = 0;
    DWunion uu, vv;
    DWtype w;
    
    uu.ll = u;
    vv.ll = v;
    
    if (uu.s.high < 0) {
        c = ~c;
        uu.ll = __negdi2 (uu.ll);
    }
    if (vv.s.high < 0)
        vv.ll = __negdi2 (vv.ll);
    
    __udivmoddi4 (uu.ll, vv.ll, (UDWtype *) &w);
    if (c)
        w = __negdi2 (w);
    return w;
}

unsigned long long __udivdi3(unsigned long long u, unsigned long long v)
{
    return __udivmoddi4 (u, v, (UDWtype *) 0);
}

unsigned long long __umoddi3(unsigned long long u, unsigned long long v)
{
    UDWtype w;
    
    __udivmoddi4 (u, v, &w);
    return w;
}

/* XXX: fix tcc's code generator to do this instead */
long long __ashrdi3(long long a, int b)
{
#ifdef __TINYC__
    DWunion u;
    u.ll = a;
    if (b >= 32) {
        u.s.low = u.s.high >> (b - 32);
        u.s.high = u.s.high >> 31;
    } else if (b != 0) {
        u.s.low = ((unsigned)u.s.low >> b) | (u.s.high << (32 - b));
        u.s.high = u.s.high >> b;
    }
    return u.ll;
#else
    return a >> b;
#endif
}

/* XXX: fix tcc's code generator to do this instead */
unsigned long long __lshrdi3(unsigned long long a, int b)
{
#ifdef __TINYC__
    DWunion u;
    u.ll = a;
    if (b >= 32) {
        u.s.low = (unsigned)u.s.high >> (b - 32);
        u.s.high = 0;
    } else if (b != 0) {
        u.s.low = ((unsigned)u.s.low >> b) | (u.s.high << (32 - b));
        u.s.high = (unsigned)u.s.high >> b;
    }
    return u.ll;
#else
    return a >> b;
#endif
}

/* XXX: fix tcc's code generator to do this instead */
long long __ashldi3(long long a, int b)
{
#ifdef __TINYC__
    DWunion u;
    u.ll = a;
    if (b >= 32) {
        u.s.high = (unsigned)u.s.low << (b - 32);
        u.s.low = 0;
    } else if (b != 0) {
        u.s.high = ((unsigned)u.s.high << b) | ((unsigned)u.s.low >> (32 - b));
        u.s.low = (unsigned)u.s.low << b;
    }
    return u.ll;
#else
    return a << b;
#endif
}

#if defined(__i386__)
/* FPU control word for rounding to nearest mode */
unsigned short __tcc_fpu_control = 0x137f;
/* FPU control word for round to zero mode for int conversion */
unsigned short __tcc_int_fpu_control = 0x137f | 0x0c00;
#endif

#endif /* !__x86_64__ */

/* XXX: fix tcc's code generator to do this instead */
float __floatundisf(unsigned long long a)
{
    DWunion uu; 
    XFtype r;

    uu.ll = a;
    if (uu.s.high >= 0) {
        return (float)uu.ll;
    } else {
        r = (XFtype)uu.ll;
        r += 18446744073709551616.0;
        return (float)r;
    }
}

double __floatundidf(unsigned long long a)
{
    DWunion uu; 
    XFtype r;

    uu.ll = a;
    if (uu.s.high >= 0) {
        return (double)uu.ll;
    } else {
        r = (XFtype)uu.ll;
        r += 18446744073709551616.0;
        return (double)r;
    }
}

long double __floatundixf(unsigned long long a)
{
    DWunion uu; 
    XFtype r;

    uu.ll = a;
    if (uu.s.high >= 0) {
        return (long double)uu.ll;
    } else {
        r = (XFtype)uu.ll;
        r += 18446744073709551616.0;
        return (long double)r;
    }
}

unsigned long long __fixunssfdi (float a1)
{
    register union float_long fl1;
    register int exp;
    register unsigned long l;

    fl1.f = a1;

    if (fl1.l == 0)
	return (0);

    exp = EXP (fl1.l) - EXCESS - 24;

    l = MANT(fl1.l);
    if (exp >= 41)
	return (unsigned long long)-1;
    else if (exp >= 0)
        return (unsigned long long)l << exp;
    else if (exp >= -23)
        return l >> -exp;
    else
        return 0;
}

unsigned long long __fixunsdfdi (double a1)
{
    register union double_long dl1;
    register int exp;
    register unsigned long long l;

    dl1.d = a1;

    if (dl1.ll == 0)
	return (0);

    exp = EXPD (dl1) - EXCESSD - 53;

    l = MANTD_LL(dl1);

    if (exp >= 12)
	return (unsigned long long)-1;
    else if (exp >= 0)
        return l << exp;
    else if (exp >= -52)
        return l >> -exp;
    else
        return 0;
}

unsigned long long __fixunsxfdi (long double a1)
{
    register union ldouble_long dl1;
    register int exp;
    register unsigned long long l;

    dl1.ld = a1;

    if (dl1.l.lower == 0 && dl1.l.upper == 0)
	return (0);

    exp = EXPLD (dl1) - EXCESSLD - 64;

    l = dl1.l.lower;

    if (exp > 0)
	return (unsigned long long)-1;
    else if (exp >= -63) 
        return l >> -exp;
    else
        return 0;
}

#if defined(__x86_64__) && !defined(_WIN64)

/* helper functions for stdarg.h */

#include <stdlib.h>
#ifndef __TINYC__
/* gives "incompatible types for redefinition of __va_arg" below */
#include <stdio.h>
#endif

enum __va_arg_type {
    __va_gen_reg, __va_float_reg, __va_stack
};

/* GCC compatible definition of va_list. */
struct __va_list_struct {
    unsigned int gp_offset;
    unsigned int fp_offset;
    union {
        unsigned int overflow_offset;
        char *overflow_arg_area;
    };
    char *reg_save_area;
};

void *__va_start(void *fp)
{
    struct __va_list_struct *ap =
        (struct __va_list_struct *)malloc(sizeof(struct __va_list_struct));
    *ap = *(struct __va_list_struct *)((char *)fp - 16);
    ap->overflow_arg_area = (char *)fp + ap->overflow_offset;
    ap->reg_save_area = (char *)fp - 176 - 16;
    return ap;
}

void *__va_arg(struct __va_list_struct *ap,
               enum __va_arg_type arg_type,
               int size)
{
    size = (size + 7) & ~7;
    switch (arg_type) {
    case __va_gen_reg:
        if (ap->gp_offset < 48) {
            ap->gp_offset += 8;
            return ap->reg_save_area + ap->gp_offset - 8;
        }
        size = 8;
        goto use_overflow_area;

    case __va_float_reg:
        if (ap->fp_offset < 128 + 48) {
            ap->fp_offset += 16;
            return ap->reg_save_area + ap->fp_offset - 16;
        }
        size = 8;
        goto use_overflow_area;

    case __va_stack:
    use_overflow_area:
        ap->overflow_arg_area += size;
        return ap->overflow_arg_area - size;

    default:
#ifndef __TINYC__
        fprintf(stderr, "unknown ABI type for __va_arg\n");
#endif
        abort();
    }
}

void *__va_copy(struct __va_list_struct *src)
{
    struct __va_list_struct *dest =
        (struct __va_list_struct *)malloc(sizeof(struct __va_list_struct));
    *dest = *src;
    return dest;
}

void __va_end(struct __va_list_struct *ap)
{
    free(ap);
}

#endif /* __x86_64__ */
ELF          >                    7          @     @   HH xfH*    H|$l$    \$D$fD  HH xfH*    H|$l$    \$D$fD  H|$l$H xf.         f     f~E1Ht?H% IHH      (yA    HLOLD  HILff.     fH~E1HtOfH~IH H4H!HH4  yE1|3  )HIL@ HILff.      LD$HD$Muft%  )|>@  )ILfD  E1Lf     ILD  SH       oC PHH   HPHX[ff.     @ t/trtNPH          H=             G=   vVHG   HHWf     /wHWHDf.     HGHcHHW HWGHD     SH       oHSHP [ff.     f           unknown ABI type for __va_arg
    _1	                           )                      "G   int         %a               (   low );        );    ,	   	s .o   	ll /
U        0       2-   
R       Sh        T            P  	ld Q-   	l U    
[@      \N        ]G        Xm  	d Ym  	l ^  	ll ea            h  	f i  	l j
4                                  4       4               1x      3G        6	      7	      8	      9	       :	  (    ;	  0    <	  8    =	  @    @	  H    A	  P    B	  X    D  `    F  h    HG   p    IG   t    J  x    M       N      O      Q      Y      [      \      ]      ^	      _
      `G       b             +                                           x                    G   *         $  $            N   jf                r      sN       t       o      pN        qN   f      v               	         ap (                  	   UU    !              #       z  src *          "              #        	   UH  !                     L  ap )          $    #@          $    G           %            &              	>  '          (  #        	   U	         T1 QN  )        '	   !    y          1         fp y          *ap {          #        	   UH  +    bG     ,    b  ,    b</  - !    Ih           [       >  .a1 I.-    /dl1 K!   *exp LG           *l M!h            !    0h           r         .a1 0)m  a/dl1 2 @  *exp 3G           *l 4!h            !    h           d         .a1 (  a/fl1 t  *exp G           *l            !    	-           '       b  a 	.h           /uu    *r             !    m          :         .a )h   U/uu    *r             !              :       	  .a (h   U/uu    *r             0        	50        	1        
 0        	O %  $ >   :;9I  $ >  :;9   :;9I8   :;9I8  :;9  	 :;9I  
:;9  :;9      I  & I   :;9   <  I  ! I/  4 :;9I?<  7 I  !   >I:;9  (   :;9   :;9I  :;9   :;9I8   I8  .?:;9'@B   :;9IB  B1    B  !.?:;9'I@B  "4 :;9IB  #1  $ :;9IB  %
 :;9  &1RBUXYW  ' 1B  ( 1  ) 1  *4 :;9IB  +.?:;9'I 4  , :;9I  -   . :;9I  /4 :;9I  0. ?<n:;9  1. ?<n:;              (       U(      )       U                                   U             S             U                               P                      @      k       Uk      u       Uu             U                      @      d       Td      u       Tu             T                                    @      D       QD      _       q	_      u      	 Q#	u             q	             q	            	 Q#	             q	             q 	            	 Q#	             q	            	 Q#	                 R      p      
                                               U      '       S'      0       s0      1       p#                        1       P                                 Q             Q                                                                     b      x       Rx             qw             R                   b      }       P             P                                   Q             Q                                      P                 @C$!             P               @C$!                                   U               h                                  h4-               !                    i       i        !i       o        !--       ?@      "o       z        !                    )       )        !)       /        !--       ?@      "/       :        !                ,                     )                      R      R      S      p                                 lib /usr/include/x86_64-linux-gnu/bits /usr/lib/gcc/x86_64-linux-gnu/9/include /usr/include/x86_64-linux-gnu/bits/types /usr/include  libtcc1.c   stdio2.h   stddef.h   types.h   struct_FILE.h   FILE.h   stdio.h   sys_errlist.h   stdlib.h   <built-in>      	        K			gwK			gwKJQ		gKL	;[	>Zp	Ld <h
Z
Lw	&XAK	Y;[	]q	L:	>V	fh
Z
L	v
<	YX.<?	}<A#K X[	Xh
L	Yt?	t<	yK $>XY	,(<*=(sK*K K	{
{ XtX	p<t		J		f.Y6IY6<
lJ<	<	uoJ6Ig6K $>XY> KX __off_t _IO_read_ptr malloc _shortbuf gp_offset /home/dan/new_app/tcc-source _IO_buf_base long long unsigned int overflow_offset __va_arg lower free float_long _codecvt long long int signed char __builtin_fwrite _fileno GNU C17 9.4.0 -mtune=generic -march=x86-64 -g -O2 -fno-strict-aliasing -fasynchronous-unwind-tables -fstack-protector-strong -fstack-clash-protection -fcf-protection _IO_read_end long int _flags _IO_buf_end _cur_column _IO_codecvt upper double _IO_write_ptr _old_offset _offset arg_type XFtype size_t _IO_marker stdin unsigned int _chain _freeres_buf lib/libtcc1.c fprintf __fixunsdfdi overflow_arg_area long unsigned int DWunion __floatundixf sys_nerr size short unsigned int _IO_wide_data _IO_save_base __va_gen_reg Wtype double_long _lock _flags2 _mode stdout long double __va_list_struct _IO_write_end reg_save_area _IO_lock_t _IO_FILE dest DWstruct float sys_errlist _markers unsigned char short int use_overflow_area _vtable_offset FILE DWtype __floatundisf __floatundidf __va_copy __va_start __va_stack char __stream abort high __off64_t _IO_read_base _IO_save_end __fmt __va_arg_type __pad5 __va_end _unused2 stderr __fixunsxfdi ldouble_long _IO_backup_base fp_offset fwrite __va_float_reg _freeres_list _wide_data _IO_write_base __fixunssfdi  GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0            GNU                    zR x            :          0       :          D       '          X       d          l       r                 [                 1    Ek                 Se           #    E]             	                                                                                                                                                                                                	                      
                                                                                                                                                                                                                                                          :       #     @       :       1            '       ?            d       L            r       Y           [       f            1       q                                                 @                                                                                          #                   	                              libtcc1.c .LC0 .LC2 __floatundisf __floatundidf __floatundixf __fixunssfdi __fixunsdfdi __fixunsxfdi __va_start _GLOBAL_OFFSET_TABLE_ malloc __va_arg stderr fwrite abort __va_copy __va_end free      +             k                                      V            g            l            q                         %         #          
                     
                    
      ;             
      0                            )       
              0       
            7       
            <       
            Q       
            V       
            d       
             k       
      Z       p       
      a             
                   
                   
                   
                    
                   
                   
            &      
             3      
            A      
            p      
            u      
                   
      j            
                  
      p            
                  
                   
                  
                    
                  
                  
      S            
                  
                   
            &      
      )      3      
            @      
            M      
      ,      Z      
      M       g      
            t      
                  
                  
      7            
      |            
      '            
                   
                  
                  
                  
                  
                   
                  
                  
             *      
            7      
            D      
      .      Q      
      X      ^      
            k      
      h      y      
                  
      H            
      	            
                  
                  
                  
                  
      q      	      
            5      
      p      A      
      J      T      
            Z      
            `      
            q      
      q       ~      
      ^            
                  
      &             
                  
      :            
      _                               
   	                
   	                       )            
            &                  I      
   	   C       M      
   	   =       R      
      \      ^      
   	          b      
   	          g                  {      
                         @            
   	                
   	                
                  
   	               
   	               
                  
   	   n            
   	   X            
                                          R            
                    
   	               
   	                     p      *                    ?            u      M      
            Y                   {      
   	               
   	               
   	   *            
   	   (                              
      I            
                  
      D            
      x                        "      
   	   Q      &      
   	   M      5      
   	         9      
   	         ?      
      Q      K                         
   	               
   	               
   	               
   	               
                                     
   	   S            
   	   O            
   	               
   	               
                               :      
   	         >      
   	         Y      
   	   P      ]      
   	   L      c      
            o            @             
   	               
   	               
                                      
   	               
   	         	      
             	      
             	      
             	      
             	      
            !	      
             (	      
            ,	      
                                       
                                   (                                          4             @       H                    \                    p                                                                        @                                              .symtab .strtab .shstrtab .rela.text .data .bss .rodata.str1.8 .rodata.cst4 .rela.debug_info .debug_abbrev .rela.debug_loc .rela.debug_aranges .debug_ranges .rela.debug_line .debug_str .comment .note.GNU-stack .note.gnu.property .rela.eh_frame                                                                                          @       )                                   @               $                                 &                     i                                     ,                     i                                     1      2               p                                   @                                                        R                            5	                             M      @               %                                ^                                                         q                            ^                             l      @               @5                
                                             0                              |      @               X5      0                                                 )      0                                                    Y                                         @               5                                       0               C                                        0               :      ,                                                   f                                                          h                                                                                                    @               5                                                              `                          	                      #                                                          6                                    /* ------------------------------------------------------------- */
/* support for tcc_run() */

#ifdef __leading_underscore
# define _(s) s
#else
# define _(s) _##s
#endif

#ifndef _WIN32
extern void (*_(_init_array_start)[]) (int argc, char **argv, char **envp);
extern void (*_(_init_array_end)[]) (int argc, char **argv, char **envp);
static void run_ctors(int argc, char **argv, char **env)
{
    int i = 0;
    while (&_(_init_array_start)[i] != _(_init_array_end))
        (*_(_init_array_start)[i++])(argc, argv, env);
}
#endif

extern void (*_(_fini_array_start)[]) (void);
extern void (*_(_fini_array_end)[]) (void);
static void run_dtors(void)
{
    int i = 0;
    while (&_(_fini_array_end)[i] != _(_fini_array_start))
        (*_(_fini_array_end)[--i])();
}

static void *rt_exitfunc[32];
static void *rt_exitarg[32];
static int __rt_nr_exit;

void __run_on_exit(int ret)
{
    int n = __rt_nr_exit;
    while (n)
	--n, ((void(*)(int,void*))rt_exitfunc[n])(ret, rt_exitarg[n]);
}

int on_exit(void *function, void *arg)
{
    int n = __rt_nr_exit;
    if (n < 32) {
	rt_exitfunc[n] = function;
	rt_exitarg[n] = arg;
        __rt_nr_exit = n + 1;
        return 0;
    }
    return 1;
}

int atexit(void (*function)(void))
{
    return on_exit(function, 0);
}

typedef struct rt_frame {
    void *ip, *fp, *sp;
} rt_frame;

__attribute__((noreturn)) void __rt_exit(rt_frame *, int);

void exit(int code)
{
    rt_frame f;
    run_dtors();
    __run_on_exit(code);
    f.fp = 0;
    f.ip = exit;
    __rt_exit(&f, code);
}

#ifndef _WIN32
int main(int, char**, char**);

int _runmain(int argc, char **argv, char **envp)
{
    int ret;
    run_ctors(argc, argv, envp);
    ret = main(argc, argv, envp);
    run_dtors();
    __run_on_exit(ret);
    return ret;
}
#endif
// for libtcc1, avoid including files that are not part of tcc
// #include <stdint.h>
#define uint8_t unsigned char
#define uint16_t unsigned short
#define uint32_t unsigned int
#define uint64_t unsigned long long
#define bool _Bool
#define false 0
#define true 1
#define __ATOMIC_RELAXED 0
#define __ATOMIC_CONSUME 1
#define __ATOMIC_ACQUIRE 2
#define __ATOMIC_RELEASE 3
#define __ATOMIC_ACQ_REL 4
#define __ATOMIC_SEQ_CST 5
typedef __SIZE_TYPE__ size_t;

#define ATOMIC_GEN_OP(TYPE, MODE, NAME, OP, RET) \
    TYPE __atomic_##NAME##_##MODE(volatile void *atom, TYPE value, int memorder) \
    { \
        TYPE xchg, cmp; \
        __atomic_load((TYPE *)atom, (TYPE *)&cmp, __ATOMIC_RELAXED); \
        do { \
            xchg = (OP); \
        } while (!__atomic_compare_exchange((TYPE *)atom, &cmp, &xchg, true, \
                                            __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)); \
        return RET; \
    }

#define ATOMIC_EXCHANGE(TYPE, MODE) \
    ATOMIC_GEN_OP(TYPE, MODE, exchange, value, cmp)
#define ATOMIC_ADD_FETCH(TYPE, MODE) \
    ATOMIC_GEN_OP(TYPE, MODE, add_fetch, (cmp + value), xchg)
#define ATOMIC_SUB_FETCH(TYPE, MODE) \
    ATOMIC_GEN_OP(TYPE, MODE, sub_fetch, (cmp - value), xchg)
#define ATOMIC_AND_FETCH(TYPE, MODE) \
    ATOMIC_GEN_OP(TYPE, MODE, and_fetch, (cmp & value), xchg)
#define ATOMIC_OR_FETCH(TYPE, MODE) \
    ATOMIC_GEN_OP(TYPE, MODE, or_fetch, (cmp | value), xchg)
#define ATOMIC_XOR_FETCH(TYPE, MODE) \
    ATOMIC_GEN_OP(TYPE, MODE, xor_fetch, (cmp ^ value), xchg)
#define ATOMIC_NAND_FETCH(TYPE, MODE) \
    ATOMIC_GEN_OP(TYPE, MODE, nand_fetch, ~(cmp & value), xchg)
#define ATOMIC_FETCH_ADD(TYPE, MODE) \
    ATOMIC_GEN_OP(TYPE, MODE, fetch_add, (cmp + value), cmp)
#define ATOMIC_FETCH_SUB(TYPE, MODE) \
    ATOMIC_GEN_OP(TYPE, MODE, fetch_sub, (cmp - value), cmp)
#define ATOMIC_FETCH_AND(TYPE, MODE) \
    ATOMIC_GEN_OP(TYPE, MODE, fetch_and, (cmp & value), cmp)
#define ATOMIC_FETCH_OR(TYPE, MODE) \
    ATOMIC_GEN_OP(TYPE, MODE, fetch_or, (cmp | value), cmp)
#define ATOMIC_FETCH_XOR(TYPE, MODE) \
    ATOMIC_GEN_OP(TYPE, MODE, fetch_xor, (cmp ^ value), cmp)
#define ATOMIC_FETCH_NAND(TYPE, MODE) \
    ATOMIC_GEN_OP(TYPE, MODE, fetch_nand, ~(cmp & value), cmp)

#define ATOMIC_GEN(TYPE, SIZE) \
    ATOMIC_EXCHANGE(TYPE, SIZE) \
    ATOMIC_ADD_FETCH(TYPE, SIZE) \
    ATOMIC_SUB_FETCH(TYPE, SIZE) \
    ATOMIC_AND_FETCH(TYPE, SIZE) \
    ATOMIC_OR_FETCH(TYPE, SIZE) \
    ATOMIC_XOR_FETCH(TYPE, SIZE) \
    ATOMIC_NAND_FETCH(TYPE, SIZE) \
    ATOMIC_FETCH_ADD(TYPE, SIZE) \
    ATOMIC_FETCH_SUB(TYPE, SIZE) \
    ATOMIC_FETCH_AND(TYPE, SIZE) \
    ATOMIC_FETCH_OR(TYPE, SIZE) \
    ATOMIC_FETCH_XOR(TYPE, SIZE) \
    ATOMIC_FETCH_NAND(TYPE, SIZE)

ATOMIC_GEN(uint8_t, 1)
ATOMIC_GEN(uint16_t, 2)
ATOMIC_GEN(uint32_t, 4)
ATOMIC_GEN(uint64_t, 8)

/* uses alias to allow building with gcc/clang */
#ifdef __TINYC__
#define ATOMIC(x)      __atomic_##x
#else
#define ATOMIC(x)      __tcc_atomic_##x
#endif

bool ATOMIC(is_lock_free) (unsigned long size, const volatile void *ptr)
{
    bool ret;

    switch (size) {
    case 1: ret = true; break;
    case 2: ret = true; break;
    case 4: ret = true; break;
#if defined __x86_64__ || defined __aarch64__ || defined __riscv
    case 8: ret = true; break;
#else
    case 8: ret = false; break;
#endif
    default: ret = false; break;
    }
    return ret;
}

#ifndef __TINYC__
bool __atomic_is_lock_free(unsigned long size, const volatile void *ptr) __attribute__((alias("__tcc_atomic_is_lock_free")));
#endif
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#ifndef _WIN32
#include <unistd.h>
#include <errno.h>
#else
#include <windows.h>
#include <io.h>
#endif

/* section layout (all little endian):
   32bit offset to executable/so file name
     filename \0
       function name \0
       align to 64 bits
       64bit function start line
         64bits end_line(28bits) / start_line(28bits) / flag=0xff(8bits)
	 64bits counter
       \0
     \0
   \0
   executable/so file name \0
 */

typedef struct tcov_line {
    unsigned int fline;
    unsigned int lline;
    unsigned long long count;
} tcov_line;

typedef struct tcov_function {
    char *function;
    unsigned int first_line;
    unsigned int n_line;
    unsigned int m_line;
    tcov_line *line;
} tcov_function;

typedef struct tcov_file {
    char *filename;
    unsigned int n_func;
    unsigned int m_func;
    tcov_function *func;
    struct tcov_file *next;
} tcov_file;

static FILE *open_tcov_file (char *cov_filename)
{
    int fd;
#ifndef _WIN32
    struct flock lock;

    lock.l_type = F_WRLCK;
    lock.l_whence = SEEK_SET;
    lock.l_start = 0;
    lock.l_len = 0; /* Until EOF.  */
    lock.l_pid = getpid ();
#endif
    fd = open (cov_filename, O_RDWR | O_CREAT, 0666);
    if (fd < 0)
	return NULL;
  
#ifndef _WIN32
    while (fcntl (fd, F_SETLKW, &lock) && errno == EINTR)
        continue;
#else
    {
        OVERLAPPED overlapped = { 0 };
        LockFileEx((HANDLE)_get_osfhandle(fd), LOCKFILE_EXCLUSIVE_LOCK,
		   0, 1, 0, &overlapped);
    }
#endif

    return fdopen (fd, "r+");
}

static unsigned long long get_value(unsigned char *p, int size)
{
    unsigned long long value = 0;

    p += size;
    while (size--)
 	value = (value << 8) | *--p;
    return value;
}

static int sort_func (const void *p, const void *q)
{
    const tcov_function *pp = (const tcov_function *) p;
    const tcov_function *pq = (const tcov_function *) q;

    return pp->first_line > pq->first_line ? 1 :
	   pp->first_line < pq->first_line ? -1 : 0;
}

static int sort_line (const void *p, const void *q)
{
    const tcov_line *pp = (const tcov_line *) p;
    const tcov_line *pq = (const tcov_line *) q;

    return pp->fline > pq->fline ? 1 :
	   pp->fline < pq->fline ? -1 :
           pp->count < pq->count ? 1 :
	   pp->count > pq->count ? -1 : 0;
}

/* sort to let inline functions work */
static tcov_file *sort_test_coverage (unsigned char *p)
{
    int i, j, k;
    unsigned char *start = p;
    tcov_file *file = NULL;
    tcov_file *nfile;

    p += 4;
    while (*p) {
        char *filename = (char *)p;
	size_t len = strlen (filename);

	nfile = file;
	while (nfile) {
	    if (strcmp (nfile->filename, filename) == 0)
		break;
	    nfile = nfile->next;
	}
	if (nfile == NULL) {
	    nfile = malloc (sizeof(tcov_file));
	    if (nfile == NULL) {
	        fprintf (stderr, "Malloc error test_coverage\n");
	        return file;
    	    }
	    nfile->filename = filename;
	    nfile->n_func = 0;
	    nfile->m_func = 0;
	    nfile->func = NULL;
	    nfile->next = NULL;
	    if (file == NULL)
	        file = nfile;
	    else {
		tcov_file *lfile = file;

	        while (lfile->next)
		    lfile = lfile->next;
		lfile->next = nfile;
	    }
	}
	p += len + 1;
	while (*p) {
	    int i;
	    char *function = (char *)p;
	    tcov_function *func;

	    p += strlen (function) + 1;
	    p += -(p - start) & 7;
	    for (i = 0; i < nfile->n_func; i++) {
		func = &nfile->func[i];
		if (strcmp (func->function, function) == 0)
		    break;
	    }
	    if (i == nfile->n_func) {
	        if (nfile->n_func >= nfile->m_func) {
		    nfile->m_func = nfile->m_func == 0 ? 4 : nfile->m_func * 2;
		    nfile->func = realloc (nfile->func,
					   nfile->m_func *
					   sizeof (tcov_function));
		    if (nfile->func == NULL) {
		        fprintf (stderr, "Realloc error test_coverage\n");
		        return file;
		    }
	        }
	        func = &nfile->func[nfile->n_func++];
	        func->function = function;
	        func->first_line = get_value (p, 8);
	        func->n_line = 0;
	        func->m_line = 0;
	        func->line = NULL;
	    }
	    p += 8;
	    while (*p) {
		tcov_line *line;
		unsigned long long val;

		if (func->n_line >= func->m_line) {
		    func->m_line = func->m_line == 0 ? 4 : func->m_line * 2;
		    func->line = realloc (func->line,
					  func->m_line * sizeof (tcov_line));
		    if (func->line == NULL) {
		        fprintf (stderr, "Realloc error test_coverage\n");
		        return file;
		    }
		}
		line = &func->line[func->n_line++];
		val = get_value (p, 8);
	        line->fline = (val >> 8) & 0xfffffffULL;
	        line->lline = val >> 36;
	        line->count = get_value (p + 8, 8);
	 	p += 16;
	    }
	    p++;
	}
	p++;
    }
    nfile = file;
    while (nfile) {
	qsort (nfile->func, nfile->n_func, sizeof (tcov_function), sort_func);
	for (i = 0; i < nfile->n_func; i++) {
	    tcov_function *func = &nfile->func[i];
	    qsort (func->line, func->n_line, sizeof (tcov_line), sort_line);
        }
	nfile = nfile->next;
    }
    return file;
}

/* merge with previous tcov file */
static void merge_test_coverage (tcov_file *file, FILE *fp,
				 unsigned int *pruns)
{
    unsigned int runs;
    char *p;
    char str[10000];
    
    *pruns = 1;
    if (fp == NULL)
        return;
    if (fgets(str, sizeof(str), fp) &&
        (p = strrchr (str, ':')) &&
        (sscanf (p + 1, "%u", &runs) == 1)) 
        *pruns = runs + 1;
    while (file) {
	int i;
	size_t len = strlen (file->filename);

	while (fgets(str, sizeof(str), fp) &&
	       (p = strstr(str, "0:File:")) == NULL) {}
        if ((p = strstr(str, "0:File:")) == NULL ||
	    strncmp (p + strlen("0:File:"), file->filename, len) != 0 ||
	    p[strlen("0:File:") + len] != ' ')
	    break;
	for (i = 0; i < file->n_func; i++) {
	    int j;
	    tcov_function *func = &file->func[i];
	    unsigned int next_zero = 0;
	    unsigned int curline = 0;

	    for (j = 0; j < func->n_line; j++) {
		tcov_line *line = &func->line[j];
	        unsigned int fline = line->fline;
	        unsigned long long count;
		unsigned int tmp;
		char c;

		while (curline < fline &&
		       fgets(str, sizeof(str), fp))
		    if ((p = strchr(str, ':')) &&
			sscanf (p + 1, "%u", &tmp) == 1)
			curline = tmp;
		if (sscanf (str, "%llu%c\n", &count, &c) == 2) {
		    if (next_zero == 0)
		        line->count += count;
		    next_zero = c == '*';
		}
	    }
	}
	file = file->next;
    }
}

/* store tcov data in file */
void __store_test_coverage (unsigned char * p)
{
    int i, j;
    unsigned int files;
    unsigned int funcs;
    unsigned int blocks;
    unsigned int blocks_run;
    unsigned int runs;
    char *cov_filename = (char *)p + get_value (p, 4);
    FILE *fp;
    char *q;
    tcov_file *file;
    tcov_file *nfile;
    tcov_function *func;

    fp = open_tcov_file (cov_filename);
    if (fp == NULL) {
	fprintf (stderr, "Cannot create coverage file: %s\n", cov_filename);
	return;
    }
    file = sort_test_coverage (p);
    merge_test_coverage (file, fp, &runs);
    fseek (fp, 0, SEEK_SET);
    fprintf (fp, "        -:    0:Runs:%u\n", runs);
    files = 0;
    funcs = 0;
    blocks = 0;
    blocks_run = 0;
    nfile = file;
    while (nfile) {
	files++;
	for (i = 0; i < nfile->n_func; i++) {
	    func = &nfile->func[i];
	    funcs++;
	    for (j = 0; j < func->n_line; j++) {
		blocks++;
		blocks_run += func->line[j].count != 0;
	    }
	}
	nfile = nfile->next;
    }
    if (blocks == 0)
	blocks = 1;
    fprintf (fp, "        -:    0:All:%s Files:%u Functions:%u %.02f%%\n",
	     cov_filename, files, funcs, 100.0 * (double) blocks_run / blocks);
    nfile = file;
    while (nfile) {
	FILE *src = fopen (nfile->filename, "r");
	unsigned int curline = 1;
	char str[10000];

        if (src == NULL)
	     goto next;
	funcs = 0;
	blocks = 0;
	blocks_run = 0;
	for (i = 0; i < nfile->n_func; i++) {
	    func = &nfile->func[i];
	    funcs++;
	    for (j = 0; j < func->n_line; j++) {
		blocks++;
		blocks_run += func->line[j].count != 0;
	    }
	}
	if (blocks == 0)
	    blocks = 1;
        fprintf (fp, "        -:    0:File:%s Functions:%u %.02f%%\n",
		 nfile->filename, funcs, 100.0 * (double) blocks_run / blocks);
        for (i = 0; i < nfile->n_func; i++) {
	    func = &nfile->func[i];
	
	    while (curline < func->first_line &&
		   fgets(str, sizeof(str), src))
		fprintf (fp, "        -:%5u:%s", curline++, str);
	    blocks = 0;
	    blocks_run = 0;
	    for (j = 0; j < func->n_line; j++) {
		blocks++;
		blocks_run += func->line[j].count != 0;
	    }
	    if (blocks == 0)
		blocks = 1;
            fprintf (fp, "        -:    0:Function:%s %.02f%%\n",
		     func->function, 100.0 * (double) blocks_run / blocks);
#if 0
	    for (j = 0; j < func->n_line; j++) {
	        unsigned int fline = func->line[j].fline;
	        unsigned int lline = func->line[j].lline;
		unsigned long long count = func->line[j].count;

		fprintf (fp, "%u %u %llu\n", fline, lline, count);
	    }
#endif
	    for (j = 0; j < func->n_line;) {
	        unsigned int fline = func->line[j].fline;
	        unsigned int lline = func->line[j].lline;
	        unsigned long long count = func->line[j].count;
		unsigned int has_zero = 0;
		unsigned int same_line = fline == lline;

		j++;
		while (j < func->n_line) {
	            unsigned int nfline = func->line[j].fline;
	            unsigned int nlline = func->line[j].lline;
	            unsigned long long ncount = func->line[j].count;

		    if (fline == nfline) {
			if (ncount == 0)
			    has_zero = 1;
			else if (ncount > count)
			    count =  ncount;
			same_line = nfline == nlline;
			lline = nlline;
			j++;
		    }
		    else
			break;
		}
		if (same_line)
		     lline++;

	        while (curline < fline &&
		       fgets(str, sizeof(str), src))
		     fprintf (fp, "        -:%5u:%s", curline++, str);
		while (curline < lline &&
		       fgets(str, sizeof(str), src)) {
		    if (count == 0)
		        fprintf (fp, "    #####:%5u:%s",
				 curline, str);
		    else if (has_zero)
		        fprintf (fp, "%8llu*:%5u:%s", 
				 count, curline, str);
		    else
		        fprintf (fp, "%9llu:%5u:%s",
				 count, curline, str);
		    curline++;
		}
	    }
	}
	while (fgets(str, sizeof(str), src))
	    fprintf (fp, "        -:%5u:%s", curline++, str);
	fclose (src);
next:
	nfile = nfile->next;
    }
    while (file) {
        for (i = 0; i < file->n_func; i++) {
	    func = &file->func[i];
	    free (func->line);
        }
	free (file->func);
	nfile = file;
	file = file->next;
	free (nfile);
    }
    fclose (fp);
}
/* va_list.c - tinycc support for va_list on X86_64 */

#if defined __x86_64__

/* Avoid include files, they may not be available when cross compiling */
extern void abort(void);

/* This should be in sync with our include/stdarg.h */
enum __va_arg_type {
    __va_gen_reg, __va_float_reg, __va_stack
};

/* GCC compatible definition of va_list. */
/*predefined by TCC (tcc_predefs.h):
typedef struct {
    unsigned int gp_offset;
    unsigned int fp_offset;
    union {
        unsigned int overflow_offset;
        char *overflow_arg_area;
    };
    char *reg_save_area;
} __builtin_va_list[1];
*/

extern void *memcpy(void *dest, const void *src, unsigned long n);

void *__va_arg(__builtin_va_list ap,
               int arg_type,
               int size, int align)
{
    size = (size + 7) & ~7;
    align = (align + 7) & ~7;
    switch ((enum __va_arg_type)arg_type) {
    case __va_gen_reg:
        if (ap->gp_offset + size <= 48) {
            ap->gp_offset += size;
            return ap->reg_save_area + ap->gp_offset - size;
        }
        goto use_overflow_area;

    case __va_float_reg:
        if (ap->fp_offset < 128 + 48) {
            ap->fp_offset += 16;
            if (size == 8)
                return ap->reg_save_area + ap->fp_offset - 16;
            if (ap->fp_offset < 128 + 48) {
                memcpy(ap->reg_save_area + ap->fp_offset - 8,
                       ap->reg_save_area + ap->fp_offset, 8);
                ap->fp_offset += 16;
                return ap->reg_save_area + ap->fp_offset - 32;
            }
        }
        goto use_overflow_area;

    case __va_stack:
    use_overflow_area:
        ap->overflow_arg_area += size;
        ap->overflow_arg_area = (char*)((long long)(ap->overflow_arg_area + align - 1) & -align);
        return ap->overflow_arg_area - size;

    default: /* should never happen */
        abort();
        return 0;
    }
}
#endif
